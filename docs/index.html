<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ File Container - Real IndexedDB Storage</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: visible;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .github-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-block;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .main-content {
            padding: 30px;
        }

        /* Tab System Styles */
        .tab-container {
            margin-bottom: 30px;
        }

        .tab-nav {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            border: 1px solid #e9ecef;
            border-bottom: none;
            overflow: hidden;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            position: relative;
        }

        .tab-button:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 0 0 10px 10px;
            padding: 25px;
            min-height: 200px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* File Selection Styles */
        .file-selection-area {
            background: #f8f9fa;
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            transition: all 0.3s;
        }

        .file-selection-area.has-selection {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .file-selection-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .selected-files-preview {
            margin-top: 15px;
            display: none;
        }

        .selected-files-preview.show {
            display: block;
        }

        .selected-file-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin: 5px 0;
        }

        .file-icon {
            width: 32px;
            height: 32px;
            margin-right: 10px;
            font-size: 24px;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: #333;
        }

        .file-size {
            font-size: 12px;
            color: #666;
        }

        .file-preview {
            width: 40px;
            height: 40px;
            margin-left: 10px;
            border-radius: 4px;
            object-fit: cover;
        }

        .remove-file {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 12px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }

        .section h2::before {
            content: "üìÅ";
            margin-right: 10px;
            font-size: 1.2em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .btn-success {
            background: linear-gradient(135deg, #20bf6b, #26de81);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffa726, #ff7043);
        }

        .file-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        /* View Toggle Styles */
        .view-toggle {
            display: flex;
            gap: 5px;
            background: #f8f9fa;
            padding: 3px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .view-btn {
            background: transparent;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #6c757d;
            transition: all 0.3s ease;
        }

        .view-btn:hover {
            background: #e9ecef;
            color: #495057;
        }

        .view-btn.active {
            background: #667eea;
            color: white;
        }

        /* Quick Actions Styles */
        .quick-actions {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5a67d8, #6b46c1);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #5a6268, #343a40);
            transform: translateY(-1px);
        }

        /* Grid View Styles */
        .file-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .file-list.grid-view .file-item,
        .file-list.grid-view .folder-item {
            text-align: center;
            padding: 15px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .file-list.grid-view .file-icon {
            font-size: 2.5em;
            margin-bottom: 8px;
        }

        .file-list.grid-view .file-name {
            font-size: 12px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            max-width: 100%;
        }

        .file-list.grid-view .file-info {
            font-size: 10px;
            margin-top: 5px;
        }

        /* List View Styles */
        .file-list.list-view {
            display: block;
        }

        .file-list.list-view .file-item,
        .file-list.list-view .folder-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            margin-bottom: 10px;
            text-align: left;
        }

        .file-list.list-view .file-icon {
            font-size: 1.5em;
            margin-right: 15px;
            min-width: 30px;
        }

        .file-list.list-view .file-details {
            flex: 1;
        }

        .file-list.list-view .file-actions {
            margin-left: auto;
        }

        .file-item, .folder-item {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s;
        }

        .file-item:hover, .folder-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .folder-item {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            border-color: #fdcb6e;
        }

        .file-name, .folder-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            word-break: break-word;
        }

        .file-info {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
        }

        .file-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .media-preview {
            margin: 10px 0;
            text-align: center;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .media-preview-placeholder {
            margin: 10px 0;
            text-align: center;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
            cursor: pointer;
            transition: all 0.3s;
        }

        .media-preview-placeholder:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .preview-icon {
            font-size: 2em;
            margin-bottom: 8px;
            color: #6c757d;
        }

        .preview-text {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .media-preview img, .media-preview video {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .media-preview img:hover {
            transform: scale(1.05);
        }

        .image-modal {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        /* Floating Toast Notification System */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 400px;
            pointer-events: none;
        }

        .toast {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            margin-bottom: 12px;
            padding: 16px 20px 16px 16px;
            border-left: 4px solid #667eea;
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            font-weight: 500;
            line-height: 1.4;
            min-height: 20px;
            display: flex;
            align-items: center;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.hide {
            transform: translateX(100%);
            opacity: 0;
        }

        .toast-success {
            border-left-color: #10B981;
            background: linear-gradient(135deg, #D1FAE5 0%, #ECFDF5 100%);
            color: #065F46;
        }

        .toast-success::before {
            content: '‚úì';
            margin-right: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .toast-error {
            border-left-color: #EF4444;
            background: linear-gradient(135deg, #FEE2E2 0%, #FEF2F2 100%);
            color: #991B1B;
        }

        .toast-error::before {
            content: '‚úï';
            margin-right: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .toast-warning {
            border-left-color: #F59E0B;
            background: linear-gradient(135deg, #FEF3C7 0%, #FFFBEB 100%);
            color: #92400E;
        }

        .toast-warning::before {
            content: '!';
            margin-right: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .toast-info {
            border-left-color: #3B82F6;
            background: linear-gradient(135deg, #DBEAFE 0%, #EFF6FF 100%);
            color: #1E40AF;
        }

        .toast-info::before {
            content: 'i';
            margin-right: 8px;
            font-size: 12px;
            font-weight: bold;
            font-style: italic;
        }

        .toast-message {
            flex: 1;
            padding-right: 8px;
        }

        .toast-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
            color: inherit;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .toast-close:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: currentColor;
            opacity: 0.3;
            border-radius: 0 0 12px 12px;
            animation: toast-progress-animation linear;
        }

        @keyframes toast-progress-animation {
            from { width: 100%; }
            to { width: 0%; }
        }

        /* Progress Container Styles */
        .progress-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
            pointer-events: none;
        }

        .global-progress {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #F3F4F6;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3B82F6, #1D4ED8);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 12px;
            color: #6B7280;
            text-align: center;
        }

        .active-operations {
            max-height: 300px;
            overflow-y: auto;
        }

        .operation-item {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 4px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            pointer-events: auto;
        }

        .operation-title {
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }

        .operation-progress {
            width: 100%;
            height: 4px;
            background: #F3F4F6;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .operation-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #059669);
            border-radius: 2px;
            transition: width 0.2s ease;
            width: 0%;
        }

        .operation-status {
            color: #6B7280;
            font-size: 11px;
        }

        /* Sync Status Styles */
        .sync-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            pointer-events: auto;
        }

        .sync-indicator {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .sync-indicator:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .sync-icon {
            font-size: 14px;
            animation: none;
        }

        .sync-icon.syncing {
            animation: rotate 1s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .sync-text {
            color: #374151;
            font-weight: 500;
        }

        .last-sync {
            color: #6B7280;
        }

        .sync-toggle {
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .sync-toggle:hover {
            background: #2563EB;
        }

        .sync-toggle.disabled {
            background: #9CA3AF;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .progress-container {
                right: 10px;
                top: 70px;
                max-width: calc(100vw - 20px);
            }
            
            .sync-status {
                bottom: 10px;
                right: 10px;
            }
        }

        /* Mobile responsive */
        @media (max-width: 480px) {
            .toast-container {
                left: 20px;
                right: 20px;
                max-width: none;
            }
            
            .toast {
                margin-bottom: 8px;
                padding: 12px 16px 12px 12px;
            }
        }

        /* Legacy alert styles for compatibility */
        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            display: none; /* Hide old alerts */
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #20bf6b;
            background: #f0fff4;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .breadcrumb {
            flex: 1;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            margin-right: 5px;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        /* Back Button Styles */
        .back-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 15px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .back-button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .back-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .breadcrumb-container {
            display: flex;
            align-items: center;
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .storage-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .storage-bar {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            margin-top: 10px;
            overflow: hidden;
        }

        .storage-fill {
            background: linear-gradient(135deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s;
        }

        .data-management {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 15px;
            }
            
            .file-list {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .file-actions {
                justify-content: center;
            }

            .data-management {
                flex-direction: column;
            }
        }

        /* ============================================================================ */
        /* DROPDOWN UTILITIES MENU */
        /* ============================================================================ */
        
        .utilities-dropdown {
            position: relative;
            display: inline-block;
        }

        .utilities-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .utilities-btn:hover {
            background: linear-gradient(135deg, #5a67d8, #6b46c1);
            transform: translateY(-1px);
        }

        .utilities-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: white;
            min-width: 250px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border-radius: 12px;
            z-index: 9999;
            border: 1px solid #e2e8f0;
            padding: 8px 0;
            margin-top: 5px;
            left:0;
        }

        .utilities-dropdown-content.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dropdown-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dropdown-item:hover {
            background-color: #f8fafc;
        }

        .dropdown-divider {
            height: 1px;
            background-color: #e2e8f0;
            margin: 8px 0;
        }

        /* Collapsible Sections */
        .collapsible-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
            overflow: hidden;
        }

        .collapsible-header {
            padding: 15px;
            background: linear-gradient(135deg, #f8a4a4, #f8f9fa);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
            border-bottom: 1px solid #dee2e6;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, #dee2e6, #a1c5ea);
        }

        .collapsible-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .collapsible-toggle {
            font-size: 14px;
            color: #f4c2c2;
            transition: transform 0.3s ease;
        }

        .collapsible-content {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 15px;
            color: #333;
        }

        .collapsible-section:not(.collapsed) .collapsible-content {
            max-height: 1000px;
            padding: 15px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 500px;
            }
        }

        .collapsible-section.collapsed .collapsible-toggle {
            transform: rotate(-90deg);
        }

        /* ============================================================================ */
        /* PAGINATION AND LOADING STYLES */
        /* ============================================================================ */

        .loading-status {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .loading-text {
            font-weight: 500;
            color: #495057;
            margin-right: 15px;
        }

        .cache-info {
            font-size: 12px;
            color: #6c757d;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .pagination-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .pagination-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 500;
            color: #495057;
        }

        .cache-status {
            font-size: 12px;
            color: #6c757d;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .cache-status.cached {
            background: #d1ecf1;
            color: #0c5460;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .pagination-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .pagination-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .pagination-numbers {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .page-number {
            padding: 8px 12px;
            border: 1px solid #e9ecef;
            background: white;
            color: #495057;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 500;
            transition: all 0.3s;
            cursor: pointer;
        }

        .page-number:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .page-number.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pagination-options {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .pagination-options label {
            font-weight: 500;
            color: #495057;
        }

        .pagination-options select {
            padding: 6px 10px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background: white;
            font-weight: 500;
        }

        .btn-small {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            transition: all 0.3s;
        }

        .btn-small:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        /* Mobile responsiveness for pagination */
        @media (max-width: 768px) {
            .pagination-controls {
                flex-direction: column;
                gap: 15px;
            }

            .pagination-numbers {
                order: 1;
            }

            .pagination-btn {
                order: 2;
                width: 120px;
            }

            .pagination-options {
                flex-direction: column;
                gap: 10px;
            }

            .pagination-info {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }

        /* ============================================================================ */
        /* PUBLIC LINK FUNCTIONALITY */
        /* ============================================================================ */

        .btn-share {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-share:hover {
            background: linear-gradient(135deg, #1e7e34, #17a2b8);
            transform: translateY(-1px);
        }

        .public-link-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            overflow-y: auto;
            padding: 20px 0;
        }

        .public-link-modal-content {
            background-color: white;
            margin: 20px auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            overflow-y: auto;
            position: relative;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .public-link-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .public-link-header h3 {
            color: #333;
            font-size: 1.4em;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: #f8f9fa;
            color: #333;
        }

        .link-config-section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
        }

        .link-config-section h4 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.1em;
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .config-row:last-child {
            margin-bottom: 0;
        }

        .config-label {
            flex: 1;
            font-weight: 500;
            color: #555;
        }

        .config-input {
            flex: 2;
            margin-left: 15px;
        }

        .config-input select,
        .config-input input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .generated-link-section {
            margin-top: 25px;
            padding: 20px;
            background: #e7f3ff;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .link-display {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .link-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #333;
        }

        .link-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-copy,
        .btn-qr {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-copy:hover,
        .btn-qr:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-1px);
        }

        .qr-code-container {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            border: 1px solid #ddd;
        }

        .link-stats {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            font-size: 14px;
        }

        .link-stats h5 {
            margin-bottom: 10px;
            color: #856404;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #856404;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 3px;
        }

        /* ============================================================================ */
        /* PUBLIC LINKS MANAGER MODAL */
        /* ============================================================================ */

        .links-manager-modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            overflow-y: auto;
            padding: 20px 0;
        }

        .links-manager-content {
            background-color: white;
            margin: 20px auto;
            padding: 30px;
            border-radius: 15px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            overflow-y: auto;
            position: relative;
        }

        .links-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .links-table th,
        .links-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .links-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #333;
            position: sticky;
            top: 0;
        }

        .links-table tr:hover {
            background-color: #f8f9fa;
        }

        .links-table tr.selected {
            background-color: #e3f2fd !important;
        }

        .links-table tr.selected:hover {
            background-color: #bbdefb !important;
        }

        .checkbox-cell {
            width: 40px;
            text-align: center;
        }

        .link-checkbox {
            transform: scale(1.2);
            cursor: pointer;
        }

        .selection-actions {
            display: none;
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #2196f3;
        }

        .selection-actions.show {
            display: block;
        }

        .selected-count {
            font-weight: bold;
            color: #1976d2;
        }

        .statistics-panel {
            display: none;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .statistics-panel.show {
            display: block;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #dee2e6;
        }

        .stats-grid-detailed {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-card h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .link-details {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: 500;
            color: #666;
        }

        .detail-value {
            color: #333;
        }

        .link-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-active {
            background-color: #d4edda;
            color: #155724;
        }

        .status-expired {
            background-color: #f8d7da;
            color: #721c24;
        }

        .link-actions-cell {
            white-space: nowrap;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            margin: 2px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-edit {
            background: #007bff;
            color: white;
        }

        .btn-edit:hover {
            background: #0056b3;
        }

        .btn-delete-link {
            background: #dc3545;
            color: white;
        }

        .btn-delete-link:hover {
            background: #c82333;
        }

        .btn-copy-small {
            background: #28a745;
            color: white;
        }

        .btn-copy-small:hover {
            background: #1e7e34;
        }

        .no-links-message {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .manager-actions {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .link-url {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #666;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ File Container</h1>
            <p>Real GitHub Repository Storage dengan Auto-Chunking (20MB chunks)</p>
            <div class="github-badge">
                üåê GitHub API Integration - Data tersimpan di Repository
            </div>
            
            <!-- Cache Clear Notice -->
            <div class="collapsible-section collapsed" id="cacheNoticeSection">
                <div class="collapsible-header" onclick="toggleCollapsible('cacheNoticeSection')">
                    <h3>üí° Troubleshooting - Cache Clear Notice</h3>
                    <span class="collapsible-toggle">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div style="background: rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 6px; font-size: 13px; border-left: 3px solid #ffd700;">
                        <strong>Jika melihat error 404 API:</strong> Hard refresh browser Anda!
                        <br>‚Ä¢ Windows/Linux: <kbd style="background: rgba(0,0,0,0.2); padding: 2px 4px; border-radius: 3px;">Ctrl + F5</kbd>
                        ‚Ä¢ Mac: <kbd style="background: rgba(0,0,0,0.2); padding: 2px 4px; border-radius: 3px;">Cmd + Shift + R</kbd>
                        <br>‚Ä¢ Atau buka Developer Tools (F12) ‚Üí Application/Storage ‚Üí Clear Storage
                    </div>
                </div>
            </div>
        </div>

        <!-- GitHub Configuration Section -->
        <div class="collapsible-section collapsed" id="githubConfigSection">
            <div class="collapsible-header" onclick="toggleCollapsible('githubConfigSection')">
                <h3>‚öôÔ∏è GitHub Configuration - Real Persistent Storage</h3>
                <span class="collapsible-toggle">‚ñº</span>
            </div>
            <div class="collapsible-content">
                <div class="github-config" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                    <div class="config-item">
                        <label><strong>Repository:</strong> </label>
                        <span id="repoInfo">krasyid822/file-container</span>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">Files stored permanently in GitHub repo</div>
                    </div>
                    <div class="config-item">
                        <label><strong>Token Status:</strong> </label>
                        <span id="tokenStatus">‚ùå Not configured</span>
                        <button onclick="configureGitHubToken()" class="btn" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">üîß Setup Token</button>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">Required for permanent storage</div>
                    </div>
                    <div class="config-item">
                        <label><strong>Storage Mode:</strong> </label>
                        <select id="storageMode" onchange="changeStorageMode()" style="padding: 5px;">
                            <option value="hybrid">üîÑ Hybrid (GitHub + Local)</option>
                            <option value="github">üåê GitHub Only (Recommended)</option>
                            <option value="indexeddb">üíæ Local Only (Temporary)</option>
                        </select>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">GitHub = Permanent, Local = Browser only</div>
                    </div>
                    <div class="config-item">
                        <button onclick="testGitHubConnection()" class="btn" style="padding: 5px 10px; font-size: 12px;">üß™ Test Connection</button>
                        <button onclick="validateGitHubStorage()" class="btn" style="padding: 5px 10px; font-size: 12px; margin-left: 5px;">‚úÖ Validate Storage</button>
                        <button onclick="initializeGitHubStorage()" class="btn" style="padding: 5px 10px; font-size: 12px; margin-left: 5px;">üöÄ Initialize Storage</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- Toast Container for Floating Notifications -->
            <div id="toastContainer" class="toast-container"></div>
            
            <!-- Real-time Progress and Sync Status -->
            <div id="progressContainer" class="progress-container">
                <!-- Global Progress Bar -->
                <div id="globalProgress" class="global-progress" style="display: none;">
                    <div class="progress-bar">
                        <div id="globalProgressBar" class="progress-fill"></div>
                    </div>
                    <div id="globalProgressText" class="progress-text">Processing...</div>
                </div>
                
                <!-- Active Operations -->
                <div id="activeOperations" class="active-operations"></div>
            </div>
            
            <!-- Sync Status Indicator -->
            <div id="syncStatus" class="sync-status">
                <div class="sync-indicator">
                    <span id="syncIcon" class="sync-icon">üîÑ</span>
                    <span id="syncText" class="sync-text">Auto-sync enabled</span>
                    <span id="lastSyncTime" class="last-sync">Never</span>
                    <button id="toggleAutoSync" class="sync-toggle" onclick="toggleAutoSync()">Disable</button>
                </div>
            </div>
            
            <!-- Legacy Alert Area (hidden) -->
            <div id="alertArea" style="display: none;"></div>

            <!-- Storage Info -->
            <div class="storage-info">
                <div>
                    <strong>üíæ JSON File Storage:</strong> 
                    <span id="storageUsed">0 KB</span> across <span id="fileCount">0</span> data files
                </div>
                <div class="storage-bar">
                    <div class="storage-fill" id="storageFill"></div>
                </div>
                <div id="storageDetails" style="font-size: 12px; margin-top: 8px; color: #666;"></div>
                
                <!-- Network Usage Info -->
                <div id="networkUsage" class="network-usage" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 12px;">
                    <strong>üìä Network Usage:</strong>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                        <span>Requests: <span id="requestCount">0</span></span>
                        <span>Cache hits: <span id="cacheHits">0</span></span>
                        <span>Data saved: <span id="dataSaved">0 KB</span></span>
                    </div>
                </div>
                
                <div class="data-management">
                    <div class="utilities-dropdown">
                        <button class="utilities-btn" onclick="toggleUtilitiesDropdown()">
                            üõ†Ô∏è Utilities
                            <span style="margin-left: auto;">‚ñº</span>
                        </button>
                        <div class="utilities-dropdown-content" id="utilitiesDropdown">
                            <button class="dropdown-item" onclick="exportAllData(); closeUtilitiesDropdown();">
                                üì§ Export All Data
                            </button>
                            <button class="dropdown-item" onclick="document.getElementById('importFile').click(); closeUtilitiesDropdown();">
                                üì• Import Data
                            </button>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item" onclick="refreshDataFiles(); closeUtilitiesDropdown();">
                                üìä Refresh Data
                            </button>
                            <button class="dropdown-item" onclick="showDataFilesList(); closeUtilitiesDropdown();">
                                üìã Show Data Files
                            </button>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item" onclick="testNotifications(); closeUtilitiesDropdown();">
                                üîî Test Notifications
                            </button>
                            <button class="dropdown-item" onclick="testLargeFileSupport(); closeUtilitiesDropdown();">
                                üìÅ Large File Info
                            </button>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item" onclick="showPublicLinksManager(); closeUtilitiesDropdown();">
                                üîó Manage Public Links
                            </button>
                        </div>
                    </div>
                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
                </div>
            </div>

            <!-- Breadcrumb Navigation -->
            <div class="breadcrumb-container">
                <button class="back-button" id="backButton" onclick="goBack()" style="display: none;">
                    ‚Üê Kembali
                </button>
                <div class="breadcrumb" id="breadcrumb">
                    <a href="#" onclick="loadFolder('')">üè† Home</a>
                </div>
            </div>

            <!-- Tab Navigation System -->
            <div class="tab-container">
                <div class="tab-nav">
                    <button class="tab-button active" onclick="switchTab('upload')">üì§ Upload Files</button>
                    <button class="tab-button" onclick="switchTab('folder')">üìÅ Buat Folder</button>
                    <button class="tab-button" onclick="switchTab('browser')">üóÇÔ∏è File Browser</button>
                </div>
                
                <div class="tab-content">
                    <!-- Upload Files Tab -->
                    <div id="uploadTab" class="tab-panel active">
                        <h3>üì§ Upload Files</h3>
                        <div class="form-group">
                            <label for="targetFolder">Pilih Folder Tujuan:</label>
                            <select id="targetFolder">
                                <option value="">Pilih folder...</option>
                            </select>
                        </div>
                        
                        <div class="file-selection-area" id="fileSelectionArea" onclick="document.getElementById('fileInput').click()">
                            <div class="upload-icon">üì§</div>
                            <p><strong>Klik untuk memilih file</strong> atau drag & drop file ke sini</p>
                            <p style="color: #666; margin-top: 10px;">Mendukung file hingga 2GB dengan auto-chunking (20MB chunks)</p>
                            <p style="color: #20bf6b; margin-top: 5px; font-size: 0.9em;">‚úÖ Unlimited storage dengan multiple JSON files</p>
                            
                            <div class="selected-files-preview" id="selectedFilesPreview">
                                <h4>üìã File yang dipilih:</h4>
                                <div id="selectedFilesList"></div>
                            </div>
                        </div>
                        <input type="file" id="fileInput" multiple style="display: none;">
                        <button class="btn" onclick="uploadFiles()" id="uploadBtn" style="margin-top: 15px;" disabled>üì§ Upload File</button>
                    </div>

                    <!-- Create Folder Tab -->
                    <div id="folderTab" class="tab-panel">
                        <h3>üìÅ Buat Folder Baru</h3>
                        <div class="form-group">
                            <label for="parentFolder">Folder Induk:</label>
                            <select id="parentFolder">
                                <option value="">üìÅ Root (Folder Utama)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="folderName">Nama Folder:</label>
                            <input type="text" id="folderName" placeholder="Masukkan nama folder">
                        </div>
                        <div class="form-group">
                            <label for="folderPassword">Sandi Keamanan:</label>
                            <input type="password" id="folderPassword" placeholder="Masukkan sandi untuk folder ini">
                        </div>
                        <button class="btn btn-success" onclick="createFolder()">üìÅ Buat Folder</button>
                    </div>

                    <!-- File Browser Tab -->
                    <div id="browserTab" class="tab-panel">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0;">üóÇÔ∏è File & Folder Browser</h3>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div class="view-toggle">
                                    <button class="view-btn active" id="listViewBtn" onclick="switchView('list')" title="List View">
                                        üìã List
                                    </button>
                                    <button class="view-btn" id="gridViewBtn" onclick="switchView('grid')" title="Grid View">
                                        ‚äû Grid
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div class="quick-actions" style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-primary" onclick="document.getElementById('quickFileInput').click();">
                                üì§ Upload Files
                            </button>
                            <button class="btn btn-primary" onclick="document.getElementById('quickFolderInput').click();" style="background: #28a745;">
                                üìÅ Upload Folder
                            </button>
                            <button class="btn btn-secondary" onclick="showQuickCreateFolder();">
                                ‚ûï New Folder
                            </button>
                            <button class="btn btn-secondary" id="upLevelBtn" onclick="goUpOneLevel()" style="display: none;">
                                ‚¨ÜÔ∏è Up Level
                            </button>
                            <input type="file" id="quickFileInput" multiple style="display: none;" onchange="handleQuickFileUpload(event)">
                            <input type="file" id="quickFolderInput" webkitdirectory style="display: none;" onchange="handleQuickFolderUpload(event)">
                        </div>
                        
                        <!-- File list loading status and cache info -->
                        <div id="loadingStatus" class="loading-status" style="display: none;">
                            <span class="loading-text">Loading files...</span>
                            <span class="cache-info" id="cacheInfo"></span>
                        </div>
                        
                        <div id="fileList" class="file-list">
                            <!-- Files and folders will be loaded here -->
                        </div>
                        
                        <!-- Pagination Controls -->
                        <div id="paginationContainer" class="pagination-container" style="display: none;">
                            <div class="pagination-info">
                                <span id="fileCount">Loading files...</span>
                                <span class="cache-status" id="cacheStatus"></span>
                            </div>
                            <div class="pagination-controls">
                                <button id="prevPage" class="pagination-btn" onclick="changePage(currentPage - 1)" disabled>
                                    ‚Üê Previous
                                </button>
                                <span class="pagination-numbers" id="paginationNumbers"></span>
                                <button id="nextPage" class="pagination-btn" onclick="changePage(currentPage + 1)" disabled>
                                    Next ‚Üí
                                </button>
                            </div>
                            <div class="pagination-options">
                                <label for="itemsPerPage">Items per page:</label>
                                <select id="itemsPerPage" onchange="changeItemsPerPage(this.value)">
                                    <option value="10">10</option>
                                    <option value="20" selected>20</option>
                                    <option value="50">50</option>
                                    <option value="100">100</option>
                                </select>
                                <button class="btn-small" onclick="refreshFileList(true)">üîÑ Refresh</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeDeleteModal()">&times;</span>
            <h3>Konfirmasi Penghapusan</h3>
            <p id="deleteMessage"></p>
            <div class="form-group">
                <label for="deletePassword">Masukkan Sandi Folder:</label>
                <input type="password" id="deletePassword" placeholder="Sandi keamanan">
            </div>
            <button class="btn btn-danger" onclick="confirmDelete()">üóëÔ∏è Hapus</button>
            <button class="btn" onclick="closeDeleteModal()">‚ùå Batal</button>
        </div>
    </div>

    <script>
        // ============================================================================
        // GITHUB API REAL STORAGE SYSTEM
        // ============================================================================
        
        // GitHub API Configuration
        const GITHUB_CONFIG = {
            OWNER: 'krasyid822',  // GitHub username
            REPO: 'file-container',  // Repository name
            BRANCH: 'main',  // Target branch
            DATA_PATH: 'storage/',  // Storage path in repo (moved to root to avoid GitHub Pages deployment)
            API_BASE: 'https://api.github.com',
            TOKEN: localStorage.getItem('github_token') || null
        };
        
        // Collapsible section toggle function
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            
            const toggle = section.querySelector('.collapsible-toggle');
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                toggle.textContent = '‚ñ≤';
            } else {
                section.classList.add('collapsed');
                toggle.textContent = '‚ñº';
            }
        }
        
        // Function to load token from file if available
        async function loadTokenFromFile() {
            try {
                const response = await fetch('./.token-api.txt');
                if (response.ok) {
                    const token = (await response.text()).trim();
                    if (token && token.startsWith('ghp_')) {
                        setGitHubToken(token);
                        console.log('üîë GitHub token loaded from .token-api.txt');
                        return true;
                    }
                }
            } catch (error) {
                console.log('üìÑ No .token-api.txt file found, using localStorage token');
            }
            return false;
        }
        
        // Initialize token on load
        (async () => {
            if (!GITHUB_CONFIG.TOKEN) {
                await loadTokenFromFile();
            }
            // Update token status after loading
            updateTokenStatus();
        })();
        
        // Debug: Check if token exists
        console.log('üîß GitHub Config loaded:', {
            hasToken: !!GITHUB_CONFIG.TOKEN,
            config: GITHUB_CONFIG
        });
        
        let db;
        const DB_NAME = 'FileContainerDB';
        const DB_VERSION = 1;
        // Configuration constants
        const CHUNK_SIZE = 20 * 1024 * 1024; // 20MB chunks (optimized for large files)
        
        // GitHub API Authentication
        function setGitHubToken(token) {
            GITHUB_CONFIG.TOKEN = token;
            localStorage.setItem('github_token', token);
            showAlert('‚úÖ GitHub token configured successfully!', 'success');
        }
        
        function getGitHubToken() {
            if (!GITHUB_CONFIG.TOKEN) {
                const token = prompt('Masukkan GitHub Personal Access Token Anda:\n\n1. Buka GitHub Settings > Developer settings > Personal access tokens\n2. Generate new token dengan scope: repo\n3. Copy dan paste token di sini:');
                if (token) {
                    setGitHubToken(token);
                }
            }
            return GITHUB_CONFIG.TOKEN;
        }
        
        // GitHub API Helper Functions with Request Deduplication
        async function githubApiRequest(endpoint, method = 'GET', data = null) {
            const token = getGitHubToken();
            if (!token) {
                throw new Error('GitHub token required');
            }
            
            // Create request key for deduplication
            const requestKey = `${method}:${endpoint}:${data ? JSON.stringify(data) : ''}`;
            
            // Check for pending request
            if (pendingRequests.has(requestKey)) {
                console.log(`üîÑ Reusing pending request: ${method} ${endpoint}`);
                return await pendingRequests.get(requestKey);
            }
            
            // Check if endpoint is already a full URL or just a path
            const url = endpoint.startsWith('http') ? endpoint : `${GITHUB_CONFIG.API_BASE}${endpoint}`;
            console.log(`üåê GitHub API Request: ${method} ${url}`);
            
            const headers = {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            };

            const options = {
                method,
                headers,
                body: data ? JSON.stringify(data) : null
            };

            // Create and store the request promise
            const requestPromise = (async () => {
                try {
                    // Track network request
                    trackNetworkRequest();
                    
                    const response = await fetch(url, options);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error(`‚ùå GitHub API Error: ${response.status} - ${errorData.message || response.statusText}`);
                        throw new Error(`GitHub API error: ${response.status} - ${errorData.message || response.statusText}`);
                    }

                    console.log(`‚úÖ GitHub API Success: ${method} ${url}`);
                    const result = await response.json();
                    
                    // Cache GET requests temporarily
                    if (method === 'GET' && result) {
                        setTimeout(() => {
                            // Remove from cache after 30 seconds for GET requests
                            pendingRequests.delete(requestKey);
                        }, 30000);
                    } else {
                        // Remove immediately for non-GET requests
                        pendingRequests.delete(requestKey);
                    }
                    
                    return result;
                } catch (error) {
                    pendingRequests.delete(requestKey);
                    throw error;
                }
            })();
            
            // Store the promise
            pendingRequests.set(requestKey, requestPromise);
            
            return await requestPromise;
        }
        
        // Get file from GitHub repository
        async function getFileFromGitHub(filePath) {
            try {
                const endpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filePath}`;
                const response = await githubApiRequest(endpoint);
                
                if (response.content) {
                    // Decode base64 content
                    const content = atob(response.content.replace(/\n/g, ''));
                    return {
                        content: content,
                        sha: response.sha,
                        path: response.path
                    };
                }
                return null;
            } catch (error) {
                if (error.message.includes('404')) {
                    return null; // File doesn't exist
                }
                throw error;
            }
        }
        
        // Save file to GitHub repository
        async function saveFileToGitHub(filePath, content, message = 'Update file', sha = null) {
            try {
                const endpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filePath}`;
                
                // If no SHA provided, check if file exists and get SHA
                if (!sha) {
                    try {
                        const existingFile = await getFileFromGitHub(filePath);
                        if (existingFile && existingFile.sha) {
                            sha = existingFile.sha;
                            console.log(`üìù File exists, updating with SHA: ${sha.substring(0, 8)}...`);
                        }
                    } catch (error) {
                        // File doesn't exist, we'll create a new one
                        console.log(`üìÑ Creating new file: ${filePath}`);
                    }
                }
                
                // Encode content to base64
                const encodedContent = btoa(unescape(encodeURIComponent(content)));
                
                const data = {
                    message: message,
                    content: encodedContent,
                    branch: GITHUB_CONFIG.BRANCH
                };
                
                // Include SHA if updating existing file
                if (sha) {
                    data.sha = sha;
                }
                
                const response = await githubApiRequest(endpoint, 'PUT', data);
                console.log(`‚úÖ File saved to GitHub: ${filePath}`);
                return response;
            } catch (error) {
                console.error('GitHub save error:', error);
                throw error;
            }
        }
        
        // Delete file from GitHub repository
        async function deleteFileFromGitHub(filePath, sha, message = 'Delete file') {
            try {
                const endpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filePath}`;
                
                const data = {
                    message: message,
                    sha: sha,
                    branch: GITHUB_CONFIG.BRANCH
                };
                
                const response = await githubApiRequest(endpoint, 'DELETE', data);
                return response;
            } catch (error) {
                console.error('GitHub delete error:', error);
                throw error;
            }
        }
        
        // ============================================================================
        // HYBRID STORAGE SYSTEM - GitHub API + IndexedDB Fallback
        // ============================================================================
        
        let storageMode = 'hybrid'; // 'github', 'indexeddb', 'hybrid'
        
        // Initialize storage mode from localStorage
        if (localStorage.getItem('storage_mode')) {
            storageMode = localStorage.getItem('storage_mode');
        } else {
            // Default to hybrid mode for new users
            localStorage.setItem('storage_mode', 'hybrid');
        }
        
        console.log('üíæ Storage mode initialized:', storageMode);
        
        async function saveFileWithGitHubChunking(fileData, fileContent) {
            const fileId = fileData.id;
            const contentSize = fileContent.length;
            
            console.log(`üíæ Saving file "${fileData.name}" (${formatFileSize(contentSize)}) to GitHub`);
            
            try {
                // Save file metadata to GitHub
                const metadataPath = `${GITHUB_CONFIG.DATA_PATH}files/${fileId}.json`;
                const metadata = {
                    ...fileData,
                    isChunked: contentSize > CHUNK_SIZE,
                    totalChunks: Math.ceil(contentSize / CHUNK_SIZE),
                    totalSize: contentSize,
                    storageType: 'github',
                    createdAt: new Date().toISOString()
                };
                
                await saveFileToGitHub(metadataPath, JSON.stringify(metadata, null, 2), `Add file: ${fileData.name}`);
                
                // Save file content (chunked if necessary)
                if (contentSize <= CHUNK_SIZE) {
                    // Single chunk
                    const chunkPath = `${GITHUB_CONFIG.DATA_PATH}chunks/${fileId}_chunk_0.txt`;
                    await saveFileToGitHub(chunkPath, fileContent, `Add content: ${fileData.name}`);
                    console.log(`‚úÖ File stored as single chunk in GitHub`);
                } else {
                    // Multiple chunks
                    const chunks = [];
                    for (let i = 0; i < contentSize; i += CHUNK_SIZE) {
                        const chunkData = fileContent.slice(i, i + CHUNK_SIZE);
                        const chunkIndex = Math.floor(i / CHUNK_SIZE);
                        const chunkPath = `${GITHUB_CONFIG.DATA_PATH}chunks/${fileId}_chunk_${chunkIndex}.txt`;
                        
                        await saveFileToGitHub(chunkPath, chunkData, `Add chunk ${chunkIndex}: ${fileData.name}`);
                        chunks.push(chunkIndex);
                    }
                    console.log(`‚úÖ File "${fileData.name}" saved in ${chunks.length} chunks to GitHub`);
                }
                
                showAlert('‚úÖ File saved to GitHub repository successfully!', 'success');
                return true;
                
            } catch (error) {
                console.error('GitHub storage failed, falling back to IndexedDB:', error);
                showAlert('‚ö†Ô∏è GitHub save failed, using local storage fallback', 'warning');
                
                // Fallback to IndexedDB
                return await saveFileWithChunking(fileData, fileContent);
            }
        }
        
        async function getFileFromGitHubChunks(fileInfo) {
            try {
                // Use the fileInfo object directly if it's passed, or treat as ID for backward compatibility
                let fileId, metadata;
                
                if (typeof fileInfo === 'string') {
                    // Backward compatibility - fileInfo is actually fileId
                    fileId = fileInfo;
                    
                    console.log(`üìã Loading file metadata for ID: ${fileId}`);
                    
                    // Get file metadata
                    const metadataPath = `${GITHUB_CONFIG.DATA_PATH}files/${fileId}.json`;
                    const metadataFile = await getFileFromGitHub(metadataPath);
                    
                    if (!metadataFile) {
                        console.warn(`‚ùå Metadata not found for ${fileId}, trying IndexedDB fallback`);
                        // Try IndexedDB fallback
                        return await getFileWithChunks(fileId);
                    }
                    
                    metadata = JSON.parse(metadataFile.content);
                    console.log(`‚úÖ Loaded metadata for ${fileId}:`, {
                        name: metadata.name,
                        isChunked: metadata.isChunked,
                        totalChunks: metadata.totalChunks,
                        totalSize: metadata.totalSize,
                        originalSize: metadata.size
                    });
                } else {
                    // New usage - fileInfo is the metadata object
                    metadata = fileInfo;
                    fileId = metadata.id;
                    
                    console.log(`üìã Using provided metadata for: ${metadata.name} (ID: ${fileId})`);
                    
                    // If metadata doesn't have complete info, load from GitHub
                    if (!metadata.hasContent && !metadata.totalChunks) {
                        console.log(`üìã Metadata incomplete, loading full metadata from GitHub`);
                        const metadataPath = `${GITHUB_CONFIG.DATA_PATH}files/${fileId}.json`;
                        const metadataFile = await getFileFromGitHub(metadataPath);
                        
                        if (metadataFile) {
                            metadata = JSON.parse(metadataFile.content);
                            console.log(`‚úÖ Loaded complete metadata:`, {
                                name: metadata.name,
                                isChunked: metadata.isChunked,
                                totalChunks: metadata.totalChunks,
                                totalSize: metadata.totalSize
                            });
                        }
                    }
                }
                
                // Determine if file is chunked
                const isChunked = metadata.isChunked || (metadata.totalChunks && metadata.totalChunks > 1);
                const totalChunks = metadata.totalChunks || 1;
                
                console.log(`üì¶ File chunking info: isChunked=${isChunked}, totalChunks=${totalChunks}`);
                
                // Get file chunks
                const chunks = [];
                for (let i = 0; i < totalChunks; i++) {
                    const chunkPath = `${GITHUB_CONFIG.DATA_PATH}chunks/${fileId}_chunk_${i}.txt`;
                    console.log(`üì• Loading chunk ${i}/${totalChunks-1}: ${chunkPath}`);
                    
                    const chunkFile = await getFileFromGitHub(chunkPath);
                    
                    if (chunkFile) {
                        console.log(`‚úÖ Chunk ${i} loaded, size: ${chunkFile.content.length} characters`);
                        chunks.push({
                            index: i,
                            data: chunkFile.content
                        });
                    } else {
                        console.error(`‚ùå Failed to load chunk ${i}: ${chunkPath}`);
                    }
                }
                
                if (chunks.length === 0) {
                    console.error(`‚ùå No chunks loaded for file ${fileId}`);
                    throw new Error(`No chunks found for file ${fileId}`);
                }
                
                console.log(`üì¶ Loaded ${chunks.length}/${totalChunks} chunks`);
                
                // Sort chunks and reconstruct file
                chunks.sort((a, b) => a.index - b.index);
                const reconstructedContent = chunks.map(chunk => chunk.data).join('');
                
                console.log(`üîß Reconstructed content size: ${reconstructedContent.length} characters`);
                console.log(`üìä Expected size: ${metadata.totalSize || metadata.size || 'unknown'}`);
                
                // Verify content integrity
                if (metadata.totalSize && reconstructedContent.length !== metadata.totalSize) {
                    console.warn(`‚ö†Ô∏è Content size mismatch! Expected: ${metadata.totalSize}, Got: ${reconstructedContent.length}`);
                }
                
                return {
                    ...metadata,
                    content: reconstructedContent,
                    reconstructedSize: reconstructedContent.length
                };
                
            } catch (error) {
                console.error('‚ùå GitHub retrieval failed, trying IndexedDB:', error);
                
                // Fallback to IndexedDB
                const fallbackId = typeof fileInfo === 'string' ? fileInfo : fileInfo.id;
                return await getFileWithChunks(fallbackId);
            }
        }
        
        async function deleteFileInfoFromGitHub(fileInfo) {
            try {
                const filePaths = [];
                
                // Add metadata file
                filePaths.push(`${GITHUB_CONFIG.DATA_PATH}files/${fileInfo.id}.json`);
                
                // Add chunk files if it's a chunked file
                if (fileInfo.isChunked && fileInfo.totalChunks) {
                    for (let i = 0; i < fileInfo.totalChunks; i++) {
                        filePaths.push(`${GITHUB_CONFIG.DATA_PATH}chunks/${fileInfo.id}_chunk_${i}.txt`);
                    }
                }
                
                // Delete all files
                const deletePromises = filePaths.map(async (path) => {
                    try {
                        await deleteFileFromGitHub_internal(path, `Delete ${fileInfo.name}`);
                    } catch (error) {
                        console.warn(`Failed to delete ${path}:`, error);
                    }
                });
                
                await Promise.all(deletePromises);
                return true;
                
            } catch (error) {
                console.error('GitHub delete failed:', error);
                throw error;
            }
        }
        
        async function deleteFileFromGitHub_internal(path, message) {
            try {
                // First get the file to get its SHA
                const fileResponse = await githubApiRequest(
                    `${GITHUB_CONFIG.API_BASE}/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${path}`,
                    'GET'
                );
                
                if (!fileResponse || !fileResponse.sha) {
                    console.warn(`File not found for deletion: ${path}`);
                    return;
                }
                
                // Delete the file
                await githubApiRequest(
                    `${GITHUB_CONFIG.API_BASE}/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${path}`,
                    'DELETE',
                    {
                        message: message || `Delete ${path}`,
                        sha: fileResponse.sha
                    }
                );
                
            } catch (error) {
                if (error.message && error.message.includes('404')) {
                    console.warn(`File not found for deletion: ${path}`);
                } else {
                    throw error;
                }
            }
        }
        
        async function getGitHubFileList() {
            try {
                const filesPath = `${GITHUB_CONFIG.DATA_PATH}files`;
                console.log(`üîç Getting file list from GitHub: ${filesPath}`);
                
                // Get contents of the files directory
                const response = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filesPath}`,
                    'GET'
                );
                
                if (!response || !Array.isArray(response)) {
                    console.log('üìÅ No files directory or empty response');
                    return [];
                }
                
                console.log(`üìÅ Found ${response.length} items in files directory`);
                const fileList = [];
                
                // Process each file metadata
                for (const item of response) {
                    if (item.name.endsWith('.json') && item.type === 'file' && item.name !== '.gitkeep') {
                        try {
                            console.log(`üìã Processing metadata file: ${item.name}`);
                            
                            // Check file size - GitHub API doesn't return content for files >1MB
                            if (item.size > 1024 * 1024) { // 1MB
                                console.log(`üìã Large metadata file detected (${formatFileSize(item.size)}), using download URL`);
                                try {
                                    // Use download_url for large files
                                    const response = await fetch(item.download_url);
                                    if (response.ok) {
                                        const metadataContent = await response.text();
                                        console.log(`üìã Downloaded large metadata content for ${item.name}:`, metadataContent.substring(0, 200) + '...');
                                        
                                        const metadata = JSON.parse(metadataContent);
                                        console.log(`‚úÖ Parsed large metadata for ${item.name}:`, {
                                            name: metadata.name,
                                            folder: metadata.folder,
                                            size: metadata.size,
                                            id: metadata.id
                                        });
                                        
                                        // Ensure required fields exist
                                        if (metadata.name && metadata.folder) {
                                            fileList.push(metadata);
                                            console.log(`‚úÖ Loaded large file metadata: ${metadata.name} in folder ${metadata.folder}`);
                                        } else {
                                            console.warn(`‚ùå Missing required fields in large metadata for ${item.name}:`, metadata);
                                        }
                                    } else {
                                        console.error(`‚ùå Failed to download large metadata for ${item.name}:`, response.status);
                                    }
                                } catch (error) {
                                    console.error(`‚ùå Error processing large metadata for ${item.name}:`, error);
                                }
                            } else {
                                // Use regular GitHub API for small files
                                const metadataResponse = await githubApiRequest(item.url, 'GET');
                                console.log(`üìã Raw GitHub response for ${item.name}:`, {
                                    hasContent: !!metadataResponse?.content,
                                    contentLength: metadataResponse?.content?.length || 0,
                                    encoding: metadataResponse?.encoding,
                                    type: metadataResponse?.type,
                                    size: metadataResponse?.size
                                });
                                
                                if (metadataResponse && metadataResponse.content) {
                                    const metadataContent = atob(metadataResponse.content);
                                    console.log(`üìã Raw metadata content for ${item.name}:`, metadataContent.substring(0, 200) + '...');
                                    
                                    const metadata = JSON.parse(metadataContent);
                                    console.log(`‚úÖ Parsed metadata for ${item.name}:`, {
                                        name: metadata.name,
                                        folder: metadata.folder,
                                        size: metadata.size,
                                        id: metadata.id
                                    });
                                    
                                    // Ensure required fields exist
                                    if (metadata.name && metadata.folder) {
                                        fileList.push(metadata);
                                        console.log(`‚úÖ Loaded file metadata: ${metadata.name} in folder ${metadata.folder}`);
                                    } else {
                                        console.warn(`‚ùå Missing required fields in metadata for ${item.name}:`, metadata);
                                    }
                                } else {
                                    console.warn(`‚ùå No content in metadata response for ${item.name}`);
                                    console.log(`üìã Full response object:`, metadataResponse);
                                }
                            }
                        } catch (error) {
                            console.warn(`Failed to parse metadata for ${item.name}:`, error);
                        }
                    }
                }
                
                console.log(`üìÅ Successfully loaded ${fileList.length} files from GitHub`);
                return fileList;
                
            } catch (error) {
                if (error.message.includes('404')) {
                    console.log('üìÅ Storage directory not found, initializing...');
                    await initializeGitHubStorage();
                    return []; // Return empty array for first time setup
                }
                console.error('Failed to get GitHub file list:', error);
                return [];
            }
        }
        
        async function saveGitHubFolder(folderData) {
            try {
                const folderPath = `${GITHUB_CONFIG.DATA_PATH}folders/${folderData.id}.json`;
                const folderContent = JSON.stringify(folderData, null, 2);
                
                await saveFileToGitHub(folderPath, folderContent, `Create folder: ${folderData.name}`);
                showAlert('‚úÖ Folder saved to GitHub repository!', 'success');
                return true;
                
            } catch (error) {
                console.error('GitHub folder save failed:', error);
                showAlert('‚ö†Ô∏è GitHub folder save failed, using local storage', 'warning');
                return await saveFolder(folderData);
            }
        }
        
        async function deleteGitHubFolder(folderName) {
            try {
                // Delete folder metadata file
                const folderPath = `${GITHUB_CONFIG.DATA_PATH}folders/${folderName}.json`;
                
                try {
                    const existingFile = await getFileFromGitHub(folderPath);
                    if (existingFile && existingFile.sha) {
                        await deleteFileFromGitHub(folderPath, existingFile.sha, `Delete folder: ${folderName}`);
                        console.log(`üìÅ Folder metadata deleted: ${folderPath}`);
                    }
                } catch (error) {
                    console.warn(`Folder metadata not found: ${folderPath}`);
                }
                
                // Delete all files in this folder
                const githubFiles = await getGitHubFileList();
                const folderFiles = githubFiles.filter(f => f.folder === folderName);
                
                for (const file of folderFiles) {
                    await deleteFileInfoFromGitHub(file);
                }
                
                console.log(`‚úÖ GitHub folder "${folderName}" deleted successfully`);
                return true;
                
            } catch (error) {
                console.error('GitHub folder delete failed:', error);
                throw error;
            }
        }
        
        async function deleteFileDB(fileId) {
            try {
                const transaction = db.transaction(['files', 'chunks'], 'readwrite');
                
                // Delete file metadata
                await transaction.objectStore('files').delete(fileId);
                
                // Delete file chunks
                await deleteFileChunks(fileId);
                
                console.log(`‚úÖ File deleted from IndexedDB: ${fileId}`);
                return true;
                
            } catch (error) {
                console.error('IndexedDB file delete failed:', error);
                throw error;
            }
        }
        
        async function initializeGitHubStorage() {
            try {
                console.log('üöÄ Initializing GitHub storage structure...');
                
                // Create main storage directory with README
                const readmeContent = `# File Container Storage

This directory contains files and folders uploaded via File Container app.

## Structure
- \`files/\` - File metadata and chunked data
- \`folders/\` - Folder configurations and metadata

## Usage
- Files are automatically chunked into 20MB segments for optimal performance
- Each file has metadata stored as JSON
- Folders can have password protection

Last updated: ${new Date().toISOString()}
Generated by File Container App`;

                await saveFileToGitHub(
                    `${GITHUB_CONFIG.DATA_PATH}README.md`,
                    readmeContent,
                    'Initialize File Container storage structure'
                );

                // Create files directory with a placeholder
                const filesPlaceholder = `# Files Directory

This directory contains uploaded file metadata and data chunks.

Files are stored as JSON with the following structure:
- Metadata: File info, upload date, folder, etc.
- Data: Base64 encoded content (chunked if >20MB for large file support)

Created: ${new Date().toISOString()}`;

                await saveFileToGitHub(
                    `${GITHUB_CONFIG.DATA_PATH}files/.gitkeep`,
                    filesPlaceholder,
                    'Create files directory'
                );

                // Create folders directory with a placeholder
                const foldersPlaceholder = `# Folders Directory

This directory contains folder configurations and metadata.

Each folder is stored as JSON with:
- Folder name and ID
- Password hash (if protected)
- Creation date
- Metadata

Created: ${new Date().toISOString()}`;

                await saveFileToGitHub(
                    `${GITHUB_CONFIG.DATA_PATH}folders/.gitkeep`,
                    foldersPlaceholder,
                    'Create folders directory'
                );

                console.log('‚úÖ GitHub storage structure initialized successfully');
                showAlert('‚úÖ GitHub storage initialized! Ready to store files.', 'success');
                
                return true;
            } catch (error) {
                console.error('Failed to initialize GitHub storage:', error);
                showAlert('‚ùå Failed to initialize GitHub storage: ' + error.message, 'error');
                return false;
            }
        }
        
        async function getAllGitHubFolders() {
            try {
                const foldersPath = `${GITHUB_CONFIG.DATA_PATH}folders`;
                
                // Get contents of the folders directory
                const response = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${foldersPath}`,
                    'GET'
                );
                
                if (!response || !Array.isArray(response)) {
                    return [];
                }
                
                const folderList = [];
                
                // Process each folder metadata
                for (const item of response) {
                    if (item.name.endsWith('.json') && item.type === 'file') {
                        try {
                            const folderResponse = await githubApiRequest(item.url, 'GET');
                            if (folderResponse && folderResponse.content) {
                                const folderContent = atob(folderResponse.content);
                                const folderData = JSON.parse(folderContent);
                                folderList.push(folderData);
                            }
                        } catch (error) {
                            console.warn(`Failed to parse folder data for ${item.name}:`, error);
                        }
                    }
                }
                
                return folderList;
                
            } catch (error) {
                if (error.message.includes('404')) {
                    console.log('üìÅ Folders directory not found, will be created when first folder is added');
                    return [];
                }
                console.error('Error loading GitHub folders:', error);
                return [];
            }
        }
        
        async function getAllGitHubFiles() {
            try {
                // Similar to folders, combine sources
                const indexedFiles = await getAllFiles();
                return indexedFiles;
                
            } catch (error) {
                console.error('Error loading GitHub files:', error);
                return await getAllFiles();
            }
        }
        
        // Initialize IndexedDB
        async function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    console.log('‚úÖ IndexedDB initialized successfully');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create folders store
                    if (!db.objectStoreNames.contains('folders')) {
                        const foldersStore = db.createObjectStore('folders', { keyPath: 'id' });
                        foldersStore.createIndex('name', 'name', { unique: true });
                    }
                    
                    // Create files store
                    if (!db.objectStoreNames.contains('files')) {
                        const filesStore = db.createObjectStore('files', { keyPath: 'id' });
                        filesStore.createIndex('folder', 'folder', { unique: false });
                        filesStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    // Create chunks store for large files
                    if (!db.objectStoreNames.contains('chunks')) {
                        const chunksStore = db.createObjectStore('chunks', { keyPath: 'id' });
                        chunksStore.createIndex('fileId', 'fileId', { unique: false });
                        chunksStore.createIndex('chunkIndex', 'chunkIndex', { unique: false });
                    }
                    
                    console.log('üì¶ Database stores created');
                };
            });
        }
        
        // Real storage functions
        async function saveFolder(folderData) {
            const transaction = db.transaction(['folders'], 'readwrite');
            const store = transaction.objectStore('folders');
            return store.put(folderData);
        }
        
        async function getAllFolders() {
            const transaction = db.transaction(['folders'], 'readonly');
            const store = transaction.objectStore('folders');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function deleteFolderDB(folderId) {
            const transaction = db.transaction(['folders', 'files', 'chunks'], 'readwrite');
            
            // Delete folder
            await transaction.objectStore('folders').delete(folderId);
            
            // Delete all files in folder
            const filesStore = transaction.objectStore('files');
            const filesIndex = filesStore.index('folder');
            const filesToDelete = await new Promise((resolve, reject) => {
                const request = filesIndex.getAll(folderId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            
            // Delete files and their chunks
            for (const file of filesToDelete) {
                await filesStore.delete(file.id);
                await deleteFileChunks(file.id);
            }
        }
        
        async function saveFileWithChunking(fileData, fileContent) {
            const fileId = fileData.id;
            const contentSize = fileContent.length;
            
            console.log(`üíæ Saving file "${fileData.name}" (${formatFileSize(contentSize)})`);
            
            // Save file metadata
            const transaction = db.transaction(['files'], 'readwrite');
            await transaction.objectStore('files').put({
                ...fileData,
                isChunked: contentSize > CHUNK_SIZE,
                totalChunks: Math.ceil(contentSize / CHUNK_SIZE),
                totalSize: contentSize
            });
            
            // If file is small, store directly
            if (contentSize <= CHUNK_SIZE) {
                const chunkTransaction = db.transaction(['chunks'], 'readwrite');
                await chunkTransaction.objectStore('chunks').put({
                    id: `${fileId}_chunk_0`,
                    fileId: fileId,
                    chunkIndex: 0,
                    data: fileContent,
                    size: contentSize
                });
                console.log(`‚úÖ File stored as single chunk`);
                return true; // Return success
            }
            
            // Split large files into chunks
            const chunks = [];
            for (let i = 0; i < contentSize; i += CHUNK_SIZE) {
                const chunkData = fileContent.slice(i, i + CHUNK_SIZE);
                chunks.push({
                    id: `${fileId}_chunk_${Math.floor(i / CHUNK_SIZE)}`,
                    fileId: fileId,
                    chunkIndex: Math.floor(i / CHUNK_SIZE),
                    data: chunkData,
                    size: chunkData.length
                });
            }
            
            // Save all chunks
            const chunkTransaction = db.transaction(['chunks'], 'readwrite');
            const chunksStore = chunkTransaction.objectStore('chunks');
            for (const chunk of chunks) {
                await chunksStore.put(chunk);
            }
            
            console.log(`‚úÖ File "${fileData.name}" saved in ${chunks.length} chunks`);
            return true; // Return success
        }
        
        async function getFileWithChunks(fileId) {
            try {
                console.log(`üìã Loading file from IndexedDB: ${fileId}`);
                
                // Get file metadata
                const fileTransaction = db.transaction(['files'], 'readonly');
                const file = await new Promise((resolve, reject) => {
                    const request = fileTransaction.objectStore('files').get(fileId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                if (!file) {
                    console.error(`‚ùå File metadata not found in IndexedDB: ${fileId}`);
                    return null;
                }
                
                console.log(`‚úÖ File metadata loaded:`, {
                    name: file.name,
                    size: file.size,
                    originalSize: file.originalSize
                });
                
                // Get all chunks for this file
                const chunkTransaction = db.transaction(['chunks'], 'readonly');
                const chunksStore = chunkTransaction.objectStore('chunks');
                const chunksIndex = chunksStore.index('fileId');
                
                const chunks = await new Promise((resolve, reject) => {
                    const request = chunksIndex.getAll(fileId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                console.log(`üì¶ Found ${chunks.length} chunks in IndexedDB`);
                
                if (chunks.length === 0) {
                    console.error(`‚ùå No chunks found for file: ${fileId}`);
                    return null;
                }
                
                // Sort chunks by index and reconstruct file
                chunks.sort((a, b) => a.chunkIndex - b.chunkIndex);
                const reconstructedContent = chunks.map(chunk => {
                    console.log(`üì• Processing chunk ${chunk.chunkIndex}, size: ${chunk.data.length}`);
                    return chunk.data;
                }).join('');
                
                console.log(`üîß Reconstructed content size: ${reconstructedContent.length} characters`);
                console.log(`üìä Expected size: ${file.size || file.originalSize || 'unknown'}`);
                
                // Verify content integrity
                const expectedSize = file.size || file.originalSize;
                if (expectedSize && reconstructedContent.length !== expectedSize) {
                    console.warn(`‚ö†Ô∏è Content size mismatch! Expected: ${expectedSize}, Got: ${reconstructedContent.length}`);
                }
                
                return {
                    ...file,
                    content: reconstructedContent,
                    reconstructedSize: reconstructedContent.length
                };
                
            } catch (error) {
                console.error('‚ùå Error loading file from IndexedDB:', error);
                return null;
            }
        }
        
        async function getAllFiles() {
            const transaction = db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function deleteFileChunks(fileId) {
            const transaction = db.transaction(['chunks'], 'readwrite');
            const store = transaction.objectStore('chunks');
            const index = store.index('fileId');
            
            const chunks = await new Promise((resolve, reject) => {
                const request = index.getAll(fileId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            
            for (const chunk of chunks) {
                await store.delete(chunk.id);
            }
        }
        
        async function deleteFileComplete(fileId) {
            const transaction = db.transaction(['files', 'chunks'], 'readwrite');
            
            // Delete file metadata
            await transaction.objectStore('files').delete(fileId);
            
            // Delete all chunks
            await deleteFileChunks(fileId);
        }
        
        async function getStorageStats() {
            const [folders, files, chunks] = await Promise.all([
                getAllFolders(),
                getAllFiles(),
                new Promise((resolve, reject) => {
                    const transaction = db.transaction(['chunks'], 'readonly');
                    const request = transaction.objectStore('chunks').getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                })
            ]);
            
            const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0);
            const chunkedFiles = files.filter(f => f.isChunked).length;
            
            return {
                totalFolders: folders.length,
                totalFiles: files.length,
                totalChunks: chunks.length,
                totalSize: totalSize,
                chunkedFiles: chunkedFiles,
                averageChunkSize: chunks.length > 0 ? totalSize / chunks.length : 0
            };
        }

        // GitHub Configuration Functions
        function configureGitHubToken() {
            const currentToken = GITHUB_CONFIG.TOKEN;
            const tokenPreview = currentToken ? `${currentToken.substring(0, 8)}...` : 'None';
            
            const instructions = `
üîß GitHub Personal Access Token Setup:

Current Token: ${tokenPreview}

üìã Instructions:
1. Buka: https://github.com/settings/tokens
2. Click "Generate new token (classic)"
3. Set name: "File Container App"
4. Select scopes: ‚úÖ repo (full repository access)
5. Click "Generate token"
6. Copy token dan paste di bawah ini

‚ö†Ô∏è Simpan token ini dengan aman - tidak akan ditampilkan lagi!
            `;
            
            const token = prompt(instructions);
            if (token && token.trim()) {
                setGitHubToken(token.trim());
                updateTokenStatus();
            }
        }
        
        function updateTokenStatus() {
            const tokenElement = document.getElementById('tokenStatus');
            if (GITHUB_CONFIG.TOKEN) {
                const preview = `${GITHUB_CONFIG.TOKEN.substring(0, 8)}...`;
                tokenElement.innerHTML = `‚úÖ Configured (${preview})`;
                tokenElement.style.color = '#28a745';
            } else {
                tokenElement.innerHTML = '‚ùå Not configured';
                tokenElement.style.color = '#dc3545';
            }
        }
        
        function changeStorageMode() {
            const mode = document.getElementById('storageMode').value;
            storageMode = mode;
            localStorage.setItem('storage_mode', mode);
            
            const messages = {
                'hybrid': 'üîÑ Mode: Hybrid - GitHub dengan fallback local',
                'github': 'üåê Mode: GitHub Only - Semua data di repository',
                'indexeddb': 'üíæ Mode: Local Only - Data di browser'
            };
            
            showAlert(messages[mode], 'info');
        }
        
        async function testGitHubConnection() {
            if (!GITHUB_CONFIG.TOKEN) {
                showAlert('‚ùå GitHub token not configured', 'error');
                return;
            }
            
            try {
                showAlert('üîÑ Testing GitHub connection...', 'info');
                
                // Test repository access
                const repoInfo = await githubApiRequest(`/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}`);
                
                // Test file creation
                const testPath = `${GITHUB_CONFIG.DATA_PATH}test/connection-test.txt`;
                const testContent = `Connection test: ${new Date().toISOString()}`;
                
                await saveFileToGitHub(testPath, testContent, 'Connection test');
                
                showAlert(`‚úÖ GitHub connection successful! Repo: ${repoInfo.full_name}`, 'success');
                
                // Clean up test file
                setTimeout(async () => {
                    try {
                        const testFile = await getFileFromGitHub(testPath);
                        if (testFile) {
                            await deleteFileFromGitHub(testPath, testFile.sha, 'Clean up connection test');
                        }
                    } catch (error) {
                        console.log('Test cleanup failed:', error);
                    }
                }, 3000);
                
            } catch (error) {
                console.error('GitHub connection test failed:', error);
                showAlert(`‚ùå GitHub connection failed: ${error.message}`, 'error');
            }
        }
        
        // Debug: Verify testGitHubConnection is defined
        console.log('üîß testGitHubConnection defined:', typeof testGitHubConnection);
        
        async function validateGitHubConfig() {
            // Auto-configure GitHub mode if token is available
            if (GITHUB_CONFIG.TOKEN && storageMode !== 'github') {
                console.log('üîß GitHub token detected, validating configuration...');
                
                try {
                    // Test GitHub connection
                    const response = await githubApiRequest(
                        `${GITHUB_CONFIG.API_BASE}/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}`,
                        'GET'
                    );
                    
                    if (response && response.name) {
                        // Auto-switch to GitHub mode if not already set
                        if (storageMode === 'indexeddb') {
                            storageMode = 'hybrid';
                            localStorage.setItem('storage_mode', 'hybrid');
                            document.getElementById('storageMode').value = 'hybrid';
                            showAlert('üîÑ Switched to Hybrid mode (GitHub + Local backup)', 'info', 3000);
                        }
                        console.log('‚úÖ GitHub configuration validated');
                    }
                } catch (error) {
                    console.warn('GitHub validation failed:', error);
                    if (storageMode === 'github') {
                        storageMode = 'indexeddb';
                        localStorage.setItem('storage_mode', 'indexeddb');
                        document.getElementById('storageMode').value = 'indexeddb';
                        showAlert('‚ö†Ô∏è GitHub unavailable, switched to Local mode', 'warning');
                    }
                }
            } else if (!GITHUB_CONFIG.TOKEN && storageMode === 'github') {
                // Switch to IndexedDB if GitHub mode but no token
                storageMode = 'indexeddb';
                localStorage.setItem('storage_mode', 'indexeddb');
                document.getElementById('storageMode').value = 'indexeddb';
                showAlert('‚ö†Ô∏è Switched to Local mode - GitHub token required for GitHub storage', 'warning');
            }
        }
        
        async function validateGitHubStorage() {
            if (!GITHUB_CONFIG.TOKEN) {
                showAlert('‚ö†Ô∏è GitHub token belum dikonfigurasi. Klik "Setup GitHub Token" untuk penyimpanan persistent.', 'warning');
                return false;
            }
            
            try {
                showAlert('üîÑ Validating GitHub repository storage...', 'info');
                
                // Test repository access
                const repoResponse = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}`,
                    'GET'
                );
                
                if (!repoResponse) {
                    throw new Error('Repository not accessible');
                }
                
                // Test storage directory structure
                try {
                    await githubApiRequest(
                        `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${GITHUB_CONFIG.DATA_PATH}`,
                        'GET'
                    );
                    console.log('‚úÖ Storage directory exists');
                } catch (error) {
                    if (error.message.includes('404')) {
                        console.log('üìÅ Storage directory not found, creating...');
                        await initializeGitHubStorage();
                    } else {
                        throw error;
                    }
                }
                
                showAlert('‚úÖ GitHub repository storage validated and ready!', 'success');
                console.log('‚úÖ GitHub storage validation completed');
                return true;
                
            } catch (error) {
                console.error('GitHub storage validation failed:', error);
                showAlert(`‚ùå GitHub storage validation failed: ${error.message}`, 'error');
                return false;
            }
        }

        // File-based storage configuration (for backward compatibility)
        const FILE_CONFIG = {
            DATA_PATH: './data/',
            INDEX_FILE: 'index.json',
            MAX_FILE_SIZE: 2 * 1024 * 1024 * 1024, // 2GB per data file
            FILE_PREFIX: 'files-',
            FILE_EXTENSION: '.json'
        };

        let currentFolder = '';
        let deleteItem = null;
        let dataIndex = null;
        let allDataFiles = [];
        let selectedFiles = [];
        
        // Navigation history for back button
        let navigationHistory = [];
        let currentHistoryIndex = -1;
        
        // View mode for file browser
        let currentViewMode = 'list'; // 'list' or 'grid'
        
        // Auto-sync and real-time features
        let autoSyncInterval = null;
        let syncInProgress = false;
        let autoSyncEnabled = true;
        let lastSyncTime = null;
        const AUTO_SYNC_INTERVAL = 5000; // 5 seconds
        const PROGRESS_UPDATE_INTERVAL = 100; // 100ms for smooth progress
        
        // Storage for progress tracking
        let currentOperations = new Map();
        let operationCounter = 0;

        // ============================================================================
        // NETWORK OPTIMIZATION AND CACHING
        // ============================================================================
        
        // Pagination and lazy loading
        const FILES_PER_PAGE = 20;
        let currentPage = 1;
        let totalFiles = 0;
        let allFilesCache = new Map(); // Cache for file metadata
        let cacheTimestamp = null;
        const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache
        
        // Incremental sync tracking
        let lastSyncHash = null;
        let incrementalMode = true; // Enable incremental loading
        
        // Network traffic optimization
        let loadedFileIds = new Set(); // Track which files have been loaded
        let pendingRequests = new Map(); // Prevent duplicate requests
        
        // Network usage tracking
        let networkStats = {
            requests: 0,
            cacheHits: 0,
            dataSaved: 0
        };

        // ============================================================================
        // TAB SYSTEM FUNCTIONS
        // ============================================================================
        
        function switchTab(tabName) {
            // Remove active class from all tab buttons and panels
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            // Add active class to clicked button and corresponding panel
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Update parent folder dropdown when folder tab is opened
            if (tabName === 'folder') {
                updateParentFolderDropdown();
            }
        }

        // Switch view mode between list and grid
        function switchView(viewMode) {
            currentViewMode = viewMode;
            
            // Update button states
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(viewMode + 'ViewBtn').classList.add('active');
            
            // Update file list class
            const fileList = document.getElementById('fileList');
            fileList.className = `file-list ${viewMode}-view`;
            
            // Save preference
            localStorage.setItem('viewMode', viewMode);
            
            // Re-render file list with new view mode
            loadFileList();
        }

        // ============================================================================
        // UTILITIES DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleUtilitiesDropdown() {
            const dropdown = document.getElementById('utilitiesDropdown');
            dropdown.classList.toggle('show');
        }
        
        function closeUtilitiesDropdown() {
            const dropdown = document.getElementById('utilitiesDropdown');
            dropdown.classList.remove('show');
        }
        
        // Close dropdown when clicking outside
        window.onclick = function(event) {
            if (!event.target.matches('.utilities-btn') && !event.target.closest('.utilities-dropdown')) {
                closeUtilitiesDropdown();
            }
        }

        // ============================================================================
        // QUICK ACTIONS FUNCTIONS
        // ============================================================================
        
        async function handleQuickFileUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            // Set target folder to current folder
            const targetFolder = currentFolder || 'default';
            
            try {
                await uploadFilesToCurrentFolder(files, targetFolder);
                event.target.value = ''; // Clear input
            } catch (error) {
                console.error('Quick file upload error:', error);
                showAlert('Upload failed: ' + error.message, 'error');
            }
        }
        
        async function handleQuickFolderUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            try {
                await uploadFolderStructure(files);
                event.target.value = ''; // Clear input
            } catch (error) {
                console.error('Quick folder upload error:', error);
                showAlert('Folder upload failed: ' + error.message, 'error');
            }
        }
        
        async function uploadFilesToCurrentFolder(files, targetFolder) {
            const uploadId = createOperation(`Quick uploading ${files.length} file${files.length !== 1 ? 's' : ''}`, 'upload');
            
            try {
                updateOperation(uploadId, 10, 'Processing files...');
                
                // Clear allDataFiles to prevent duplicates
                allDataFiles.length = 0;
                allDataFiles.push({
                    filename: `fileData_${Date.now()}.json`,
                    data: { files: [] }
                });
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const progress = 10 + (i / files.length) * 70;
                    
                    updateOperation(uploadId, progress, `Processing ${file.name}...`);
                    
                    const base64Data = await fileToBase64WithProgress(file, file.name);
                    
                    const fileInfo = {
                        id: Date.now() + Math.random().toString(36).substr(2, 9),
                        name: file.name,
                        folder: targetFolder,
                        size: file.size,
                        mimetype: file.type,
                        uploadDate: new Date().toISOString(),
                        data: base64Data
                    };
                    
                    allDataFiles[0].data.files.push(fileInfo);
                }
                
                updateOperation(uploadId, 80, 'Saving to storage...');
                const saveSuccess = await saveFilesData(allDataFiles);
                
                if (!saveSuccess) {
                    throw new Error('Failed to save files to storage');
                }
                
                updateOperation(uploadId, 95, 'Refreshing...');
                await loadFileList();
                await updateStorageInfo();
                
                completeOperation(uploadId, `‚úÖ ${files.length} files uploaded`);
                showAlert(`‚úÖ ${files.length} file berhasil diupload ke ${targetFolder}!`, 'success');
                
            } catch (error) {
                completeOperation(uploadId, '‚ùå Upload failed');
                throw error;
            }
        }
        
        function showQuickCreateFolder() {
            const folderName = prompt('Nama folder baru:');
            if (!folderName) return;
            
            const password = prompt('Sandi keamanan untuk folder:');
            if (!password) return;
            
            // Set the current folder as parent
            const parentFolder = currentFolder;
            
            // Temporarily fill the form and trigger create
            const originalParent = document.getElementById('parentFolder').value;
            const originalName = document.getElementById('folderName').value;
            const originalPassword = document.getElementById('folderPassword').value;
            
            document.getElementById('parentFolder').value = parentFolder;
            document.getElementById('folderName').value = folderName;
            document.getElementById('folderPassword').value = password;
            
            createFolder().then(() => {
                // Restore original values
                document.getElementById('parentFolder').value = originalParent;
                document.getElementById('folderName').value = originalName;
                document.getElementById('folderPassword').value = originalPassword;
            });
        }

        // ============================================================================
        // FILE SELECTION PREVIEW FUNCTIONS
        // ============================================================================
        
        function updateFileSelectionPreview() {
            const previewArea = document.getElementById('selectedFilesPreview');
            const filesList = document.getElementById('selectedFilesList');
            const selectionArea = document.getElementById('fileSelectionArea');
            const uploadBtn = document.getElementById('uploadBtn');
            
            if (selectedFiles.length === 0) {
                previewArea.classList.remove('show');
                selectionArea.classList.remove('has-selection');
                uploadBtn.disabled = true;
                return;
            }
            
            previewArea.classList.add('show');
            selectionArea.classList.add('has-selection');
            uploadBtn.disabled = false;
            
            filesList.innerHTML = '';
            
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'selected-file-item';
                
                const fileIcon = getFileIcon(file.name);
                const fileSize = formatFileSize(file.size);
                
                fileItem.innerHTML = `
                    <div class="file-icon">${fileIcon}</div>
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${fileSize}</div>
                    </div>
                    ${file.type.startsWith('image/') ? `<img class="file-preview" src="${URL.createObjectURL(file)}" alt="Preview">` : ''}
                    <button class="remove-file" onclick="removeSelectedFile(${index})">‚úï</button>
                `;
                
                filesList.appendChild(fileItem);
            });
        }
        
        function getFileIcon(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            const iconMap = {
                'pdf': 'üìÑ',
                'doc': 'üìù', 'docx': 'üìù',
                'xls': 'üìä', 'xlsx': 'üìä',
                'ppt': 'üìä', 'pptx': 'üìä',
                'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'png': 'üñºÔ∏è', 'gif': 'üñºÔ∏è',
                'mp4': 'üé•', 'avi': 'üé•', 'mov': 'üé•',
                'mp3': 'üéµ', 'wav': 'üéµ',
                'zip': 'üì¶', 'rar': 'üì¶',
                'txt': 'üìÑ',
                'js': '‚ö°', 'html': 'üåê', 'css': 'üé®'
            };
            return iconMap[ext] || 'üìÑ';
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // ============================================================================
        // PUBLIC LINK FUNCTIONALITY
        // ============================================================================

        // Storage for public links
        let publicLinks = JSON.parse(localStorage.getItem('publicLinks') || '{}');

        // Create public link for file or folder
        function createPublicLink(type, id, name = '') {
            const modal = document.getElementById('publicLinkModal');
            if (!modal) {
                // Create modal if it doesn't exist
                createPublicLinkModal();
            }
            
            // Set modal data
            window.currentLinkData = {
                type: type,
                id: id,
                name: name || id,
                created: new Date().toISOString()
            };
            
            // Show modal
            document.getElementById('publicLinkModal').style.display = 'block';
            document.getElementById('linkItemName').textContent = name || id;
            document.getElementById('linkItemType').textContent = type === 'file' ? 'File' : 'Folder';
            
            // Reset form
            document.getElementById('linkExpiry').value = '24h';
            document.getElementById('linkPassword').value = '';
            document.getElementById('linkPermissions').value = 'view';
            
            // Clear previous generated link
            document.getElementById('generatedLinkSection').style.display = 'none';
        }

        // Generate the actual public link
        function generatePublicLink() {
            const expiry = document.getElementById('linkExpiry').value;
            const password = document.getElementById('linkPassword').value;
            const permissions = document.getElementById('linkPermissions').value;
            
            if (!window.currentLinkData) return;
            
            let linkId, linkData;
            
            // Check if we're in edit mode
            if (window.currentLinkData.editMode && window.currentLinkData.editLinkId) {
                // Edit existing link
                linkId = window.currentLinkData.editLinkId;
                const existingLink = publicLinks[linkId];
                
                // Calculate expiry time
                let expiryTime = null;
                if (expiry !== 'never') {
                    const duration = parseInt(expiry.slice(0, -1));
                    const unit = expiry.slice(-1);
                    const multiplier = unit === 'h' ? 3600000 : unit === 'd' ? 86400000 : 604800000; // h, d, w
                    expiryTime = Date.now() + (duration * multiplier);
                }
                
                // Update existing link data
                linkData = {
                    ...existingLink,
                    permissions: permissions,
                    password: password || null,
                    expiryTime: expiryTime
                };
                
                showAlert('üîó Public link updated successfully!', 'success');
            } else {
                // Create new link
                linkId = 'link_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                // Calculate expiry time
                let expiryTime = null;
                if (expiry !== 'never') {
                    const duration = parseInt(expiry.slice(0, -1));
                    const unit = expiry.slice(-1);
                    const multiplier = unit === 'h' ? 3600000 : unit === 'd' ? 86400000 : 604800000; // h, d, w
                    expiryTime = Date.now() + (duration * multiplier);
                }
                
                // Create link object
                linkData = {
                    id: linkId,
                    type: window.currentLinkData.type,
                    targetId: window.currentLinkData.id,
                    targetName: window.currentLinkData.name,
                    permissions: permissions,
                    password: password || null,
                    expiryTime: expiryTime,
                    created: window.currentLinkData.created,
                    accessCount: 0,
                    lastAccessed: null
                };
                
                showAlert('üîó Public link generated successfully!', 'success');
            }
            
            // Save to storage
            publicLinks[linkId] = linkData;
            localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
            
            // Generate the actual URL - ensure it points to index.html
            let baseUrl = window.location.origin + window.location.pathname;
            
            // If the pathname doesn't end with .html, ensure we point to index.html
            if (!baseUrl.endsWith('.html')) {
                // Remove trailing slash if present
                if (baseUrl.endsWith('/')) {
                    baseUrl = baseUrl.slice(0, -1);
                }
                // Add index.html
                baseUrl += '/index.html';
            }
            
            const publicUrl = `${baseUrl}?share=${linkId}`;
            
            // Show generated link
            document.getElementById('generatedLink').value = publicUrl;
            document.getElementById('generatedLinkSection').style.display = 'block';
            
            // Update stats
            updateLinkStats(linkData);
            
            showAlert('üîó Public link generated successfully!', 'success');
        }

        // Copy link to clipboard
        async function copyPublicLink() {
            const linkInput = document.getElementById('generatedLink');
            try {
                await navigator.clipboard.writeText(linkInput.value);
                showAlert('üìã Link copied to clipboard!', 'success');
            } catch (err) {
                // Fallback for older browsers
                linkInput.select();
                document.execCommand('copy');
                showAlert('üìã Link copied to clipboard!', 'success');
            }
        }

        // Generate QR code for link
        function generateQRCode() {
            const link = document.getElementById('generatedLink').value;
            if (!link) return;
            
            // Simple QR code generation using a service
            const qrContainer = document.getElementById('qrCodeContainer');
            qrContainer.innerHTML = `
                <h5>QR Code</h5>
                <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(link)}" 
                     alt="QR Code" style="max-width: 200px; border: 1px solid #ddd; border-radius: 8px;">
                <p style="margin-top: 10px; font-size: 12px; color: #666;">Scan with mobile device</p>
            `;
            qrContainer.style.display = 'block';
        }

        // Update link statistics
        function updateLinkStats(linkData) {
            const statsHtml = `
                <h5>Link Statistics</h5>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${linkData.accessCount}</div>
                        <div class="stat-label">Total Access</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${linkData.lastAccessed ? new Date(linkData.lastAccessed).toLocaleDateString() : 'Never'}</div>
                        <div class="stat-label">Last Accessed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${linkData.expiryTime ? new Date(linkData.expiryTime).toLocaleDateString() : 'Never'}</div>
                        <div class="stat-label">Expires</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${linkData.permissions.toUpperCase()}</div>
                        <div class="stat-label">Permissions</div>
                    </div>
                </div>
            `;
            document.getElementById('linkStats').innerHTML = statsHtml;
            document.getElementById('linkStats').style.display = 'block';
        }

        // Close public link modal
        function closePublicLinkModal() {
            document.getElementById('publicLinkModal').style.display = 'none';
            
            // Reset form and edit mode
            document.getElementById('linkExpiry').value = '24h';
            document.getElementById('linkPassword').value = '';
            document.getElementById('linkPermissions').value = 'view';
            document.getElementById('generatedLinkSection').style.display = 'none';
            document.getElementById('linkStats').style.display = 'none';
            
            window.currentLinkData = null;
        }

        // Check if shared link is accessed
        function checkSharedLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            
            if (shareId) {
                // Ensure publicLinks is loaded
                if (!publicLinks) {
                    publicLinks = JSON.parse(localStorage.getItem('publicLinks') || '{}');
                }
                
                if (publicLinks[shareId]) {
                    handleSharedLinkAccess(shareId);
                } else {
                    showAlert('‚ùå Shared link not found or invalid', 'error');
                    // Clean up URL
                    const url = new URL(window.location);
                    url.searchParams.delete('share');
                    window.history.replaceState({}, document.title, url);
                }
            }
        }

        // Handle shared link access
        function handleSharedLinkAccess(shareId) {
            const linkData = publicLinks[shareId];
            
            // Check if link is expired
            if (linkData.expiryTime && Date.now() > linkData.expiryTime) {
                showAlert('‚è∞ This shared link has expired', 'error');
                return;
            }
            
            // Check if password is required
            if (linkData.password) {
                const enteredPassword = prompt('This shared link is password protected. Please enter the password:');
                if (enteredPassword !== linkData.password) {
                    showAlert('‚ùå Incorrect password', 'error');
                    return;
                }
            }
            
            // Update access stats
            linkData.accessCount++;
            linkData.lastAccessed = Date.now();
            localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
            
            // Show shared content
            showSharedContent(linkData);
        }

        // Show shared content
        async function showSharedContent(linkData) {
            showAlert('üîó Loading shared content...', 'info');
            
            if (linkData.type === 'file') {
                // Download the shared file
                try {
                    await downloadFile(linkData.targetId);
                    showAlert(`üì• Downloading shared file: ${linkData.targetName}`, 'success');
                } catch (error) {
                    console.error('Error downloading shared file:', error);
                    showAlert('‚ùå Error downloading shared file', 'error');
                }
            } else if (linkData.type === 'folder') {
                // Navigate to shared folder
                try {
                    // For shared folders, we need to set the current folder and load it
                    const folderPath = linkData.targetId;
                    
                    // Clear URL parameters to avoid confusion
                    const url = new URL(window.location);
                    url.searchParams.delete('share');
                    window.history.replaceState({}, document.title, url);
                    
                    // Load the shared folder
                    await loadFolder(folderPath);
                    showAlert(`üìÅ Opened shared folder: ${linkData.targetName}`, 'success');
                } catch (error) {
                    console.error('Error loading shared folder:', error);
                    showAlert('‚ùå Error loading shared folder', 'error');
                }
            }
        }

        // ============================================================================
        // NETWORK OPTIMIZATION AND CACHING FUNCTIONS
        // ============================================================================

        // Check if cache is still valid
        function isCacheValid() {
            return cacheTimestamp && (Date.now() - cacheTimestamp) < CACHE_DURATION;
        }

        // Clear expired cache
        function clearExpiredCache() {
            if (!isCacheValid()) {
                console.log('üóëÔ∏è Clearing expired cache');
                allFilesCache.clear();
                loadedFileIds.clear();
                cacheTimestamp = null;
                lastSyncHash = null;
            }
        }

        // Generate hash for incremental sync
        function generateFileListHash(fileList) {
            const simplified = fileList.map(f => `${f.id}:${f.uploadDate}`).sort().join('|');
            return btoa(simplified).substring(0, 16);
        }

        // Network usage tracking functions
        function trackNetworkRequest(size = 0) {
            networkStats.requests++;
            updateNetworkUsageDisplay();
        }

        function trackCacheHit(size = 0) {
            networkStats.cacheHits++;
            networkStats.dataSaved += size;
            updateNetworkUsageDisplay();
        }

        function updateNetworkUsageDisplay() {
            const requestCount = document.getElementById('requestCount');
            const cacheHits = document.getElementById('cacheHits');
            const dataSaved = document.getElementById('dataSaved');
            
            if (requestCount) requestCount.textContent = networkStats.requests;
            if (cacheHits) cacheHits.textContent = networkStats.cacheHits;
            if (dataSaved) dataSaved.textContent = formatFileSize(networkStats.dataSaved);
        }

        function resetNetworkStats() {
            networkStats = {
                requests: 0,
                cacheHits: 0,
                dataSaved: 0
            };
            updateNetworkUsageDisplay();
        }

        // Data compression utilities (simple compression for metadata)
        function compressMetadata(metadata) {
            try {
                // Remove unnecessary fields for display
                const compressed = {
                    i: metadata.id,
                    n: metadata.name,
                    f: metadata.folder,
                    s: metadata.size,
                    m: metadata.mimetype,
                    u: metadata.uploadDate,
                    h: metadata.sha,
                    c: metadata.hasContent
                };
                
                // Only include chunking info if present
                if (metadata.isChunked) {
                    compressed.ch = metadata.totalChunks;
                    compressed.ts = metadata.totalSize;
                }
                
                return compressed;
            } catch (error) {
                console.warn('Failed to compress metadata:', error);
                return metadata;
            }
        }

        function decompressMetadata(compressed) {
            try {
                const metadata = {
                    id: compressed.i || compressed.id,
                    name: compressed.n || compressed.name,
                    folder: compressed.f || compressed.folder,
                    size: compressed.s || compressed.size,
                    mimetype: compressed.m || compressed.mimetype,
                    uploadDate: compressed.u || compressed.uploadDate,
                    sha: compressed.h || compressed.sha,
                    hasContent: compressed.c !== undefined ? compressed.c : compressed.hasContent
                };
                
                // Restore chunking info if present
                if (compressed.ch) {
                    metadata.isChunked = true;
                    metadata.totalChunks = compressed.ch;
                    metadata.totalSize = compressed.ts;
                }
                
                return metadata;
            } catch (error) {
                console.warn('Failed to decompress metadata:', error);
                return compressed;
            }
        }

        // Batch operations for better performance
        async function processBatchedRequests(requests, batchSize = 5) {
            const results = [];
            
            for (let i = 0; i < requests.length; i += batchSize) {
                const batch = requests.slice(i, i + batchSize);
                const batchResults = await Promise.allSettled(batch);
                
                results.push(...batchResults.map(result => 
                    result.status === 'fulfilled' ? result.value : null
                ).filter(Boolean));
                
                // Small delay between batches to avoid rate limiting
                if (i + batchSize < requests.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            return results;
        }

        // Get cached file metadata
        function getCachedFile(fileId) {
            if (isCacheValid() && allFilesCache.has(fileId)) {
                console.log(`üìã Using cached metadata for: ${fileId}`);
                const file = allFilesCache.get(fileId);
                trackCacheHit(file.size || 0);
                return file;
            }
            return null;
        }

        // Cache file metadata
        function cacheFileMetadata(file) {
            allFilesCache.set(file.id, {
                ...file,
                cachedAt: Date.now()
            });
            
            if (!cacheTimestamp) {
                cacheTimestamp = Date.now();
            }
        }

        // Intelligent file list loading with pagination
        async function getOptimizedFileList(page = 1, limit = FILES_PER_PAGE, forceRefresh = false) {
            try {
                // Clear expired cache
                clearExpiredCache();
                
                // Use cache if available and not forcing refresh
                if (!forceRefresh && isCacheValid() && allFilesCache.size > 0) {
                    console.log(`üìã Using cached file list (${allFilesCache.size} files)`);
                    const cachedFiles = Array.from(allFilesCache.values());
                    const startIndex = (page - 1) * limit;
                    const endIndex = startIndex + limit;
                    
                    // Track cache usage
                    trackCacheHit(cachedFiles.length * 1024); // Estimate 1KB per file metadata
                    
                    return {
                        files: cachedFiles.slice(startIndex, endIndex),
                        totalFiles: cachedFiles.length,
                        totalPages: Math.ceil(cachedFiles.length / limit),
                        currentPage: page,
                        fromCache: true
                    };
                }

                console.log(`üîç Loading optimized file list (page ${page}, limit ${limit})`);
                
                // Get lightweight file list first (metadata only)
                const allFiles = await getGitHubFileListOptimized();
                
                // Update cache
                allFiles.forEach(file => cacheFileMetadata(file));
                
                // Generate hash for incremental sync
                const currentHash = generateFileListHash(allFiles);
                const hasChanges = lastSyncHash !== currentHash;
                lastSyncHash = currentHash;
                
                // Return paginated results
                const startIndex = (page - 1) * limit;
                const endIndex = startIndex + limit;
                
                console.log(`üìã Loaded ${allFiles.length} files, showing ${startIndex + 1}-${Math.min(endIndex, allFiles.length)}`);
                
                return {
                    files: allFiles.slice(startIndex, endIndex),
                    totalFiles: allFiles.length,
                    totalPages: Math.ceil(allFiles.length / limit),
                    currentPage: page,
                    fromCache: false,
                    hasChanges
                };
                
            } catch (error) {
                console.error('‚ùå Error in optimized file list loading:', error);
                throw error;
            }
        }

        // Optimized version of getGitHubFileList - loads only metadata, no content
        async function getGitHubFileListOptimized() {
            try {
                const filesPath = `${GITHUB_CONFIG.DATA_PATH}files`;
                console.log(`üîç Getting optimized file list from GitHub: ${filesPath}`);
                
                // Get contents of the files directory
                const response = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filesPath}`,
                    'GET'
                );
                
                if (!response || !Array.isArray(response)) {
                    console.log('üìÅ No files directory or empty response');
                    return [];
                }
                
                console.log(`üìÅ Found ${response.length} metadata files`);
                const fileList = [];
                
                // Process metadata files with minimal data transfer
                for (const item of response) {
                    if (item.name.endsWith('.json') && item.type === 'file' && item.name !== '.gitkeep') {
                        try {
                            // Check if we already have this file in cache
                            const fileId = item.name.replace('.json', '');
                            const cached = getCachedFile(fileId);
                            
                            if (cached && cached.sha === item.sha) {
                                // File hasn't changed, use cache
                                fileList.push(cached);
                                continue;
                            }
                            
                            // Only load metadata, not file content
                            let metadata = null;
                            
                            if (item.size > 1024 * 1024) { // 1MB
                                // For large metadata files, use download URL but only get metadata
                                console.log(`üìã Loading large metadata file efficiently: ${item.name}`);
                                const response = await fetch(item.download_url);
                                if (response.ok) {
                                    const metadataContent = await response.text();
                                    const fullMetadata = JSON.parse(metadataContent);
                                    
                                    // Extract only essential metadata, exclude heavy 'data' field
                                    metadata = {
                                        id: fullMetadata.id,
                                        name: fullMetadata.name,
                                        folder: fullMetadata.folder,
                                        size: fullMetadata.size,
                                        mimetype: fullMetadata.mimetype,
                                        uploadDate: fullMetadata.uploadDate,
                                        sha: item.sha,
                                        // Don't include 'data' field to save bandwidth
                                        hasContent: !!fullMetadata.data
                                    };
                                }
                            } else {
                                // For small files, use GitHub API
                                const metadataResponse = await githubApiRequest(item.url, 'GET');
                                if (metadataResponse && metadataResponse.content) {
                                    const metadataContent = atob(metadataResponse.content);
                                    const fullMetadata = JSON.parse(metadataContent);
                                    
                                    // Extract only essential metadata
                                    metadata = {
                                        id: fullMetadata.id,
                                        name: fullMetadata.name,
                                        folder: fullMetadata.folder,
                                        size: fullMetadata.size,
                                        mimetype: fullMetadata.mimetype,
                                        uploadDate: fullMetadata.uploadDate,
                                        sha: item.sha,
                                        hasContent: !!fullMetadata.data
                                    };
                                }
                            }
                            
                            if (metadata && metadata.name && metadata.folder) {
                                fileList.push(metadata);
                                console.log(`‚úÖ Loaded optimized metadata: ${metadata.name}`);
                            }
                            
                        } catch (error) {
                            console.warn(`Failed to parse optimized metadata for ${item.name}:`, error);
                        }
                    }
                }
                
                console.log(`üìÅ Successfully loaded ${fileList.length} files with optimized metadata`);
                return fileList;
                
            } catch (error) {
                console.error('‚ùå Error loading optimized GitHub file list:', error);
                throw error;
            }
        }

        // ============================================================================
        // REAL-TIME PROGRESS AND SYNC SYSTEM
        // ============================================================================

        // Progress Management Functions
        function createOperation(title, type = 'upload') {
            const id = ++operationCounter;
            const operation = {
                id,
                title,
                type,
                progress: 0,
                status: 'Starting...',
                startTime: Date.now()
            };
            
            currentOperations.set(id, operation);
            renderOperations();
            return id;
        }

        function updateOperation(id, progress, status) {
            const operation = currentOperations.get(id);
            if (operation) {
                operation.progress = Math.min(100, Math.max(0, progress));
                operation.status = status;
                renderOperations();
            }
        }

        function completeOperation(id, finalStatus = 'Completed') {
            const operation = currentOperations.get(id);
            if (operation) {
                operation.progress = 100;
                operation.status = finalStatus;
                renderOperations();
                
                // Remove after 3 seconds
                setTimeout(() => {
                    currentOperations.delete(id);
                    renderOperations();
                }, 3000);
            }
        }

        function renderOperations() {
            const container = document.getElementById('activeOperations');
            const globalProgress = document.getElementById('globalProgress');
            const globalProgressBar = document.getElementById('globalProgressBar');
            const globalProgressText = document.getElementById('globalProgressText');
            
            // Clear existing operations
            container.innerHTML = '';
            
            if (currentOperations.size === 0) {
                globalProgress.style.display = 'none';
                return;
            }
            
            // Show global progress
            globalProgress.style.display = 'block';
            
            // Calculate overall progress
            let totalProgress = 0;
            let activeOperations = 0;
            
            currentOperations.forEach(operation => {
                totalProgress += operation.progress;
                activeOperations++;
                
                // Create operation UI
                const operationEl = document.createElement('div');
                operationEl.className = 'operation-item';
                operationEl.innerHTML = `
                    <div class="operation-title">${operation.title}</div>
                    <div class="operation-progress">
                        <div class="operation-progress-fill" style="width: ${operation.progress}%"></div>
                    </div>
                    <div class="operation-status">${operation.status} (${operation.progress.toFixed(1)}%)</div>
                `;
                container.appendChild(operationEl);
            });
            
            // Update global progress
            const avgProgress = activeOperations > 0 ? totalProgress / activeOperations : 0;
            globalProgressBar.style.width = `${avgProgress}%`;
            globalProgressText.textContent = `${activeOperations} active operation${activeOperations !== 1 ? 's' : ''} ‚Ä¢ ${avgProgress.toFixed(1)}%`;
        }

        // Auto-Sync Functions
        function initializeAutoSync() {
            console.log('üîÑ Initializing auto-sync system...');
            updateSyncStatus('Auto-sync enabled', false);
            
            if (autoSyncEnabled) {
                startAutoSync();
            }
        }

        function startAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
            }
            
            autoSyncInterval = setInterval(async () => {
                if (!syncInProgress && autoSyncEnabled) {
                    await performAutoSync();
                }
            }, AUTO_SYNC_INTERVAL);
            
            console.log(`üîÑ Auto-sync started with ${AUTO_SYNC_INTERVAL/1000}s interval`);
        }

        function stopAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
                autoSyncInterval = null;
            }
            console.log('‚è∏Ô∏è Auto-sync stopped');
        }

        async function performAutoSync() {
            if (syncInProgress) return;
            
            syncInProgress = true;
            updateSyncStatus('Syncing...', true);
            
            try {
                console.log('üîÑ Performing optimized auto-sync...');
                
                // Create sync operation
                const syncId = createOperation('Auto-sync', 'sync');
                
                // Check for incremental updates first
                updateOperation(syncId, 20, 'Checking for changes...');
                
                // Only refresh if cache is expired or force refresh
                const needsRefresh = !isCacheValid();
                
                if (needsRefresh) {
                    // Update file list with optimization
                    updateOperation(syncId, 50, 'Refreshing file list...');
                    await loadFileList(currentPage, false); // Don't force refresh unless needed
                    
                    // Update folder list
                    updateOperation(syncId, 70, 'Refreshing folders...');
                    await loadFolders();
                } else {
                    updateOperation(syncId, 70, 'Using cached data...');
                    console.log('üìã Auto-sync using cached data, no network request needed');
                }
                
                // Update storage stats (lightweight)
                updateOperation(syncId, 90, 'Updating storage stats...');
                await updateStorageInfo();
                
                // Complete sync
                updateOperation(syncId, 100, 'Sync completed');
                completeOperation(syncId, needsRefresh ? '‚úÖ Refreshed' : 'üìã Cached');
                
                lastSyncTime = new Date();
                updateSyncStatus('Auto-sync enabled', false);
                
                console.log(`‚úÖ Auto-sync completed successfully (${needsRefresh ? 'refreshed' : 'cached'})`);
                
            } catch (error) {
                console.error('‚ùå Auto-sync failed:', error);
                updateSyncStatus('Sync failed', false);
                // Remove annoying auto-sync popup - only show in console
                // showAlert('‚ùå Auto-sync failed: ' + error.message, 'error');
            } finally {
                syncInProgress = false;
            }
        }

        function updateSyncStatus(text, isActive) {
            const syncIcon = document.getElementById('syncIcon');
            const syncText = document.getElementById('syncText');
            const lastSyncEl = document.getElementById('lastSyncTime');
            const toggleBtn = document.getElementById('toggleAutoSync');
            
            if (syncIcon) {
                syncIcon.className = isActive ? 'sync-icon syncing' : 'sync-icon';
                syncIcon.textContent = isActive ? 'üîÑ' : (autoSyncEnabled ? 'üîÑ' : '‚è∏Ô∏è');
            }
            
            if (syncText) {
                syncText.textContent = text;
            }
            
            if (lastSyncEl && lastSyncTime) {
                const timeAgo = getTimeAgo(lastSyncTime);
                lastSyncEl.textContent = timeAgo;
            }
            
            if (toggleBtn) {
                toggleBtn.textContent = autoSyncEnabled ? 'Disable' : 'Enable';
                toggleBtn.className = autoSyncEnabled ? 'sync-toggle' : 'sync-toggle disabled';
            }
        }

        function toggleAutoSync() {
            autoSyncEnabled = !autoSyncEnabled;
            
            if (autoSyncEnabled) {
                startAutoSync();
                updateSyncStatus('Auto-sync enabled', false);
                // Remove annoying popup - status visible in UI
                // showAlert('üîÑ Auto-sync enabled', 'info');
            } else {
                stopAutoSync();
                updateSyncStatus('Auto-sync disabled', false);
                // Remove annoying popup - status visible in UI  
                // showAlert('‚è∏Ô∏è Auto-sync disabled', 'info');
            }
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            return date.toLocaleDateString();
        }
        
        function removeSelectedFile(index) {
            selectedFiles.splice(index, 1);
            updateFileSelectionPreview();
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Debug: Clear potential old API cache and service workers
                console.log('üßπ Clearing caches and checking for service workers...');
                
                // Unregister any service workers
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (let registration of registrations) {
                        console.log('üóëÔ∏è Unregistering service worker:', registration.scope);
                        await registration.unregister();
                    }
                }
                
                // Clear application caches if available
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    for (let cacheName of cacheNames) {
                        console.log('üóëÔ∏è Deleting cache:', cacheName);
                        await caches.delete(cacheName);
                    }
                }
                
                // Override fetch to detect any old API calls
                const originalFetch = window.fetch;
                window.fetch = function(...args) {
                    const url = args[0];
                    if (typeof url === 'string' && (url.includes('/api/files') || url.includes('/api/folders'))) {
                        console.error('üö® Detected old API call to:', url);
                        console.trace('üîç Call stack:');
                        return Promise.reject(new Error('Old API endpoints disabled. Using GitHub/IndexedDB storage.'));
                    }
                    return originalFetch.apply(this, args);
                };
                
                showAlert('üöÄ Initializing Real Storage System...', 'info');
                
                // Check if we need to show cache clear instructions
                const lastCacheClear = localStorage.getItem('lastCacheClear');
                const now = Date.now();
                if (!lastCacheClear || (now - parseInt(lastCacheClear)) > 86400000) { // 24 hours
                    showAlert('üí° Jika mengalami error 404 API, lakukan hard refresh (Ctrl+F5)', 'warning', 5000);
                    localStorage.setItem('lastCacheClear', now.toString());
                }
                
                // Force validate GitHub configuration and storage mode
                await validateGitHubConfig();
                
                // Validate GitHub storage if in GitHub mode
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    const isValid = await validateGitHubStorage();
                    if (!isValid && storageMode === 'github') {
                        // If GitHub validation fails in GitHub-only mode, switch to local
                        storageMode = 'indexeddb';
                        localStorage.setItem('storage_mode', 'indexeddb');
                        document.getElementById('storageMode').value = 'indexeddb';
                        showAlert('‚ö†Ô∏è GitHub storage failed, switched to Local mode', 'warning');
                    }
                }
                
                await loadAllData();
                await loadFolders();
                await loadFileList();
                setupDragAndDrop();
                await updateStorageInfo();
                
                // Initialize navigation
                updateBackButton();
                
                // Initialize view mode
                const savedViewMode = localStorage.getItem('viewMode') || 'list';
                switchView(savedViewMode);
                
                // Initialize auto-sync system
                initializeAutoSync();
                
                showAlert('‚úÖ Real GitHub Storage System Ready! Your files are now stored permanently in repository.', 'success');
            } catch (error) {
                console.error('Initialization error:', error);
                showAlert('Error initializing storage: ' + error.message, 'error');
            }
        });

        // Load data index file
        async function loadDataIndex() {
            try {
                const response = await fetch(FILE_CONFIG.DATA_PATH + FILE_CONFIG.INDEX_FILE);
                if (!response.ok) {
                    throw new Error('Index file not found');
                }
                dataIndex = await response.json();
                console.log('Data index loaded:', dataIndex);
            } catch (error) {
                console.error('Error loading data index:', error);
                // Create default index if not exists
                dataIndex = {
                    version: "2.0",
                    lastUpdate: new Date().toISOString(),
                    dataFiles: [{
                        filename: "files-001.json",
                        fileNumber: 1,
                        currentSize: 0,
                        maxSize: FILE_CONFIG.MAX_FILE_SIZE,
                        active: true,
                        created: new Date().toISOString()
                    }],
                    totalDataFiles: 1,
                    totalFolders: 0,
                    totalFiles: 0,
                    totalSizeBytes: 0
                };
                showAlert('‚ö†Ô∏è Mode offline: Menggunakan data lokal. Data tidak akan tersimpan permanen.', 'warning');
            }
        }

        // Load all data files
        // Initialize and load all data from IndexedDB
        async function loadAllData() {
            try {
                await initDatabase();
                updateStorageInfo();
                console.log('‚úÖ Real storage system initialized');
            } catch (error) {
                console.error('‚ùå Failed to initialize database:', error);
                showAlert('Error initializing storage: ' + error.message, 'error');
            }
        }

        // Legacy function for compatibility - replaced with IndexedDB
        async function loadAllDataFiles() {
            // No longer needed - data comes from IndexedDB
            console.log('‚ÑπÔ∏è Using IndexedDB instead of JSON files');
            return Promise.resolve();
        }

        // Get all folders from IndexedDB
        async function getFoldersData() {
            const folders = await getAllFolders();
            const foldersObject = {};
            folders.forEach(folder => {
                foldersObject[folder.name] = folder;
            });
            return foldersObject;
        }

        // Get all files from IndexedDB
        async function getFilesData() {
            return await getAllFiles();
        }

        // Save data to appropriate JSON file
        async function saveData(newFolders = null, newFiles = null) {
            try {
                // In a real GitHub Pages environment, this would need a backend service
                // For demo purposes, we'll show what the data would look like
                
                if (newFolders !== null) {
                    // Update folders in the first data file
                    if (allDataFiles.length > 0) {
                        allDataFiles[0].data.folders = newFolders;
                    }
                }

                if (newFiles !== null) {
                    // Distribute files across data files based on size
                    await distributeFilesAcrossDataFiles(newFiles);
                }

                // Update metadata
                updateDataIndex();
                updateStorageInfo();

                showAlert('‚ö†Ô∏è Demo Mode: Data changes tidak tersimpan secara permanen. Dalam implementasi nyata, data akan disimpan ke file JSON di repository.', 'warning');
                
            } catch (error) {
                console.error('Error saving data:', error);
                showAlert('Error saving data: ' + error.message, 'error');
            }
        }

        // Wrapper functions for backward compatibility - now use IndexedDB
        async function saveFoldersData(foldersData) {
            // Convert object to array and save each folder
            for (const [folderName, folderData] of Object.entries(foldersData)) {
                await saveFolder({
                    id: folderName,
                    name: folderName,
                    ...folderData
                });
            }
        }

        async function saveFilesData(filesData) {
            try {
                console.log('üíæ Starting saveFilesData for', filesData.length, 'data files');
                
                // Use the global storageMode variable
                console.log('üìä Using storage mode:', storageMode);
                
                let allSuccessful = true;
                let totalFilesSaved = 0;
                
                // Process each data file container
                for (const dataFile of filesData) {
                    console.log(`üóÇÔ∏è Processing data file with ${dataFile.data.files.length} files`);
                    
                    // Process each file in this data container
                    for (const file of dataFile.data.files) {
                        console.log(`üíæ Saving individual file: ${file.name} (${formatFileSize(file.size)})`);
                        
                        let fileSuccess = false;
                        
                        if (storageMode === 'github' || storageMode === 'hybrid') {
                            try {
                                console.log(`üíæ Attempting GitHub storage for: ${file.name}`);
                                const githubSuccess = await saveFileWithGitHubChunking(file, file.data);
                                console.log(`üíæ GitHub save result for ${file.name}:`, githubSuccess);
                                fileSuccess = githubSuccess;
                            } catch (error) {
                                console.error(`‚ùå GitHub save failed for ${file.name}:`, error);
                                if (storageMode === 'github') {
                                    allSuccessful = false;
                                    continue;
                                }
                            }
                        }
                        
                        if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                            try {
                                console.log(`üíæ Attempting IndexedDB storage for: ${file.name}`);
                                const indexedDBSuccess = await saveFileWithChunking(file, file.data);
                                console.log(`üíæ IndexedDB save result for ${file.name}:`, indexedDBSuccess);
                                fileSuccess = fileSuccess || indexedDBSuccess;
                            } catch (error) {
                                console.error(`‚ùå IndexedDB save failed for ${file.name}:`, error);
                                allSuccessful = false;
                            }
                        }
                        
                        if (!fileSuccess) {
                            console.error(`‚ùå Failed to save file: ${file.name}`);
                            allSuccessful = false;
                        } else {
                            console.log(`‚úÖ Successfully saved file: ${file.name}`);
                            totalFilesSaved++;
                        }
                    }
                }
                
                console.log(`üíæ Save operation completed. Files saved: ${totalFilesSaved}, Overall success: ${allSuccessful}`);
                return allSuccessful;
                
            } catch (error) {
                console.error('‚ùå Error in saveFilesData:', error);
                return false;
            }
        }

        // Distribute files across multiple JSON files based on size
        async function distributeFilesAcrossDataFiles(files) {
            try {
                // Clear existing files from all data files
                allDataFiles.forEach(fileData => {
                    fileData.data.files = [];
                });

                let currentFileIndex = 0;
                let currentSize = JSON.stringify(allDataFiles[currentFileIndex]?.data || {}).length;

                for (const file of files) {
                    const fileSize = JSON.stringify(file).length;
                    
                    // Check if adding this file would exceed the limit
                    if (currentSize + fileSize > FILE_CONFIG.MAX_FILE_SIZE && 
                        allDataFiles[currentFileIndex]?.data.files.length > 0) {
                        
                        // Need a new data file
                        currentFileIndex++;
                        currentSize = 0;
                        
                        // Create new data file if doesn't exist
                        if (currentFileIndex >= allDataFiles.length) {
                            await createNewDataFile(currentFileIndex + 1);
                        }
                    }

                    // Add file to current data file
                    if (allDataFiles[currentFileIndex]) {
                        allDataFiles[currentFileIndex].data.files.push(file);
                        currentSize += fileSize;
                        allDataFiles[currentFileIndex].info.currentSize = currentSize;
                    }
                }

                console.log(`Files distributed across ${currentFileIndex + 1} data files`);
                
            } catch (error) {
                console.error('Error distributing files:', error);
                throw error;
            }
        }

        // Create new data file when needed
        async function createNewDataFile(fileNumber) {
            try {
                const filename = `${FILE_CONFIG.FILE_PREFIX}${fileNumber.toString().padStart(3, '0')}${FILE_CONFIG.FILE_EXTENSION}`;
                
                const newDataFile = {
                    version: "2.0",
                    metadata: {
                        created: new Date().toISOString(),
                        lastUpdate: new Date().toISOString(),
                        fileNumber: fileNumber,
                        totalFiles: dataIndex.totalDataFiles + 1,
                        maxSizeBytes: FILE_CONFIG.MAX_FILE_SIZE,
                        currentSizeBytes: 0
                    },
                    folders: {},
                    files: []
                };

                const newFileInfo = {
                    filename: filename,
                    fileNumber: fileNumber,
                    currentSize: 0,
                    maxSize: FILE_CONFIG.MAX_FILE_SIZE,
                    active: true,
                    created: new Date().toISOString()
                };

                // Add to data index
                dataIndex.dataFiles.push(newFileInfo);
                dataIndex.totalDataFiles++;

                // Add to loaded data files
                allDataFiles.push({
                    info: newFileInfo,
                    data: newDataFile
                });

                console.log(`Created new data file: ${filename}`);
                showAlert(`üìÑ File data baru dibuat: ${filename}`, 'success');

            } catch (error) {
                console.error('Error creating new data file:', error);
                throw error;
            }
        }

        // Update data index metadata
        function updateDataIndex() {
            if (!dataIndex) return;

            const allFolders = getFoldersData();
            const allFiles = getFilesData();
            
            dataIndex.lastUpdate = new Date().toISOString();
            dataIndex.totalFolders = Object.keys(allFolders).length;
            dataIndex.totalFiles = allFiles.length;
            dataIndex.totalSizeBytes = JSON.stringify(allFiles).length;

            // Update individual file sizes
            allDataFiles.forEach((fileData, index) => {
                if (dataIndex.dataFiles[index]) {
                    dataIndex.dataFiles[index].currentSize = JSON.stringify(fileData.data).length;
                }
            });
        }

        // Simple hash function for password (client-side only)
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // File to base64 conversion
        function fileToBase64(file, progressCallback = null) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                
                reader.onprogress = (event) => {
                    if (progressCallback && event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        progressCallback(percentComplete);
                    }
                };
                
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Enhanced file to base64 with progress for large files
        async function fileToBase64WithProgress(file, fileName) {
            if (file.size > 50 * 1024 * 1024) { // Show progress for files > 50MB (with 20MB chunks)
                let progressToast = null;
                
                const progressCallback = (percent) => {
                    const message = `Memproses "${fileName}": ${Math.round(percent)}%`;
                    if (progressToast) {
                        // Update existing toast message
                        const messageDiv = progressToast.querySelector('.toast-message');
                        if (messageDiv) {
                            messageDiv.textContent = message;
                        }
                    } else {
                        progressToast = showAlert(message, 'info', 0); // Persistent toast
                    }
                };
                
                try {
                    const result = await fileToBase64(file, progressCallback);
                    
                    // Hide progress toast
                    if (progressToast) {
                        hideToast(progressToast);
                    }
                    
                    showAlert(`File "${fileName}" berhasil diproses (${formatFileSize(file.size)})`, 'success');
                    return result;
                } catch (error) {
                    if (progressToast) {
                        hideToast(progressToast);
                    }
                    throw error;
                }
            } else {
                return await fileToBase64(file);
            }
        }

        // Base64 to file download - FIXED VERSION
        function downloadBase64File(base64Data, filename) {
            try {
                console.log(`üì• Starting download for: ${filename}`);
                console.log(`üìä Base64 data length: ${base64Data.length} characters`);
                
                // Remove data URL prefix if present (e.g., "data:image/png;base64,")
                let cleanBase64 = base64Data;
                if (base64Data.includes(',')) {
                    cleanBase64 = base64Data.split(',')[1];
                    console.log(`üßπ Cleaned base64 data length: ${cleanBase64.length} characters`);
                }
                
                // Convert base64 to binary data
                const binaryString = atob(cleanBase64);
                console.log(`üî¢ Binary string length: ${binaryString.length} bytes`);
                
                // Create Uint8Array from binary string
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                console.log(`üì¶ Created Uint8Array with ${bytes.length} bytes`);
                
                // Create blob with correct MIME type
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                console.log(`üíæ Created blob with size: ${blob.size} bytes`);
                
                // Create download URL and trigger download
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL object
                URL.revokeObjectURL(url);
                
                console.log(`‚úÖ Download triggered for: ${filename} (${blob.size} bytes)`);
                
            } catch (error) {
                console.error('‚ùå Error in downloadBase64File:', error);
                showAlert(`Error downloading file: ${error.message}`, 'error');
            }
        }

        // Update storage info
        async function updateStorageInfo() {
            try {
                // Get stats based on storage mode  
                let stats = { totalSize: 0, totalFiles: 0, totalFolders: 0, totalChunks: 0, chunkedFiles: 0 };
                
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    try {
                        const githubFiles = await getGitHubFileList();
                        const githubStats = {
                            totalFiles: githubFiles.length,
                            totalSize: githubFiles.reduce((sum, file) => sum + (file.totalSize || file.size || 0), 0),
                            totalChunks: githubFiles.reduce((sum, file) => sum + (file.totalChunks || 1), 0),
                            chunkedFiles: githubFiles.filter(file => file.isChunked).length,
                            totalFolders: new Set(githubFiles.map(file => file.folder).filter(f => f)).size
                        };
                        
                        if (storageMode === 'github') {
                            stats = githubStats;
                        } else {
                            // Hybrid mode - merge with IndexedDB stats
                            const indexedDBStats = await getStorageStats();
                            stats = {
                                totalFiles: githubStats.totalFiles + (indexedDBStats.totalFiles || 0),
                                totalSize: githubStats.totalSize + (indexedDBStats.totalSize || 0),
                                totalChunks: githubStats.totalChunks + (indexedDBStats.totalChunks || 0),
                                chunkedFiles: githubStats.chunkedFiles + (indexedDBStats.chunkedFiles || 0),
                                totalFolders: githubStats.totalFolders + (indexedDBStats.totalFolders || 0)
                            };
                        }
                    } catch (error) {
                        console.warn('Failed to get GitHub stats:', error);
                        if (storageMode === 'hybrid') {
                            stats = await getStorageStats();
                        }
                    }
                } else {
                    // IndexedDB only
                    stats = await getStorageStats();
                }
                
                const totalSizeBytes = stats.totalSize || 0;
                const totalSizeKB = (totalSizeBytes / 1024).toFixed(2);
                const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
                
                document.getElementById('storageUsed').textContent = 
                    totalSizeBytes > 1024 * 1024 ? totalSizeMB + ' MB' : totalSizeKB + ' KB';
                
                document.getElementById('fileCount').textContent = stats.totalChunks || 0;
                
                // Update storage details with current mode info
                const storageDetails = document.getElementById('storageDetails');
                const storageTypeText = storageMode === 'github' ? 'üåê GitHub Repository Storage' :
                                      storageMode === 'hybrid' ? 'üîÑ Hybrid Storage (GitHub + Local)' :
                                      'üíæ Local IndexedDB Storage';
                
                storageDetails.innerHTML = 
                    `ÔøΩ ${stats.totalFiles || 0} files dalam ${stats.totalFolders || 0} folders ‚Ä¢ ` +
                    `üì¶ ${stats.totalChunks || 0} chunks ‚Ä¢ ` +
                    `üîó ${stats.chunkedFiles || 0} chunked files ‚Ä¢ ` +
                    storageTypeText;
                
                console.log('üìä Storage Stats:', stats);
            } catch (error) {
                console.error('Error updating storage info:', error);
                document.getElementById('storageUsed').textContent = 'Error';
                document.getElementById('fileCount').textContent = '0';
            }
        }

        // Refresh data files from IndexedDB
        async function refreshDataFiles() {
            try {
                showAlert('üîÑ Refreshing data from IndexedDB...', 'success');
                await loadAllData();
                await loadFolders();
                await loadFileList();
                await updateStorageInfo();
                showAlert('‚úÖ Data refreshed successfully!', 'success');
            } catch (error) {
                showAlert('Error refreshing data: ' + error.message, 'error');
            }
        }

        // Show data files list
        function showDataFilesList() {
            if (!dataIndex || !dataIndex.dataFiles) {
                showAlert('No data files information available', 'error');
                return;
            }

            let filesList = 'üìã Data Files:\n\n';
            dataIndex.dataFiles.forEach((file, index) => {
                const sizeKB = (file.currentSize / 1024).toFixed(1);
                const maxSizeKB = (file.maxSize / 1024).toFixed(0);
                const percentage = ((file.currentSize / file.maxSize) * 100).toFixed(1);
                
                filesList += `${index + 1}. ${file.filename}\n`;
                filesList += `   Size: ${sizeKB} KB / ${maxSizeKB} KB (${percentage}%)\n`;
                filesList += `   Status: ${file.active ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
                filesList += `   Created: ${new Date(file.created).toLocaleString('id-ID')}\n\n`;
            });

            alert(filesList);
        }

        // Show public links manager
        function showPublicLinksManager() {
            // Create modal if it doesn't exist
            if (!document.getElementById('linksManagerModal')) {
                createLinksManagerModal();
            }
            
            // Populate and show modal
            populateLinksManager();
            document.getElementById('linksManagerModal').style.display = 'block';
        }

        // Create links manager modal
        function createLinksManagerModal() {
            const modalHtml = `
                <div id="linksManagerModal" class="links-manager-modal">
                    <div class="links-manager-content">
                        <div class="public-link-header">
                            <h3>üîó Manage Public Links</h3>
                            <button class="close-modal" onclick="closeLinksManager()">&times;</button>
                        </div>
                        
                        <div class="manager-actions">
                            <button class="btn" onclick="cleanupExpiredLinks()">üßπ Clean Expired</button>
                            <button class="btn" onclick="exportPublicLinks()">ÔøΩ Export Links</button>
                            <button class="btn btn-danger" onclick="deleteAllLinks()">üóëÔ∏è Delete All</button>
                        </div>

                        <div id="linksTableContainer">
                            <!-- Table will be populated here -->
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // Populate links manager with current links
        function populateLinksManager() {
            const container = document.getElementById('linksTableContainer');
            const links = Object.entries(publicLinks);
            
            if (links.length === 0) {
                container.innerHTML = `
                    <div class="no-links-message">
                        <h4>ÔøΩ No Public Links Found</h4>
                        <p>Create your first public link by clicking the üîó share button on any file or folder.</p>
                    </div>
                `;
                return;
            }

            let tableHtml = `
                <div class="selection-actions" id="selectionActions">
                    <span class="selected-count" id="selectedCount">0 links selected</span>
                    <div style="margin-left: auto; display: flex; gap: 10px;">
                        <button class="btn-small btn-delete-link" onclick="deleteSelectedLinks()">üóëÔ∏è Delete Selected</button>
                        <button class="btn-small btn-copy-small" onclick="exportSelectedLinks()">üì§ Export Selected</button>
                        <button class="btn-small" onclick="clearSelection()">‚ùå Clear Selection</button>
                    </div>
                </div>

                <table class="links-table">
                    <thead>
                        <tr>
                            <th class="checkbox-cell">
                                <input type="checkbox" id="selectAll" class="link-checkbox" onchange="toggleSelectAll()" title="Select All">
                            </th>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Status</th>
                            <th>Access Count</th>
                            <th>Expires</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            links.forEach(([linkId, link]) => {
                const isExpired = link.expiryTime && Date.now() > link.expiryTime;
                const status = isExpired ? 'expired' : 'active';
                const statusText = isExpired ? '‚è∞ Expired' : '‚úÖ Active';
                const expiry = link.expiryTime ? new Date(link.expiryTime).toLocaleDateString() : 'Never';
                const created = new Date(link.created).toLocaleDateString();
                const protection = link.password ? 'üîí' : '';
                
                // Generate the link URL
                let baseUrl = window.location.origin + window.location.pathname;
                if (!baseUrl.endsWith('.html')) {
                    if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
                    baseUrl += '/index.html';
                }
                const linkUrl = `${baseUrl}?share=${linkId}`;

                tableHtml += `
                    <tr class="link-row" data-link-id="${linkId}" onclick="showLinkStatistics('${linkId}', event)">
                        <td class="checkbox-cell">
                            <input type="checkbox" class="link-checkbox" value="${linkId}" onchange="updateSelection()" onclick="event.stopPropagation()">
                        </td>
                        <td>
                            <strong>${link.targetName}</strong> ${protection}
                            <div class="link-url">${linkUrl}</div>
                        </td>
                        <td>${link.type === 'file' ? 'üìÑ File' : 'üìÅ Folder'}</td>
                        <td><span class="link-status status-${status}">${statusText}</span></td>
                        <td>${link.accessCount}</td>
                        <td>${expiry}</td>
                        <td>${created}</td>
                        <td class="link-actions-cell" onclick="event.stopPropagation()">
                            <button class="btn-small btn-copy-small" onclick="copyLinkUrl('${linkUrl}')" title="Copy Link">üìã</button>
                            <button class="btn-small btn-edit" onclick="editPublicLink('${linkId}')" title="Edit">‚úèÔ∏è</button>
                            <button class="btn-small btn-delete-link" onclick="deletePublicLink('${linkId}')" title="Delete">üóëÔ∏è</button>
                        </td>
                    </tr>
                `;
            });

            tableHtml += `</tbody></table>
                <div class="statistics-panel" id="statisticsPanel">
                    <div class="stats-header">
                        <h4 id="statsTitle">Link Statistics</h4>
                        <button class="btn-small" onclick="hideStatistics()">‚ùå Close</button>
                    </div>
                    <div id="statisticsContent">
                        <!-- Statistics content will be populated here -->
                    </div>
                </div>
            `;
            container.innerHTML = tableHtml;
        }

        // Close links manager
        function closeLinksManager() {
            document.getElementById('linksManagerModal').style.display = 'none';
        }

        // Multi-selection functions
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAll');
            const linkCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll)');
            
            linkCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelection();
        }

        function updateSelection() {
            const linkCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll)');
            const selectedCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll):checked');
            const selectAllCheckbox = document.getElementById('selectAll');
            const selectionActions = document.getElementById('selectionActions');
            const selectedCount = document.getElementById('selectedCount');
            
            // Update select all checkbox state
            if (selectedCheckboxes.length === 0) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = false;
            } else if (selectedCheckboxes.length === linkCheckboxes.length) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = true;
            } else {
                selectAllCheckbox.indeterminate = true;
            }
            
            // Update row highlighting
            document.querySelectorAll('.link-row').forEach(row => {
                const checkbox = row.querySelector('.link-checkbox');
                if (checkbox && checkbox.checked) {
                    row.classList.add('selected');
                } else {
                    row.classList.remove('selected');
                }
            });
            
            // Show/hide selection actions
            if (selectedCheckboxes.length > 0) {
                selectionActions.classList.add('show');
                selectedCount.textContent = `${selectedCheckboxes.length} link${selectedCheckboxes.length === 1 ? '' : 's'} selected`;
            } else {
                selectionActions.classList.remove('show');
            }
        }

        function clearSelection() {
            document.querySelectorAll('.link-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateSelection();
        }

        function deleteSelectedLinks() {
            const selectedCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll):checked');
            const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                showAlert('üì≠ No links selected', 'info');
                return;
            }
            
            const linkNames = selectedIds.map(id => publicLinks[id]?.targetName).filter(Boolean);
            const confirmMessage = `Are you sure you want to delete ${selectedIds.length} selected link${selectedIds.length === 1 ? '' : 's'}?\n\n${linkNames.join('\n')}\n\nThis action cannot be undone.`;
            
            if (confirm(confirmMessage)) {
                selectedIds.forEach(linkId => {
                    delete publicLinks[linkId];
                });
                
                localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
                showAlert(`üóëÔ∏è ${selectedIds.length} link${selectedIds.length === 1 ? '' : 's'} deleted successfully`, 'success');
                
                // Refresh the manager
                populateLinksManager();
            }
        }

        function exportSelectedLinks() {
            const selectedCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll):checked');
            const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                showAlert('üì≠ No links selected', 'info');
                return;
            }
            
            const selectedLinks = selectedIds.map(id => publicLinks[id]).filter(Boolean);
            
            const exportData = {
                exportDate: new Date().toISOString(),
                totalLinks: selectedLinks.length,
                links: selectedLinks.map(link => ({
                    name: link.targetName,
                    type: link.type,
                    permissions: link.permissions,
                    hasPassword: !!link.password,
                    accessCount: link.accessCount,
                    created: link.created,
                    expires: link.expiryTime ? new Date(link.expiryTime).toISOString() : null,
                    lastAccessed: link.lastAccessed ? new Date(link.lastAccessed).toISOString() : null
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `selected-links-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert(`üì§ ${selectedLinks.length} selected link${selectedLinks.length === 1 ? '' : 's'} exported successfully`, 'success');
        }

        // Statistics functions
        function showLinkStatistics(linkId, event) {
            // Don't show statistics if clicking on checkbox or action buttons
            if (event.target.type === 'checkbox' || event.target.tagName === 'BUTTON') {
                return;
            }
            
            const link = publicLinks[linkId];
            if (!link) return;
            
            const statisticsPanel = document.getElementById('statisticsPanel');
            const statsTitle = document.getElementById('statsTitle');
            const statisticsContent = document.getElementById('statisticsContent');
            
            statsTitle.textContent = `Statistics: ${link.targetName}`;
            
            // Calculate statistics
            const now = Date.now();
            const isExpired = link.expiryTime && now > link.expiryTime;
            const daysSinceCreated = Math.floor((now - new Date(link.created).getTime()) / (1000 * 60 * 60 * 24));
            const daysUntilExpiry = link.expiryTime ? Math.floor((link.expiryTime - now) / (1000 * 60 * 60 * 24)) : null;
            
            // Generate link URL
            let baseUrl = window.location.origin + window.location.pathname;
            if (!baseUrl.endsWith('.html')) {
                if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
                baseUrl += '/index.html';
            }
            const linkUrl = `${baseUrl}?share=${linkId}`;
            
            const statsHtml = `
                <div class="stats-grid-detailed">
                    <div class="stat-card">
                        <h4>Total Access</h4>
                        <div class="value">${link.accessCount}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Link Age</h4>
                        <div class="value">${daysSinceCreated} day${daysSinceCreated === 1 ? '' : 's'}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Status</h4>
                        <div class="value" style="color: ${isExpired ? '#dc3545' : '#28a745'}">${isExpired ? 'Expired' : 'Active'}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Time to Expiry</h4>
                        <div class="value">${daysUntilExpiry !== null ? (daysUntilExpiry > 0 ? `${daysUntilExpiry} day${daysUntilExpiry === 1 ? '' : 's'}` : 'Expired') : 'Never'}</div>
                    </div>
                </div>
                
                <div class="link-details">
                    <div class="detail-row">
                        <span class="detail-label">Name:</span>
                        <span class="detail-value">${link.targetName}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Type:</span>
                        <span class="detail-value">${link.type === 'file' ? 'üìÑ File' : 'üìÅ Folder'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Permissions:</span>
                        <span class="detail-value">${link.permissions.toUpperCase()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Password Protected:</span>
                        <span class="detail-value">${link.password ? 'üîí Yes' : 'üîì No'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Created:</span>
                        <span class="detail-value">${new Date(link.created).toLocaleString()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Last Accessed:</span>
                        <span class="detail-value">${link.lastAccessed ? new Date(link.lastAccessed).toLocaleString() : 'Never'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Expires:</span>
                        <span class="detail-value">${link.expiryTime ? new Date(link.expiryTime).toLocaleString() : 'Never expires'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Link URL:</span>
                        <span class="detail-value" style="font-family: 'Courier New', monospace; font-size: 12px; word-break: break-all;">${linkUrl}</span>
                    </div>
                </div>
                
                <div style="margin-top: 15px; text-align: center;">
                    <button class="btn-copy" onclick="copyLinkUrl('${linkUrl}')">üìã Copy Link</button>
                    <button class="btn" onclick="editPublicLink('${linkId}')">‚úèÔ∏è Edit Link</button>
                </div>
            `;
            
            statisticsContent.innerHTML = statsHtml;
            statisticsPanel.classList.add('show');
            
            // Scroll to statistics panel
            statisticsPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function hideStatistics() {
            const statisticsPanel = document.getElementById('statisticsPanel');
            statisticsPanel.classList.remove('show');
        }

        // Copy link URL to clipboard
        async function copyLinkUrl(url) {
            try {
                await navigator.clipboard.writeText(url);
                showAlert('üìã Link copied to clipboard!', 'success');
            } catch (err) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = url;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showAlert('üìã Link copied to clipboard!', 'success');
            }
        }

        // Edit public link
        function editPublicLink(linkId) {
            const link = publicLinks[linkId];
            if (!link) return;

            // Close manager modal
            closeLinksManager();

            // Set up edit mode
            window.currentLinkData = {
                type: link.type,
                id: link.targetId,
                name: link.targetName,
                created: link.created,
                editMode: true,
                editLinkId: linkId
            };

            // Create or show public link modal
            if (!document.getElementById('publicLinkModal')) {
                createPublicLinkModal();
            }

            // Populate form with existing data
            document.getElementById('publicLinkModal').style.display = 'block';
            document.getElementById('linkItemName').textContent = link.targetName;
            document.getElementById('linkItemType').textContent = link.type === 'file' ? 'File' : 'Folder';
            
            // Set form values
            if (link.expiryTime) {
                const diffMs = link.expiryTime - Date.now();
                const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));
                const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
                
                if (diffHours <= 24) {
                    document.getElementById('linkExpiry').value = diffHours <= 1 ? '1h' : '24h';
                } else if (diffDays <= 7) {
                    document.getElementById('linkExpiry').value = '7d';
                } else {
                    document.getElementById('linkExpiry').value = '30d';
                }
            } else {
                document.getElementById('linkExpiry').value = 'never';
            }
            
            document.getElementById('linkPassword').value = link.password || '';
            document.getElementById('linkPermissions').value = link.permissions;
            
            // Show existing link if available
            let baseUrl = window.location.origin + window.location.pathname;
            if (!baseUrl.endsWith('.html')) {
                if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
                baseUrl += '/index.html';
            }
            const linkUrl = `${baseUrl}?share=${linkId}`;
            
            document.getElementById('generatedLink').value = linkUrl;
            document.getElementById('generatedLinkSection').style.display = 'block';
            updateLinkStats(link);
        }

        // Delete public link
        function deletePublicLink(linkId) {
            const link = publicLinks[linkId];
            if (!link) return;

            if (confirm(`Are you sure you want to delete the public link for "${link.targetName}"?\n\nThis action cannot be undone.`)) {
                delete publicLinks[linkId];
                localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
                showAlert('üóëÔ∏è Public link deleted successfully', 'success');
                
                // Refresh the manager
                populateLinksManager();
            }
        }

        // Delete all public links
        function deleteAllLinks() {
            const linkCount = Object.keys(publicLinks).length;
            if (linkCount === 0) {
                showAlert('üì≠ No links to delete', 'info');
                return;
            }

            if (confirm(`Are you sure you want to delete ALL ${linkCount} public links?\n\nThis action cannot be undone.`)) {
                publicLinks = {};
                localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
                showAlert(`üóëÔ∏è All ${linkCount} public links deleted`, 'success');
                
                // Refresh the manager
                populateLinksManager();
            }
        }

        // Export public links
        function exportPublicLinks() {
            const links = Object.values(publicLinks);
            if (links.length === 0) {
                showAlert('üì≠ No links to export', 'info');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                totalLinks: links.length,
                links: links.map(link => ({
                    name: link.targetName,
                    type: link.type,
                    permissions: link.permissions,
                    hasPassword: !!link.password,
                    accessCount: link.accessCount,
                    created: link.created,
                    expires: link.expiryTime ? new Date(link.expiryTime).toISOString() : null,
                    lastAccessed: link.lastAccessed ? new Date(link.lastAccessed).toISOString() : null
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `public-links-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert('üì§ Public links exported successfully', 'success');
        }

        // Clean up expired public links
        function cleanupExpiredLinks() {
            const currentTime = Date.now();
            let removedCount = 0;
            
            Object.keys(publicLinks).forEach(linkId => {
                const link = publicLinks[linkId];
                if (link.expiryTime && currentTime > link.expiryTime) {
                    delete publicLinks[linkId];
                    removedCount++;
                }
            });
            
            localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
            
            if (removedCount > 0) {
                showAlert(`üßπ Cleaned up ${removedCount} expired link(s)`, 'success');
            } else {
                showAlert('‚ú® No expired links found', 'info');
            }
        }

        // Load folders for dropdown
        async function loadFolders() {
            try {
                let foldersData = {};
                
                // Get folders data based on storage mode
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    try {
                        // Load folders directly from GitHub storage/folders directory
                        console.log('üìÅ Loading folders from GitHub...');
                        const foldersEndpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${GITHUB_CONFIG.DATA_PATH}folders`;
                        const folderFiles = await githubApiRequest(foldersEndpoint);
                        
                        if (Array.isArray(folderFiles)) {
                            for (const folderFile of folderFiles) {
                                if (folderFile.name.endsWith('.json') && folderFile.name !== '.gitkeep') {
                                    try {
                                        const folderContent = await getFileFromGitHub(folderFile.path);
                                        if (folderContent && folderContent.content) {
                                            // Handle both base64 and plain text content
                                            let jsonContent;
                                            try {
                                                // Try base64 decode first
                                                jsonContent = atob(folderContent.content);
                                            } catch (atobError) {
                                                // If base64 fails, content might already be plain text
                                                jsonContent = folderContent.content;
                                            }
                                            
                                            const folderData = JSON.parse(jsonContent);
                                            foldersData[folderData.name] = folderData;
                                            console.log(`üìÅ Loaded folder: ${folderData.name}`);
                                        }
                                    } catch (error) {
                                        console.warn(`Failed to load folder file ${folderFile.name}:`, error);
                                    }
                                }
                            }
                        }
                        
                        console.log(`üìÅ Loaded ${Object.keys(foldersData).length} folders from GitHub`);
                        
                        // Also check for folders from files (fallback method)
                        const githubFiles = await getGitHubFileList();
                        const folderSet = new Set();
                        githubFiles.forEach(file => {
                            if (file.folder && !folderSet.has(file.folder) && !foldersData[file.folder]) {
                                folderSet.add(file.folder);
                                foldersData[file.folder] = {
                                    id: file.folder,
                                    name: file.folder,
                                    createdAt: file.uploadDate || new Date().toISOString(),
                                    password: '' // GitHub mode doesn't use folder passwords yet
                                };
                            }
                        });
                    } catch (error) {
                        console.warn('Failed to load folders from GitHub:', error);
                        if (storageMode === 'github') {
                            throw error;
                        }
                    }
                }
                
                if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                    const localFoldersData = await getFoldersData();
                    
                    if (storageMode === 'hybrid') {
                        // Merge with GitHub folders
                        Object.keys(localFoldersData).forEach(folder => {
                            if (!foldersData[folder]) {
                                foldersData[folder] = localFoldersData[folder];
                            }
                        });
                    } else {
                        foldersData = localFoldersData;
                    }
                }
                
                const folders = Object.keys(foldersData);
                const select = document.getElementById('targetFolder');
                
                if (select) {
                    select.innerHTML = '<option value="">Pilih folder...</option>';
                    folders.forEach(folder => {
                        select.innerHTML += `<option value="${folder}">${folder}</option>`;
                    });
                }
                
                console.log(`üìÅ Total folders loaded: ${folders.length}`);
                return foldersData;
                
            } catch (error) {
                console.error('Error loading folders:', error);
                const select = document.getElementById('targetFolder');
                if (select) {
                    select.innerHTML = '<option value="">Error loading folders</option>';
                }
            }
        }

        // Create new folder
        async function createFolder() {
            const name = document.getElementById('folderName').value.trim();
            const password = document.getElementById('folderPassword').value;
            const parentFolder = document.getElementById('parentFolder').value;

            if (!name) {
                showAlert('Nama folder tidak boleh kosong', 'error');
                return;
            }

            if (!password) {
                showAlert('Sandi keamanan harus diisi', 'error');
                return;
            }

            const sanitizedName = name.replace(/[^a-zA-Z0-9\-_\s]/g, '').trim();
            if (!sanitizedName) {
                showAlert('Nama folder tidak valid', 'error');
                return;
            }

            // Create full folder path for subfolder
            const fullFolderPath = parentFolder ? `${parentFolder}/${sanitizedName}` : sanitizedName;

            try {
                // Check if folder already exists based on storage mode
                let folderExists = false;
                
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    const githubFolders = await getAllGitHubFolders();
                    folderExists = githubFolders.some(folder => folder.name === fullFolderPath);
                }
                
                if (!folderExists && (storageMode === 'indexeddb' || storageMode === 'hybrid')) {
                    const localFolders = await getFoldersData();
                    folderExists = !!localFolders[fullFolderPath];
                }
                
                if (folderExists) {
                    showAlert('Folder sudah ada', 'error');
                    return;
                }

                // Hash password
                const hashedPassword = await hashPassword(password);
                
                // Create folder data
                const folderData = {
                    id: fullFolderPath,
                    name: fullFolderPath,
                    displayName: sanitizedName,
                    parentFolder: parentFolder || '',
                    password: hashedPassword,
                    createdAt: new Date().toISOString()
                };
                
                // Save based on storage mode
                let saveSuccess = false;
                
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    try {
                        await saveGitHubFolder(folderData);
                        saveSuccess = true;
                        console.log('‚úÖ Folder saved to GitHub');
                    } catch (error) {
                        console.error('Failed to save to GitHub:', error);
                        if (storageMode === 'github') {
                            throw error;
                        }
                    }
                }
                
                if (!saveSuccess || storageMode === 'indexeddb' || storageMode === 'hybrid') {
                    await saveFolder(folderData);
                    console.log('‚úÖ Folder saved to IndexedDB');
                }
                
                await updateParentFolderDropdown();
                await loadFolders();
                await loadFileList();
                
                showAlert('‚úÖ Folder berhasil dibuat!', 'success');
                
                // Clear form
                document.getElementById('folderName').value = '';
                document.getElementById('folderPassword').value = '';
                document.getElementById('parentFolder').value = '';
                
            } catch (error) {
                console.error('Error creating folder:', error);
                showAlert('Error creating folder: ' + error.message, 'error');
            }
        }

        // Update parent folder dropdown
        async function updateParentFolderDropdown() {
            const parentFolderSelect = document.getElementById('parentFolder');
            
            // Clear current options except root
            parentFolderSelect.innerHTML = '<option value="">üìÅ Root (Folder Utama)</option>';
            
            try {
                let allFolders = [];
                
                // Get folders from GitHub
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    try {
                        const githubFolders = await getAllGitHubFolders();
                        allFolders = allFolders.concat(githubFolders);
                    } catch (error) {
                        console.warn('Failed to get GitHub folders:', error);
                    }
                }
                
                // Get folders from IndexedDB
                if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                    try {
                        const localFolders = await getFoldersData();
                        const localFolderArray = Object.values(localFolders);
                        allFolders = allFolders.concat(localFolderArray);
                    } catch (error) {
                        console.warn('Failed to get local folders:', error);
                    }
                }
                
                // Remove duplicates and sort
                const uniqueFolders = allFolders.filter((folder, index, self) => 
                    index === self.findIndex(f => f.name === folder.name)
                );
                
                uniqueFolders.sort((a, b) => a.name.localeCompare(b.name));
                
                // Add options
                uniqueFolders.forEach(folder => {
                    const option = document.createElement('option');
                    option.value = folder.name;
                    option.textContent = `üìÅ ${folder.displayName || folder.name}`;
                    parentFolderSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error updating parent folder dropdown:', error);
            }
        }

        // Upload files
        // Export all data
        async function exportAllData() {
            try {
                const exportData = {
                    version: "2.0",
                    exportDate: new Date().toISOString(),
                    dataIndex: dataIndex,
                    allFolders: await getFoldersData(),
                    allFiles: await getFilesData(),
                    dataFiles: allDataFiles.map(fileData => ({
                        info: fileData.info,
                        data: fileData.data
                    }))
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `file-container-complete-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                const sizeKB = (dataBlob.size / 1024).toFixed(1);
                showAlert(`‚úÖ Complete backup exported! Size: ${sizeKB} KB`, 'success');
                
            } catch (error) {
                showAlert('Error exporting data: ' + error.message, 'error');
            }
        }

        // Import data
        async function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (importedData.version === "2.0" && importedData.dataIndex) {
                        // Complete backup format
                        if (confirm('Import complete backup? This will replace all current data.')) {
                            dataIndex = importedData.dataIndex;
                            allDataFiles = importedData.dataFiles || [];
                            
                            await loadFolders();
                            await loadFileList();
                            await updateStorageInfo();
                            
                            showAlert(`‚úÖ Complete backup imported! ${importedData.allFiles?.length || 0} files restored.`, 'success');
                        }
                    } else if (importedData.folders && importedData.files) {
                        // Legacy format
                        if (confirm('Import legacy data? This will be merged with current data.')) {
                            const currentFolders = await getFoldersData();
                            const currentFiles = await getFilesData();
                            
                            const mergedFolders = { ...currentFolders, ...importedData.folders };
                            const mergedFiles = [...currentFiles, ...importedData.files];
                            
                            await saveData(mergedFolders, mergedFiles);
                            
                            showAlert('‚úÖ Legacy data imported and merged!', 'success');
                        }
                    } else {
                        showAlert('‚ùå Invalid file format!', 'error');
                    }
                } catch (error) {
                    showAlert('Error importing data: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // Confirm delete
        async function confirmDelete() {
            if (!deleteItem) return;

            const password = document.getElementById('deletePassword').value;
            if (!password) {
                showAlert('Masukkan sandi folder', 'error');
                return;
            }

            try {
                let foldersData = {};
                
                // Get folders data based on storage mode
                if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                    foldersData = await getFoldersData();
                } else if (storageMode === 'github') {
                    // For GitHub mode, get folders from GitHub
                    const githubFolders = await getAllGitHubFolders();
                    githubFolders.forEach(folder => {
                        foldersData[folder.name] = folder;
                    });
                }
                
                const hashedPassword = await hashPassword(password);

                if (deleteItem.type === 'folder') {
                    // Delete folder
                    let folderExists = false;
                    let passwordValid = false;
                    
                    // Check if folder exists and verify password
                    if (foldersData[deleteItem.name]) {
                        folderExists = true;
                        passwordValid = hashedPassword === foldersData[deleteItem.name].password;
                    }
                    
                    if (!folderExists) {
                        showAlert('Folder tidak ditemukan', 'error');
                        return;
                    }
                    
                    if (!passwordValid) {
                        showAlert('Sandi salah', 'error');
                        return;
                    }
                    
                    // Delete based on storage mode
                    if (storageMode === 'github' || storageMode === 'hybrid') {
                        try {
                            // Delete from GitHub
                            await deleteGitHubFolder(deleteItem.name);
                            console.log('‚úÖ Folder deleted from GitHub');
                        } catch (error) {
                            console.error('Failed to delete from GitHub:', error);
                            if (storageMode === 'github') {
                                throw error;
                            }
                        }
                    }
                    
                    if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                        // Delete from IndexedDB
                        await deleteFolderDB(deleteItem.name);
                        console.log('‚úÖ Folder deleted from IndexedDB');
                    }
                    
                    showAlert(`‚úÖ Folder "${deleteItem.name}" berhasil dihapus!`, 'success');
                    await loadFolders();
                    await loadFileList();
                    
                } else if (deleteItem.type === 'file') {
                    // Delete file
                    let folderExists = false;
                    let passwordValid = false;
                    
                    if (foldersData[deleteItem.folder]) {
                        folderExists = true;
                        passwordValid = hashedPassword === foldersData[deleteItem.folder].password;
                    }
                    
                    if (!folderExists) {
                        showAlert('Folder tidak ditemukan', 'error');
                        return;
                    }
                    
                    if (!passwordValid) {
                        showAlert('Sandi salah', 'error');
                        return;
                    }
                    
                    // Delete based on storage mode
                    if (storageMode === 'github' || storageMode === 'hybrid') {
                        try {
                            // Find and delete from GitHub
                            const githubFiles = await getGitHubFileList();
                            const targetFile = githubFiles.find(f => f.id === deleteItem.fileId);
                            
                            if (targetFile) {
                                await deleteFileInfoFromGitHub(targetFile);
                                console.log('‚úÖ File deleted from GitHub');
                            }
                        } catch (error) {
                            console.error('Failed to delete from GitHub:', error);
                            if (storageMode === 'github') {
                                throw error;
                            }
                        }
                    }
                    
                    if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                        // Delete from IndexedDB
                        await deleteFileDB(deleteItem.fileId);
                        console.log('‚úÖ File deleted from IndexedDB');
                    }
                    
                    showAlert(`‚úÖ File "${deleteItem.name}" berhasil dihapus!`, 'success');
                }
                
                closeDeleteModal();
                loadFileList();
                
            } catch (error) {
                showAlert('Error deleting: ' + error.message, 'error');
            }
        }

        // Drag and drop functionality
        function setupDragAndDrop() {
            const fileSelectionArea = document.getElementById('fileSelectionArea');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                fileSelectionArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                fileSelectionArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                fileSelectionArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                fileSelectionArea.classList.add('dragover');
            }

            function unhighlight() {
                fileSelectionArea.classList.remove('dragover');
            }

            fileSelectionArea.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                selectedFiles = Array.from(dt.files);
                updateFileSelectionPreview();
            }
        }

        // File input change handler
        document.getElementById('fileInput').addEventListener('change', function(event) {
            selectedFiles = Array.from(event.target.files);
            updateFileSelectionPreview();
        });
        
        document.getElementById('targetFolder').addEventListener('change', updateUploadButton);

        function updateUploadButton() {
            const folder = document.getElementById('targetFolder').value;
            const uploadBtn = document.getElementById('uploadBtn');
            
            uploadBtn.disabled = selectedFiles.length === 0 || !folder;
            
            if (selectedFiles.length > 0 && !folder) {
                showAlert('Silakan pilih folder tujuan untuk upload file', 'error');
            }
        }

        // Upload files
        async function uploadFiles() {
            const files = document.getElementById('fileInput').files;
            const targetFolder = document.getElementById('targetFolder').value;

            if (files.length === 0 || !targetFolder) {
                showAlert('Pilih file dan folder tujuan', 'error');
                return;
            }

            // Create upload operation
            const uploadId = createOperation(`Uploading ${files.length} file${files.length !== 1 ? 's' : ''}`, 'upload');

            try {
                updateOperation(uploadId, 5, 'Preparing upload...');
                console.log(`üì§ Starting upload of ${files.length} files to storage mode: ${storageMode}`);
                
                // Clear allDataFiles to prevent duplicates
                console.log('üßπ Clearing allDataFiles to prevent duplicates');
                allDataFiles.length = 0;
                allDataFiles.push({
                    filename: `fileData_${Date.now()}.json`,
                    data: { files: [] }
                });
                
                updateOperation(uploadId, 10, 'Processing files...');
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const fileProgress = 10 + (i / files.length) * 60; // 10-70% for file processing
                    
                    updateOperation(uploadId, fileProgress, `Processing ${file.name} (${i+1}/${files.length})`);
                    console.log(`üìÅ Processing file ${i+1}/${files.length}: ${file.name} (${formatFileSize(file.size)})`);
                    
                    // Support large files with chunking system (up to 2GB recommended)
                    if (file.size > 2 * 1024 * 1024 * 1024) {
                        showAlert(`File "${file.name}" terlalu besar (>2GB). Silakan gunakan file yang lebih kecil untuk performa optimal.`, 'warning');
                        continue;
                    }
                    
                    // Show progress for larger files (>50MB with 20MB chunks)
                    if (file.size > 50 * 1024 * 1024) {
                        updateOperation(uploadId, fileProgress, `Converting large file ${file.name}...`);
                    }
                    
                    console.log(`‚è≥ Converting file to base64: ${file.name}`);
                    const base64Data = await fileToBase64WithProgress(file, file.name);
                    console.log(`‚úÖ Base64 conversion complete for: ${file.name}`);
                    
                    const fileInfo = {
                        id: Date.now() + Math.random().toString(36).substr(2, 9),
                        name: file.name,
                        folder: targetFolder,
                        size: file.size,
                        mimetype: file.type,
                        uploadDate: new Date().toISOString(),
                        data: base64Data
                    };
                    
                    console.log(`üìÅ Adding file to allDataFiles: ${file.name} (${formatFileSize(file.size)})`);
                    
                    // Find the appropriate data file or create new one
                    let targetDataFile = allDataFiles.find(df => df.data.files.length === 0) || allDataFiles[0];
                    if (!targetDataFile) {
                        targetDataFile = {
                            filename: `fileData_${Date.now()}.json`,
                            data: { files: [] }
                        };
                        allDataFiles.push(targetDataFile);
                    }
                    
                    // Add file to the data structure
                    targetDataFile.data.files.push(fileInfo);
                    console.log(`‚úÖ File added to allDataFiles: ${file.name}`);
                }
                
                // Save all files to storage after processing all files
                updateOperation(uploadId, 75, 'Saving to storage...');
                console.log(`üíæ Saving all files to storage mode: ${storageMode}`);
                const saveSuccess = await saveFilesData(allDataFiles);
                
                if (!saveSuccess) {
                    throw new Error('Failed to save files to storage');
                }
                
                updateOperation(uploadId, 90, 'Refreshing file list...');
                
                const modeText = storageMode === 'github' ? 'GitHub repository' : 
                                storageMode === 'hybrid' ? 'GitHub (with local fallback)' : 
                                'local storage';
                
                console.log(`‚úÖ Upload complete! ${files.length} files saved to ${modeText}`);
                
                // Clear selection and refresh
                document.getElementById('fileInput').value = '';
                updateUploadButton();
                
                console.log(`üîÑ Refreshing file list...`);
                await loadFileList();
                await updateStorageInfo();
                console.log(`‚úÖ File list refreshed`);
                
                updateOperation(uploadId, 100, 'Upload completed');
                completeOperation(uploadId, `‚úÖ ${files.length} files uploaded`);
                showAlert(`‚úÖ ${files.length} file berhasil disimpan ke ${modeText}!`, 'success');
                
            } catch (error) {
                console.error('Upload error details:', error);
                completeOperation(uploadId, '‚ùå Upload failed');
                showAlert('Error uploading files: ' + error.message, 'error');
            }
        }

        // Load file list with optimization and pagination
        async function loadFileList(page = null, forceRefresh = false) {
            try {
                const loadingStatus = document.getElementById('loadingStatus');
                const cacheInfo = document.getElementById('cacheInfo');
                const paginationContainer = document.getElementById('paginationContainer');
                
                // Show loading status
                loadingStatus.style.display = 'block';
                cacheInfo.textContent = forceRefresh ? 'Force refreshing...' : 'Loading...';
                
                console.log(`üìã Loading optimized file list for storage mode: ${storageMode}`);
                let foldersData = {};
                let filesData = [];
                
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    // Load from GitHub repository with optimization
                    try {
                        console.log(`üîç Loading files from GitHub with optimization...`);
                        const pageToLoad = page || currentPage;
                        const result = await getOptimizedFileList(pageToLoad, FILES_PER_PAGE, forceRefresh);
                        
                        filesData = result.files;
                        totalFiles = result.totalFiles;
                        currentPage = result.currentPage;
                        
                        // Update cache info
                        cacheInfo.textContent = result.fromCache ? 
                            `üìã From cache (${result.totalFiles} files)` : 
                            `üîÑ Fresh data (${result.totalFiles} files)`;
                        
                        console.log(`üìÅ Loaded ${filesData.length} files from GitHub (page ${currentPage})`);
                        
                        // Build folders data from all cached files
                        const folderSet = new Set();
                        Array.from(allFilesCache.values()).forEach(file => {
                            if (file.folder && !folderSet.has(file.folder)) {
                                folderSet.add(file.folder);
                                foldersData[file.folder] = {
                                    createdAt: file.uploadDate || new Date().toISOString()
                                };
                            }
                        });
                        
                        // Update pagination UI
                        updatePaginationUI(result);
                        
                    } catch (error) {
                        console.warn('Failed to load from GitHub:', error);
                        if (storageMode === 'github') {
                            throw error;
                        }
                    }
                }
                
                if (storageMode === 'indexeddb' || storageMode === 'hybrid') {
                    // Load from IndexedDB (for hybrid mode, this is just for completeness)
                    console.log(`üîç Loading files from IndexedDB...`);
                    const localFoldersData = await getFoldersData();
                    const localFilesData = await getFilesData();
                    console.log(`üìÅ Loaded ${localFilesData.length} files from IndexedDB`);
                    
                    if (storageMode === 'hybrid') {
                        // Merge with GitHub data
                        console.log(`üîÑ Merging GitHub and IndexedDB data...`);
                        Object.keys(localFoldersData).forEach(folder => {
                            if (!foldersData[folder]) {
                                foldersData[folder] = localFoldersData[folder];
                            }
                        });
                        
                        // For hybrid mode, we prioritize GitHub data but show IndexedDB as fallback
                        if (filesData.length === 0) {
                            // Only use IndexedDB files if GitHub failed
                            filesData = localFilesData.slice(0, FILES_PER_PAGE);
                            totalFiles = localFilesData.length;
                        }
                    } else {
                        // IndexedDB only - implement simple pagination
                        foldersData = localFoldersData;
                        const pageToLoad = page || currentPage;
                        const startIndex = (pageToLoad - 1) * FILES_PER_PAGE;
                        const endIndex = startIndex + FILES_PER_PAGE;
                        
                        filesData = localFilesData.slice(startIndex, endIndex);
                        totalFiles = localFilesData.length;
                        currentPage = pageToLoad;
                        
                        // Update pagination for IndexedDB
                        updatePaginationUI({
                            totalFiles: localFilesData.length,
                            totalPages: Math.ceil(localFilesData.length / FILES_PER_PAGE),
                            currentPage: pageToLoad,
                            fromCache: false
                        });
                    }
                }
                
                // Hide loading status
                loadingStatus.style.display = 'none';
                
                // Render the file list with current data
                await renderFileListOptimized(foldersData, filesData);
                
                // Show pagination if we have files
                if (totalFiles > FILES_PER_PAGE) {
                    paginationContainer.style.display = 'block';
                } else {
                    paginationContainer.style.display = 'none';
                }
                
                console.log(`‚úÖ File list loaded successfully (${filesData.length} files shown)`);
            } catch (error) {
                console.error('‚ùå Error loading file list:', error);
                document.getElementById('loadingStatus').style.display = 'none';
                showAlert('Error loading files: ' + error.message, 'error');
            }
        }

        // Optimized rendering function for file list
        async function renderFileListOptimized(foldersData, filesData) {
            try {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                // Update breadcrumb
                updateBreadcrumb();

                // Show folders (only at root level)
                let folders = [];
                if (!currentFolder) {
                    folders = Object.keys(foldersData);
                }

                // Show folders
                folders.forEach(folder => {
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'folder-item';
                    
                    if (currentViewMode === 'grid') {
                        folderDiv.innerHTML = `
                            <div class="file-icon">üìÅ</div>
                            <div class="file-name">${folder}</div>
                            <div class="file-info">Folder</div>
                            <div class="file-actions" style="margin-top: 10px;">
                                <button class="btn" onclick="loadFolder('${folder}')" style="margin: 2px; font-size: 11px;">üìÇ</button>
                                <button class="btn-share" onclick="createPublicLink('folder', '${currentFolder ? currentFolder + '/' + folder : folder}', '${folder}')" style="margin: 2px; font-size: 11px;">üîó</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('folder', '${folder}')" style="margin: 2px; font-size: 11px;">üóëÔ∏è</button>
                            </div>
                        `;
                    } else {
                        folderDiv.innerHTML = `
                            <div class="file-icon">üìÅ</div>
                            <div class="file-details">
                                <div class="file-name">${folder}</div>
                                <div class="file-info">
                                    Dibuat: ${new Date(foldersData[folder].createdAt).toLocaleString('id-ID')}
                                </div>
                            </div>
                            <div class="file-actions">
                                <button class="btn" onclick="loadFolder('${folder}')">üìÇ Buka</button>
                                <button class="btn-share" onclick="createPublicLink('folder', '${currentFolder ? currentFolder + '/' + folder : folder}', '${folder}')">üîó Share</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('folder', '${folder}')">üóëÔ∏è Hapus</button>
                            </div>
                        `;
                    }
                    fileList.appendChild(folderDiv);
                });

                // Show files in current folder
                const folderFiles = filesData.filter(file => file.folder === currentFolder);
                
                // Process files with lazy-loaded media preview
                for (const file of folderFiles) {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file-item';
                    
                    // For optimized loading, don't load media previews by default
                    let mediaPreview = '';
                    if (isImageFile(file.name, file.mimetype) || isVideoFile(file.name, file.mimetype)) {
                        // Show a placeholder that can be loaded on demand
                        mediaPreview = `
                            <div class="media-preview-placeholder" onclick="loadMediaPreview('${file.id}', this)">
                                <div class="preview-icon">${isImageFile(file.name, file.mimetype) ? 'üñºÔ∏è' : 'üé•'}</div>
                                <div class="preview-text">Click to load preview</div>
                            </div>
                        `;
                    }
                    
                    const chunkInfo = file.isChunked ? `<br>üì¶ Chunked: ${file.totalChunks} parts` : '';
                    
                    if (currentViewMode === 'grid') {
                        fileDiv.innerHTML = `
                            <div class="file-icon">${getFileIcon(file.name)}</div>
                            <div class="file-name">${file.name}</div>
                            ${mediaPreview}
                            <div class="file-info">${formatFileSize(file.totalSize || file.size)}</div>
                            <div class="file-actions" style="margin-top: 10px;">
                                <button class="btn" onclick="downloadFile('${file.id}')" style="margin: 2px; font-size: 11px;">üì•</button>
                                <button class="btn-share" onclick="createPublicLink('file', '${file.id}', '${file.name}')" style="margin: 2px; font-size: 11px;">üîó</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('file', '${file.name}', '${file.folder}', '${file.id}')" style="margin: 2px; font-size: 11px;">üóëÔ∏è</button>
                            </div>
                        `;
                    } else {
                        fileDiv.innerHTML = `
                            <div class="file-icon">${getFileIcon(file.name)}</div>
                            <div class="file-details">
                                <div class="file-name">${file.name}</div>
                                ${mediaPreview}
                                <div class="file-info">
                                    Ukuran: ${formatFileSize(file.totalSize || file.size)}<br>
                                    Upload: ${new Date(file.uploadDate).toLocaleString('id-ID')}<br>
                                    Type: ${file.mimetype || 'Unknown'}${chunkInfo}
                                </div>
                            </div>
                            <div class="file-actions">
                                <button class="btn" onclick="downloadFile('${file.id}')">üì• Download</button>
                                <button class="btn-share" onclick="createPublicLink('file', '${file.id}', '${file.name}')">üîó Share</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('file', '${file.name}', '${file.folder}', '${file.id}')">üóëÔ∏è Hapus</button>
                            </div>
                        `;
                    }
                    fileList.appendChild(fileDiv);
                }

                console.log(`üìã File list display completed: ${folders.length} folders, ${folderFiles.length} files shown`);
                
                if (folders.length === 0 && folderFiles.length === 0) {
                    fileList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Tidak ada file atau folder</p>';
                }
            } catch (error) {
                console.error('‚ùå Error rendering file list:', error);
                showAlert('Error displaying files: ' + error.message, 'error');
            }
        }

        // Load specific folder
        async function loadFolder(folderName) {
            // Add to navigation history (only if not going back)
            if (currentHistoryIndex === -1 || navigationHistory[currentHistoryIndex] !== folderName) {
                // Remove any forward history if we're navigating to a new folder
                if (currentHistoryIndex < navigationHistory.length - 1) {
                    navigationHistory = navigationHistory.slice(0, currentHistoryIndex + 1);
                }
                navigationHistory.push(folderName);
                currentHistoryIndex = navigationHistory.length - 1;
            }
            
            currentFolder = folderName;
            await loadFileList();
            updateBackButton();
        }

        // Go back to previous folder
        function goBack() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const previousFolder = navigationHistory[currentHistoryIndex];
                currentFolder = previousFolder;
                loadFileList();
                updateBackButton();
            }
        }

        // Update back button visibility and state
        function updateBackButton() {
            const backButton = document.getElementById('backButton');
            const upLevelBtn = document.getElementById('upLevelBtn');
            
            // Handle back button (history-based)
            if (currentHistoryIndex > 0) {
                backButton.style.display = 'inline-flex';
                backButton.disabled = false;
            } else {
                backButton.style.display = 'none';
                backButton.disabled = true;
            }
            
            // Handle up level button (folder hierarchy-based)
            if (currentFolder && currentFolder.includes('/')) {
                // If we're in a subfolder, show up level button
                upLevelBtn.style.display = 'inline-flex';
                upLevelBtn.disabled = false;
            } else if (currentFolder && !currentFolder.includes('/')) {
                // If we're in root level folder, show up to home
                upLevelBtn.style.display = 'inline-flex';
                upLevelBtn.disabled = false;
            } else {
                // If we're at home, hide up level button
                upLevelBtn.style.display = 'none';
                upLevelBtn.disabled = true;
            }
        }

        // Go up one level in folder hierarchy
        function goUpOneLevel() {
            if (!currentFolder) return; // Already at root
            
            if (currentFolder.includes('/')) {
                // Go up one level in subfolder hierarchy
                const parentPath = currentFolder.substring(0, currentFolder.lastIndexOf('/'));
                loadFolder(parentPath);
            } else {
                // Go to root from top-level folder
                loadFolder('');
            }
        }

        // Update breadcrumb
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            let html = '<a href="#" onclick="loadFolder(\'\')">üè† Home</a>';
            
            if (currentFolder) {
                html += ` / <span>${currentFolder}</span>`;
            }
            
            breadcrumb.innerHTML = html;
            updateBackButton();
        }

        // ============================================================================
        // PAGINATION AND OPTIMIZATION FUNCTIONS
        // ============================================================================

        // Update pagination UI elements
        function updatePaginationUI(result) {
            const fileCount = document.getElementById('fileCount');
            const cacheStatus = document.getElementById('cacheStatus');
            const paginationNumbers = document.getElementById('paginationNumbers');
            const prevPage = document.getElementById('prevPage');
            const nextPage = document.getElementById('nextPage');
            
            // Update file count and cache status
            const start = (result.currentPage - 1) * FILES_PER_PAGE + 1;
            const end = Math.min(result.currentPage * FILES_PER_PAGE, result.totalFiles);
            fileCount.textContent = `Showing ${start}-${end} of ${result.totalFiles} files`;
            
            if (result.fromCache) {
                cacheStatus.textContent = 'üìã Cached';
                cacheStatus.className = 'cache-status cached';
            } else {
                cacheStatus.textContent = 'üîÑ Fresh';
                cacheStatus.className = 'cache-status';
            }
            
            // Update pagination numbers
            const totalPages = result.totalPages;
            let numbersHtml = '';
            
            // Show page numbers (max 7 pages visible)
            let startPage = Math.max(1, result.currentPage - 3);
            let endPage = Math.min(totalPages, startPage + 6);
            
            if (endPage - startPage < 6) {
                startPage = Math.max(1, endPage - 6);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const activeClass = i === result.currentPage ? ' active' : '';
                numbersHtml += `<span class="page-number${activeClass}" onclick="changePage(${i})">${i}</span>`;
            }
            
            paginationNumbers.innerHTML = numbersHtml;
            
            // Update prev/next buttons
            prevPage.disabled = result.currentPage <= 1;
            nextPage.disabled = result.currentPage >= totalPages;
        }

        // Change page
        async function changePage(page) {
            if (page < 1 || page > Math.ceil(totalFiles / FILES_PER_PAGE)) return;
            currentPage = page;
            await loadFileList(page);
        }

        // Change items per page
        async function changeItemsPerPage(newLimit) {
            FILES_PER_PAGE = parseInt(newLimit);
            currentPage = 1; // Reset to first page
            await loadFileList(1, true); // Force refresh
        }

        // Refresh file list
        async function refreshFileList(forceRefresh = false) {
            await loadFileList(currentPage, forceRefresh);
        }

        // Lazy load media preview
        async function loadMediaPreview(fileId, placeholderElement) {
            try {
                // Show loading state
                placeholderElement.innerHTML = `
                    <div class="preview-icon">‚è≥</div>
                    <div class="preview-text">Loading preview...</div>
                `;
                
                // Find file in cache first
                let file = getCachedFile(fileId);
                if (!file) {
                    // If not in cache, try to find in current page data
                    const allFiles = Array.from(allFilesCache.values());
                    file = allFiles.find(f => f.id === fileId);
                }
                
                if (!file) {
                    throw new Error('File not found');
                }
                
                let fileWithContent = null;
                
                // Load file content
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    try {
                        fileWithContent = await getFileFromGitHubChunks(file);
                    } catch (error) {
                        if (storageMode === 'hybrid') {
                            fileWithContent = await getFileWithChunks(file.id);
                        } else {
                            throw error;
                        }
                    }
                } else {
                    fileWithContent = await getFileWithChunks(file.id);
                }
                
                if (fileWithContent) {
                    let mediaPreview = '';
                    if (isImageFile(file.name, file.mimetype)) {
                        mediaPreview = createImagePreview(fileWithContent);
                    } else if (isVideoFile(file.name, file.mimetype)) {
                        mediaPreview = createVideoPreview(fileWithContent);
                    }
                    
                    // Replace placeholder with actual preview
                    placeholderElement.outerHTML = mediaPreview;
                } else {
                    throw new Error('Could not load file content');
                }
                
            } catch (error) {
                console.warn(`Failed to load preview for ${fileId}:`, error);
                placeholderElement.innerHTML = `
                    <div class="preview-icon">‚ùå</div>
                    <div class="preview-text">Preview failed</div>
                `;
            }
        }

        // Download file
        async function downloadFile(fileId) {
            // Create download operation
            const downloadId = createOperation('Downloading file', 'download');
            
            try {
                updateOperation(downloadId, 10, 'Locating file...');
                let fileWithContent = null;
                
                // Try to get file from appropriate storage based on mode
                if (storageMode === 'github' || storageMode === 'hybrid') {
                    try {
                        updateOperation(downloadId, 25, 'Searching GitHub repository...');
                        
                        // Find file info first
                        const allFiles = await getGitHubFileList();
                        const fileInfo = allFiles.find(f => f.id === fileId);
                        
                        if (fileInfo) {
                            updateOperation(downloadId, 50, `Reconstructing ${fileInfo.name}...`);
                            fileWithContent = await getFileFromGitHubChunks(fileInfo);
                        }
                    } catch (error) {
                        console.warn('Failed to download from GitHub:', error);
                        if (storageMode === 'hybrid') {
                            updateOperation(downloadId, 50, 'Falling back to local storage...');
                            // Fallback to IndexedDB
                            fileWithContent = await getFileWithChunks(fileId);
                        } else {
                            throw error;
                        }
                    }
                } else {
                    updateOperation(downloadId, 50, 'Retrieving from local storage...');
                    // IndexedDB only
                    fileWithContent = await getFileWithChunks(fileId);
                }
                
                if (!fileWithContent) {
                    completeOperation(downloadId, '‚ùå File not found');
                    showAlert('File tidak ditemukan', 'error');
                    return;
                }
                
                updateOperation(downloadId, 80, `Preparing download for ${fileWithContent.name}...`);
                console.log(`üì• Downloading ${fileWithContent.name} (${formatFileSize(fileWithContent.totalSize || fileWithContent.size)})`);
                downloadBase64File(fileWithContent.content, fileWithContent.name);
                
                const storageText = storageMode === 'github' ? 'GitHub repository' : 
                                  storageMode === 'hybrid' ? 'hybrid storage' : 
                                  'local storage';
                
                updateOperation(downloadId, 100, 'Download completed');
                completeOperation(downloadId, `‚úÖ Downloaded ${fileWithContent.name}`);
                showAlert(`‚úÖ File "${fileWithContent.name}" berhasil didownload dari ${storageText}!`, 'success');
            } catch (error) {
                console.error('Download error:', error);
                completeOperation(downloadId, '‚ùå Download failed');
                showAlert('Error downloading file: ' + error.message, 'error');
            }
        }

        // Show delete modal
        function showDeleteModal(type, name, folder = '', fileId = '') {
            deleteItem = { type, name, folder, fileId };
            document.getElementById('deleteMessage').textContent = 
                `Apakah Anda yakin ingin menghapus ${type === 'folder' ? 'folder' : 'file'} "${name}"?`;
            document.getElementById('deleteModal').style.display = 'block';
        }

        // Close delete modal
        function closeDeleteModal() {
            document.getElementById('deleteModal').style.display = 'none';
            document.getElementById('deletePassword').value = '';
            deleteItem = null;
        }

        // Utility functions
        function showAlert(message, type = 'info', duration = 5000) {
            const toastContainer = document.getElementById('toastContainer');
            
            // Limit number of toasts (max 5)
            const existingToasts = toastContainer.querySelectorAll('.toast');
            if (existingToasts.length >= 5) {
                // Remove oldest toast
                const oldestToast = existingToasts[0];
                hideToast(oldestToast);
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            // Add message container
            const messageDiv = document.createElement('div');
            messageDiv.className = 'toast-message';
            messageDiv.textContent = message;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '√ó';
            closeBtn.onclick = () => hideToast(toast);
            closeBtn.setAttribute('aria-label', 'Close notification');
            
            // Add progress bar (only if duration > 0)
            let progressBar = null;
            if (duration > 0) {
                progressBar = document.createElement('div');
                progressBar.className = 'toast-progress';
                progressBar.style.animationDuration = `${duration}ms`;
            }
            
            // Assemble toast
            toast.appendChild(messageDiv);
            toast.appendChild(closeBtn);
            if (progressBar) {
                toast.appendChild(progressBar);
            }
            
            // Add to container
            toastContainer.appendChild(toast);
            
            // Show animation
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });
            });
            
            // Auto hide (if duration > 0)
            let hideTimer = null;
            if (duration > 0) {
                hideTimer = setTimeout(() => {
                    hideToast(toast);
                }, duration);
            }
            
            // Store timer for manual close
            toast._hideTimer = hideTimer;
            
            return toast;
        }
        
        function hideToast(toast) {
            if (!toast || !toast.parentNode) return;
            
            if (toast._hideTimer) {
                clearTimeout(toast._hideTimer);
                toast._hideTimer = null;
            }
            
            toast.classList.remove('show');
            toast.classList.add('hide');
            
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 400);
        }
        
        // Clear all toasts
        function clearAllToasts() {
            const toastContainer = document.getElementById('toastContainer');
            const toasts = toastContainer.querySelectorAll('.toast');
            toasts.forEach(toast => hideToast(toast));
        }
        
        // Test notification system
        function testNotifications() {
            // Clear existing toasts first
            clearAllToasts();
            
            // Show demo notifications with delays
            setTimeout(() => showAlert('Data berhasil disimpan ke GitHub repository!', 'success'), 200);
            setTimeout(() => showAlert('Sedang memvalidasi koneksi ke server...', 'info', 3000), 800);
            setTimeout(() => showAlert('Token GitHub akan kedaluwarsa dalam 7 hari', 'warning'), 1400);
            setTimeout(() => showAlert('Gagal terhubung ke server backup', 'error'), 2000);
            setTimeout(() => showAlert('Folder "Documents" berhasil dibuat dengan 25 file', 'success', 4000), 2600);
        }
        
        // Test large file upload functionality
        function testLargeFileSupport() {
            // Clear existing toasts
            clearAllToasts();
            
            // Show demo of large file support
            setTimeout(() => showAlert('Sistem mendukung file hingga 2GB', 'info'), 200);
            setTimeout(() => showAlert('File besar akan dipecah menjadi chunk 20MB', 'info'), 800);
            setTimeout(() => showAlert('Progress bar akan tampil untuk file >50MB', 'info'), 1400);
            setTimeout(() => showAlert('File berhasil diupload dengan chunking system', 'success'), 2000);
        }
        
        // Legacy function for compatibility
        function showAlertLegacy(message, type) {
            const alertArea = document.getElementById('alertArea');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            alertArea.innerHTML = '';
            alertArea.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Media preview functions
        function isImageFile(filename, mimetype) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
            const imageMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/svg+xml'];
            
            const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return imageExtensions.includes(extension) || (mimetype && imageMimeTypes.includes(mimetype.toLowerCase()));
        }

        function isVideoFile(filename, mimetype) {
            const videoExtensions = ['.mp4', '.webm', '.ogg', '.avi', '.mov', '.wmv', '.flv', '.mkv'];
            const videoMimeTypes = ['video/mp4', 'video/webm', 'video/ogg', 'video/avi', 'video/quicktime', 'video/x-msvideo'];
            
            const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return videoExtensions.includes(extension) || (mimetype && videoMimeTypes.includes(mimetype.toLowerCase()));
        }

        function createImagePreview(file) {
            // Clean base64 data (remove data URL prefix if present)
            let cleanBase64 = file.content;
            if (file.content && file.content.includes(',')) {
                cleanBase64 = file.content.split(',')[1];
            }
            
            return `
                <div class="media-preview">
                    <img src="data:${file.mimetype || 'image/jpeg'};base64,${cleanBase64}" 
                         alt="${file.name}" 
                         style="max-width: 200px; max-height: 150px; border-radius: 8px; cursor: pointer; object-fit: cover;"
                         onclick="showFullImage('${file.id}', '${file.name}', '${file.mimetype}', '${cleanBase64}')"
                         onerror="this.parentElement.innerHTML='<div class=\\'preview-icon\\'>üñºÔ∏è</div><div class=\\'preview-text\\'>Image preview failed</div>'" />
                </div>
            `;
        }

        function createVideoPreview(file) {
            // Clean base64 data (remove data URL prefix if present)
            let cleanBase64 = file.content;
            if (file.content && file.content.includes(',')) {
                cleanBase64 = file.content.split(',')[1];
            }
            
            return `
                <div class="media-preview">
                    <video controls style="max-width: 200px; max-height: 150px; border-radius: 8px;">
                        <source src="data:${file.mimetype || 'video/mp4'};base64,${cleanBase64}" type="${file.mimetype || 'video/mp4'}">
                        Your browser does not support the video tag.
                    </video>
                </div>
            `;
        }

        function showFullImage(fileId, fileName, mimetype, content) {
            try {
                // Create modal for full image view
                const modal = document.createElement('div');
                modal.className = 'image-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    cursor: pointer;
                `;
                
                modal.innerHTML = `
                    <div style="max-width: 90%; max-height: 90%; text-align: center;">
                        <img src="data:${mimetype || 'image/jpeg'};base64,${content}" 
                             style="max-width: 100%; max-height: 100%; border-radius: 8px;" 
                             alt="${fileName}"
                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkVycm9yIGxvYWRpbmcgaW1hZ2U8L3RleHQ+PC9zdmc+'" />
                        <div style="color: white; margin-top: 10px; font-size: 16px;">${fileName}</div>
                        <div style="color: #ccc; margin-top: 5px; font-size: 12px;">Click anywhere to close</div>
                    </div>
                `;
                
                modal.onclick = function() {
                    document.body.removeChild(modal);
                };
                
                document.body.appendChild(modal);
            } catch (error) {
                console.error('Error showing full image:', error);
                showAlert('Error displaying image: ' + error.message, 'error');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('deleteModal');
            if (event.target === modal) {
                closeDeleteModal();
            }
        }

        // Add public link modal creation function
        function createPublicLinkModal() {
            const modalHtml = `
                <!-- Public Link Modal -->
                <div id="publicLinkModal" class="public-link-modal">
                    <div class="public-link-modal-content">
                        <div class="public-link-header">
                            <h3>üîó Create Public Link</h3>
                            <button class="close-modal" onclick="closePublicLinkModal()">&times;</button>
                        </div>
                        
                        <div class="link-config-section">
                            <h4>üìÑ Item Details</h4>
                            <div class="config-row">
                                <div class="config-label">Type:</div>
                                <div class="config-input">
                                    <span id="linkItemType">File</span>
                                </div>
                            </div>
                            <div class="config-row">
                                <div class="config-label">Name:</div>
                                <div class="config-input">
                                    <span id="linkItemName">example.txt</span>
                                </div>
                            </div>
                        </div>

                        <div class="link-config-section">
                            <h4>‚öôÔ∏è Link Configuration</h4>
                            <div class="config-row">
                                <div class="config-label">Expiry Time:</div>
                                <div class="config-input">
                                    <select id="linkExpiry">
                                        <option value="1h">1 Hour</option>
                                        <option value="24h" selected>24 Hours</option>
                                        <option value="7d">7 Days</option>
                                        <option value="30d">30 Days</option>
                                        <option value="never">Never Expires</option>
                                    </select>
                                </div>
                            </div>
                            <div class="config-row">
                                <div class="config-label">Password Protection:</div>
                                <div class="config-input">
                                    <input type="text" id="linkPassword" placeholder="Optional password">
                                </div>
                            </div>
                            <div class="config-row">
                                <div class="config-label">Permissions:</div>
                                <div class="config-input">
                                    <select id="linkPermissions">
                                        <option value="view" selected>View Only</option>
                                        <option value="download">View & Download</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div style="text-align: center; margin: 25px 0;">
                            <button class="btn" onclick="generatePublicLink()" style="padding: 12px 30px; font-size: 16px;">
                                üîó Generate Link
                            </button>
                        </div>

                        <div id="generatedLinkSection" class="generated-link-section" style="display: none;">
                            <h4>üéâ Public Link Generated!</h4>
                            <div class="link-display">
                                <input type="text" id="generatedLink" class="link-input" readonly>
                            </div>
                            <div class="link-actions">
                                <button class="btn-copy" onclick="copyPublicLink()">üìã Copy Link</button>
                                <button class="btn-qr" onclick="generateQRCode()">üì± QR Code</button>
                            </div>
                            <div id="qrCodeContainer" class="qr-code-container" style="display: none;"></div>
                            <div id="linkStats" class="link-stats" style="display: none;"></div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Add a small delay to ensure everything is loaded
            setTimeout(() => {
                checkSharedLink();
            }, 100);
        });

        // Also check for shared links when the page becomes visible
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                checkSharedLink();
            }
        });
    </script>
</body>
</html>
