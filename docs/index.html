<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ File Container</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden; /* Changed from visible to hidden for better corner clipping */
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
            /* Ensure header respects container's top rounded corners */
            border-radius: 15px 15px 0 0;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .github-badge {
            background: rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-block;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .main-content {
            padding: 30px;
        }

        /* Tab System Styles */
        .tab-container {
            margin-bottom: 30px;
        }

        .tab-nav {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px 10px 0 0;
            border: 1px solid #e9ecef;
            border-bottom: none;
            overflow: hidden;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            position: relative;
        }

        .tab-button:hover {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .tab-button.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 0 0 10px 10px;
            padding: 25px;
            min-height: 200px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        /* File Selection Styles */
        .file-selection-area {
            background: #f8f9fa;
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            transition: all 0.3s;
        }

        .file-selection-area.has-selection {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }

        .file-selection-area.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        .selected-files-preview {
            margin-top: 15px;
            display: none;
        }

        .selected-files-preview.show {
            display: block;
        }

        .selected-file-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin: 5px 0;
        }

        /* Multi-select checkbox styles */
        .multi-select-toolbar {
            display: none;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            animation: slideDown 0.3s ease;
        }

        .multi-select-toolbar.show {
            display: flex;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .multi-select-toolbar .select-count {
            font-weight: 600;
            background: rgba(255,255,255,0.2);
            padding: 5px 12px;
            border-radius: 20px;
        }

        .multi-select-toolbar button {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .multi-select-toolbar button:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        .multi-select-toolbar button.btn-danger {
            background: #e74c3c;
            border-color: #c0392b;
        }

        .multi-select-toolbar button.btn-danger:hover {
            background: #c0392b;
        }

        .item-checkbox {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: #667eea;
            z-index: 10;
            opacity: 0.7;
            transition: all 0.2s;
        }

        .item-checkbox:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .item-checkbox:checked {
            opacity: 1;
        }

        /* List view checkbox positioning */
        .file-list.list-view .item-checkbox {
            position: relative;
            top: auto;
            left: auto;
            margin-right: 15px;
            flex-shrink: 0;
        }

        /* Grid view - add padding for checkbox */
        .file-list.grid-view .file-item,
        .file-list.grid-view .folder-item {
            padding-top: 40px;
        }

        .file-item, .folder-item {
            position: relative;
        }

        .file-item.selected, .folder-item.selected {
            border-color: #667eea !important;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.3);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1)) !important;
        }

        .select-all-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #e9ecef;
        }

        .select-all-container input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
            cursor: pointer;
        }

        .select-all-container label {
            cursor: pointer;
            font-weight: 500;
            color: #333;
        }

        .file-icon {
            width: 32px;
            height: 32px;
            margin-right: 10px;
            font-size: 24px;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: #333;
        }

        .file-size {
            font-size: 12px;
            color: #666;
        }

        .file-preview {
            width: 40px;
            height: 40px;
            margin-left: 10px;
            border-radius: 4px;
            object-fit: cover;
        }

        .remove-file {
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 12px;
        }

        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid #e9ecef;
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }

        .section h2::before {
            content: "üìÅ";
            margin-right: 10px;
            font-size: 1.2em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .btn-success {
            background: linear-gradient(135deg, #20bf6b, #26de81);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffa726, #ff7043);
        }

        .file-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        /* View Toggle Styles */
        .view-toggle {
            display: flex;
            gap: 5px;
            background: #f8f9fa;
            padding: 3px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .view-btn {
            background: transparent;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #6c757d;
            transition: all 0.3s ease;
        }

        .view-btn:hover {
            background: #e9ecef;
            color: #495057;
        }

        .view-btn.active {
            background: #667eea;
            color: white;
        }

        /* Quick Actions Styles */
        .quick-actions {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        /* Balanced Quick Action Buttons */
        .quick-actions .btn {
            flex: 1;
            min-width: 140px;
            max-width: 180px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            white-space: nowrap;
            margin: 0;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #5a67d8, #6b46c1);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d, #495057);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #5a6268, #343a40);
            transform: translateY(-1px);
        }

        /* Grid View Styles */
        .file-list.grid-view {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .file-list.grid-view .file-item,
        .file-list.grid-view .folder-item {
            text-align: center;
            padding: 15px;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .file-list.grid-view .file-icon {
            font-size: 2.5em;
            margin-bottom: 8px;
        }

        .file-list.grid-view .file-name {
            font-size: 12px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
            max-width: 100%;
        }

        .file-list.grid-view .file-info {
            font-size: 10px;
            margin-top: 5px;
        }

        /* List View Styles */
        .file-list.list-view {
            display: block;
        }

        .file-list.list-view .file-item,
        .file-list.list-view .folder-item {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            margin-bottom: 10px;
            text-align: left;
        }

        .file-list.list-view .file-icon {
            font-size: 1.5em;
            margin-right: 15px;
            min-width: 30px;
        }

        .file-list.list-view .file-details {
            flex: 1;
        }

        .file-list.list-view .file-actions {
            margin-left: auto;
        }

        .file-item, .folder-item {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s;
        }

        .file-item:hover, .folder-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .folder-item {
            background: linear-gradient(135deg, #ffeaa7, #fdcb6e);
            border-color: #fdcb6e;
        }

        .file-name, .folder-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            word-break: break-word;
        }

        .file-info {
            font-size: 14px;
            color: #666;
            margin-bottom: 15px;
        }

        .file-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .media-preview {
            margin: 10px 0;
            text-align: center;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .media-preview-placeholder {
            margin: 10px 0;
            text-align: center;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #dee2e6;
            cursor: pointer;
            transition: all 0.3s;
        }

        .media-preview-placeholder:hover {
            background: #e9ecef;
            border-color: #667eea;
            transform: translateY(-1px);
        }

        .preview-icon {
            font-size: 2em;
            margin-bottom: 8px;
            color: #6c757d;
        }

        .preview-text {
            font-size: 14px;
            color: #6c757d;
            font-weight: 500;
        }

        .media-preview img, .media-preview video {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .media-preview img:hover {
            transform: scale(1.05);
        }

        .image-modal {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }

        .modal h3 {
            margin-bottom: 20px;
            color: #333;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #000;
        }

        /* Floating Toast Notification System */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 400px;
            pointer-events: none;
        }

        .toast {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            margin-bottom: 12px;
            padding: 16px 20px 16px 16px;
            border-left: 4px solid #667eea;
            backdrop-filter: blur(10px);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: auto;
            position: relative;
            overflow: hidden;
            font-weight: 500;
            line-height: 1.4;
            min-height: 20px;
            display: flex;
            align-items: center;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.hide {
            transform: translateX(100%);
            opacity: 0;
        }

        .toast-success {
            border-left-color: #10B981;
            background: linear-gradient(135deg, #D1FAE5 0%, #ECFDF5 100%);
            color: #065F46;
        }

        .toast-success::before {
            content: '‚úì';
            margin-right: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .toast-error {
            border-left-color: #EF4444;
            background: linear-gradient(135deg, #FEE2E2 0%, #FEF2F2 100%);
            color: #991B1B;
        }

        .toast-error::before {
            content: '‚úï';
            margin-right: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .toast-warning {
            border-left-color: #F59E0B;
            background: linear-gradient(135deg, #FEF3C7 0%, #FFFBEB 100%);
            color: #92400E;
        }

        .toast-warning::before {
            content: '!';
            margin-right: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .toast-info {
            border-left-color: #3B82F6;
            background: linear-gradient(135deg, #DBEAFE 0%, #EFF6FF 100%);
            color: #1E40AF;
        }

        .toast-info::before {
            content: 'i';
            margin-right: 8px;
            font-size: 12px;
            font-weight: bold;
            font-style: italic;
        }

        .toast-message {
            flex: 1;
            padding-right: 8px;
        }

        .toast-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.2s;
            color: inherit;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .toast-close:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.1);
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: currentColor;
            opacity: 0.3;
            border-radius: 0 0 12px 12px;
            animation: toast-progress-animation linear;
        }

        @keyframes toast-progress-animation {
            from { width: 100%; }
            to { width: 0%; }
        }

        /* Progress Container Styles */
        .progress-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
            pointer-events: none;
        }

        .global-progress {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #F3F4F6;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3B82F6, #1D4ED8);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 12px;
            color: #6B7280;
            text-align: center;
        }

        .active-operations {
            max-height: 300px;
            overflow-y: auto;
        }

        .operation-item {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 4px;
            font-size: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            pointer-events: auto;
        }

        .operation-title {
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }

        .operation-progress {
            width: 100%;
            height: 4px;
            background: #F3F4F6;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 4px;
        }

        .operation-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10B981, #059669);
            border-radius: 2px;
            transition: width 0.2s ease;
            width: 0%;
        }

        .operation-status {
            color: #6B7280;
            font-size: 11px;
        }

        /* Active Operations Container */
        .active-operations {
            margin: 10px 0;
        }

        .operation-item {
            background: #F9FAFB;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
        }

        .operation-title {
            font-weight: 500;
            color: #374151;
            margin-bottom: 8px;
            font-size: 14px;
        }

        /* Sync Status Styles */
        .sync-status {
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .sync-indicator {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #E5E7EB;
            border-radius: 12px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .sync-indicator:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .sync-icon {
            font-size: 14px;
            animation: none;
        }

        .sync-icon.syncing {
            animation: rotate 1s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .sync-text {
            color: #374151;
            font-weight: 500;
        }

        .last-sync {
            color: #6B7280;
        }

        .sync-toggle {
            background: #3B82F6;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .sync-toggle:hover {
            background: #2563EB;
        }

        .sync-toggle.disabled {
            background: #9CA3AF;
        }
        
        /* Sync Status Section - Active Upload Highlight */
        #syncStatusSection.has-active-operations {
            border: 2px solid #3B82F6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
            animation: pulse-border 2s infinite;
        }
        
        #syncStatusSection.has-active-operations .collapsible-header {
            background: linear-gradient(135deg, #3B82F6, #1D4ED8);
            color: white;
        }
        
        #syncStatusSection.has-active-operations .collapsible-header h3 {
            color: white;
        }
        
        @keyframes pulse-border {
            0%, 100% {
                box-shadow: 0 0 15px rgba(59, 130, 246, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(59, 130, 246, 0.6);
            }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .progress-container {
                right: 10px;
                top: 70px;
                max-width: calc(100vw - 20px);
            }
        }

        /* Mobile responsive */
        @media (max-width: 480px) {
            .toast-container {
                left: 20px;
                right: 20px;
                max-width: none;
            }
            
            .toast {
                margin-bottom: 8px;
                padding: 12px 16px 12px 12px;
            }
        }

        /* Legacy alert styles for compatibility */
        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            display: none; /* Hide old alerts */
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover, .upload-area.dragover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .upload-area.dragover {
            border-color: #20bf6b;
            background: #f0fff4;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 15px;
            color: #667eea;
        }

        .breadcrumb {
            flex: 1;
        }

        .breadcrumb a {
            color: #667eea;
            text-decoration: none;
            margin-right: 5px;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        /* Back Button Styles */
        .back-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 15px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .back-button:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .back-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .breadcrumb-container {
            display: flex;
            align-items: center;
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .storage-info {
            background: #e3f2fd;
            border: 1px solid #bbdefb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .storage-bar {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            margin-top: 10px;
            overflow: hidden;
        }

        .storage-fill {
            background: linear-gradient(135deg, #667eea, #764ba2);
            height: 100%;
            transition: width 0.3s;
        }

        .data-management {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 15px;
            }
            
            .file-list {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .file-actions {
                justify-content: center;
            }

            .data-management {
                flex-direction: column;
            }
        }

        /* ============================================================================ */
        /* DROPDOWN UTILITIES MENU */
        /* ============================================================================ */
        
        .utilities-dropdown {
            position: relative;
            display: inline-block;
        }

        .utilities-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .utilities-btn:hover {
            background: linear-gradient(135deg, #5a67d8, #6b46c1);
            transform: translateY(-1px);
        }

        .utilities-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: white;
            min-width: 250px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            border-radius: 12px;
            z-index: 9999;
            border: 1px solid #e2e8f0;
            padding: 8px 0;
            margin-top: 5px;
            left:0;
        }

        .utilities-dropdown-content.show {
            display: block;
            animation: fadeInDown 0.3s ease;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dropdown-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dropdown-item:hover {
            background-color: #f8fafc;
        }

        .dropdown-divider {
            height: 1px;
            background-color: #e2e8f0;
            margin: 8px 0;
        }

        /* Collapsible Sections */
        .collapsible-section {
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 3px;
            border: 1px solid #dee2e6;
            overflow: hidden;
        }

        .collapsible-header {
            padding: 5px;
            background: linear-gradient(135deg, #f8a4a4, #f8f9fa);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s ease;
            border-bottom: 1px solid #dee2e6;
            /* Ensure proper corner styling */
            border-radius: 10px 10px 0 0;
        }

        .collapsible-header:hover {
            background: linear-gradient(135deg, #dee2e6, #a1c5ea);
        }

        .collapsible-section.collapsed .collapsible-header {
            /* When collapsed, round all corners */
            border-radius: 10px;
            border-bottom: none;
        }

        .collapsible-header h3 {
            margin: 10px;
            font-size: 16px;
        }

        .collapsible-toggle {
            font-size: 14px;
            color: #f4c2c2;
            transition: transform 0.3s ease;
        }

        .collapsible-content {
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
            padding: 0 15px;
            color: #333;
        }

        .collapsible-section:not(.collapsed) .collapsible-content {
            max-height: 1000px;
            padding: 15px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 500px;
            }
        }

        .collapsible-section.collapsed .collapsible-toggle {
            transform: rotate(-90deg);
        }

        /* Mobile responsive for GitHub configuration */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 12px;
            }
            
            .header {
                padding: 20px;
                border-radius: 12px 12px 0 0;
            }
            
            .github-config {
                display: block !important;
                grid-template-columns: none !important;
            }
            
            .config-item {
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }
            
            .config-item:last-child {
                border-bottom: none;
            }
            
            .config-item button {
                display: block;
                width: 100%;
                margin: 5px 0 !important;
                text-align: center;
            }
        }

        @media (max-width: 480px) {
            .container {
                margin: 5px;
                border-radius: 8px;
            }
            
            .header {
                padding: 15px;
                border-radius: 8px 8px 0 0;
            }
            
            .header h1 {
                font-size: 1.8em;
            }
            
            .collapsible-section {
                border-radius: 8px;
                margin-bottom: 8px;
            }
            
            .collapsible-header {
                padding: 10px;
                border-radius: 8px 8px 0 0;
            }
            
            .collapsible-section.collapsed .collapsible-header {
                border-radius: 8px;
            }
            
            .collapsible-header h3 {
                font-size: 14px;
                margin: 5px;
            }
            
            .github-config {
                margin-top: 5px !important;
            }
            
            .config-item label {
                display: block;
                font-weight: bold;
                margin-bottom: 5px;
            }
            
            .config-item select {
                width: 100%;
                padding: 8px;
                font-size: 14px;
            }
        }

        /* ============================================================================ */
        /* LOG VIEWER STYLES */
        /* ============================================================================ */
        
        .log-container {
            margin-top: 15px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: #343a40;
            color: white;
        }
        
        .log-header h4 {
            margin: 0;
            font-size: 14px;
        }
        
        .log-controls {
            display: flex;
            gap: 8px;
        }
        
        .log-controls button {
            padding: 4px 10px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .log-controls .btn-clear {
            background: #dc3545;
            color: white;
        }
        
        .log-controls .btn-clear:hover {
            background: #c82333;
        }
        
        .log-controls .btn-export {
            background: #28a745;
            color: white;
        }
        
        .log-controls .btn-export:hover {
            background: #218838;
        }
        
        .log-controls .btn-filter {
            background: #6c757d;
            color: white;
        }
        
        .log-controls .btn-filter.active {
            background: #007bff;
        }
        
        .log-viewer {
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            height: 250px;
            overflow-y: auto;
            overflow-x: auto;
        }
        
        .log-entry {
            padding: 3px 8px;
            margin: 2px 0;
            border-radius: 3px;
            display: flex;
            gap: 10px;
            white-space: nowrap;
        }
        
        .log-entry:hover {
            background: rgba(255,255,255,0.05);
        }
        
        .log-time {
            color: #858585;
            min-width: 80px;
        }
        
        .log-type {
            min-width: 60px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .log-entry.info .log-type { color: #3794ff; }
        .log-entry.success .log-type { color: #4ec9b0; }
        .log-entry.warning .log-type { color: #cca700; }
        .log-entry.error .log-type { color: #f14c4c; }
        .log-entry.debug .log-type { color: #b267e6; }
        
        .log-message {
            flex: 1;
            word-break: break-all;
            white-space: pre-wrap;
        }
        
        .log-entry.info .log-message { color: #9cdcfe; }
        .log-entry.success .log-message { color: #4ec9b0; }
        .log-entry.warning .log-message { color: #dcdcaa; }
        .log-entry.error .log-message { color: #f48771; }
        .log-entry.debug .log-message { color: #ce9178; }
        
        .log-stats {
            display: flex;
            gap: 15px;
            padding: 8px 15px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            font-size: 12px;
        }
        
        .log-stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .log-stat-count {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
        }
        
        .log-stat-count.info { background: #cce5ff; color: #004085; }
        .log-stat-count.success { background: #d4edda; color: #155724; }
        .log-stat-count.warning { background: #fff3cd; color: #856404; }
        .log-stat-count.error { background: #f8d7da; color: #721c24; }

        /* ============================================================================ */
        /* PAGINATION AND LOADING STYLES */
        /* ============================================================================ */

        .loading-status {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #e9ecef;
        }

        .loading-text {
            font-weight: 500;
            color: #495057;
            margin-right: 15px;
        }

        .cache-info {
            font-size: 12px;
            color: #6c757d;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .pagination-container {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .pagination-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 500;
            color: #495057;
        }

        .cache-status {
            font-size: 12px;
            color: #6c757d;
            background: #e9ecef;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .cache-status.cached {
            background: #d1ecf1;
            color: #0c5460;
        }

        .pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .pagination-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .pagination-btn:hover:not(:disabled) {
            background: #5a6fd8;
            transform: translateY(-1px);
        }

        .pagination-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .pagination-numbers {
            display: flex;
            gap: 5px;
            align-items: center;
        }

        .page-number {
            padding: 8px 12px;
            border: 1px solid #e9ecef;
            background: white;
            color: #495057;
            text-decoration: none;
            border-radius: 4px;
            font-weight: 500;
            transition: all 0.3s;
            cursor: pointer;
        }

        .page-number:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .page-number.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pagination-options {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .pagination-options label {
            font-weight: 500;
            color: #495057;
        }

        .pagination-options select {
            padding: 6px 10px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background: white;
            font-weight: 500;
        }

        .btn-small {
            background: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            transition: all 0.3s;
        }

        .btn-small:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        /* Mobile responsiveness for pagination */
        @media (max-width: 768px) {
            .pagination-controls {
                flex-direction: column;
                gap: 15px;
            }

            .pagination-numbers {
                order: 1;
            }

            .pagination-btn {
                order: 2;
                width: 120px;
            }

            .pagination-options {
                flex-direction: column;
                gap: 10px;
            }

            .pagination-info {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }

        /* ============================================================================ */
        /* PUBLIC LINK FUNCTIONALITY */
        /* ============================================================================ */

        .btn-share {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-share:hover {
            background: linear-gradient(135deg, #1e7e34, #17a2b8);
            transform: translateY(-1px);
        }

        .public-link-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            overflow-y: auto;
            padding: 20px 0;
        }

        .public-link-modal-content {
            background-color: white;
            margin: 20px auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            overflow-y: auto;
            position: relative;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .public-link-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .public-link-header h3 {
            color: #333;
            font-size: 1.4em;
            margin: 0;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .close-modal:hover {
            background: #f8f9fa;
            color: #333;
        }

        .link-config-section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
        }

        .link-config-section h4 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.1em;
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .config-row:last-child {
            margin-bottom: 0;
        }

        .config-label {
            flex: 1;
            font-weight: 500;
            color: #555;
        }

        .config-input {
            flex: 2;
            margin-left: 15px;
        }

        .config-input select,
        .config-input input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .generated-link-section {
            margin-top: 25px;
            padding: 20px;
            background: #e7f3ff;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .link-display {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .link-input {
            flex: 1;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: white;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #333;
        }

        .link-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-copy,
        .btn-qr {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .btn-copy:hover,
        .btn-qr:hover {
            background: linear-gradient(135deg, #0056b3, #004085);
            transform: translateY(-1px);
        }

        .qr-code-container {
            text-align: center;
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            border: 1px solid #ddd;
        }

        .link-stats {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            font-size: 14px;
        }

        .link-stats h5 {
            margin-bottom: 10px;
            color: #856404;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #856404;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 3px;
        }

        /* ============================================================================ */
        /* PUBLIC LINKS MANAGER MODAL */
        /* ============================================================================ */

        .links-manager-modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            overflow-y: auto;
            padding: 20px 0;
        }

        .links-manager-content {
            background-color: white;
            margin: 20px auto;
            padding: 30px;
            border-radius: 15px;
            width: 95%;
            max-width: 900px;
            max-height: 90vh;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease;
            overflow-y: auto;
            position: relative;
        }

        .links-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .links-table th,
        .links-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .links-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #333;
            position: sticky;
            top: 0;
        }

        .links-table tr:hover {
            background-color: #f8f9fa;
        }

        .links-table tr.selected {
            background-color: #e3f2fd !important;
        }

        .links-table tr.selected:hover {
            background-color: #bbdefb !important;
        }

        .checkbox-cell {
            width: 40px;
            text-align: center;
        }

        .link-checkbox {
            transform: scale(1.2);
            cursor: pointer;
        }

        .selection-actions {
            display: none;
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #2196f3;
        }

        .selection-actions.show {
            display: block;
        }

        .selected-count {
            font-weight: bold;
            color: #1976d2;
        }

        .statistics-panel {
            display: none;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .statistics-panel.show {
            display: block;
        }

        .stats-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #dee2e6;
        }

        .stats-grid-detailed {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-card h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 14px;
        }

        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }

        .link-details {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .detail-label {
            font-weight: 500;
            color: #666;
        }

        .detail-value {
            color: #333;
        }

        .link-status {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .status-active {
            background-color: #d4edda;
            color: #155724;
        }

        .status-expired {
            background-color: #f8d7da;
            color: #721c24;
        }

        .link-actions-cell {
            white-space: nowrap;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
            margin: 2px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-edit {
            background: #007bff;
            color: white;
        }

        .btn-edit:hover {
            background: #0056b3;
        }

        .btn-delete-link {
            background: #dc3545;
            color: white;
        }

        .btn-delete-link:hover {
            background: #c82333;
        }

        .btn-copy-small {
            background: #28a745;
            color: white;
        }

        .btn-copy-small:hover {
            background: #1e7e34;
        }

        .no-links-message {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .manager-actions {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .link-url {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #666;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ File Container</h1>
            <!-- GitHub Configuration Section -->
        <div class="collapsible-section collapsed" id="githubConfigSection">
            <div class="collapsible-header" onclick="toggleCollapsible('githubConfigSection')">
                <h3>‚öôÔ∏è GitHub Configuration</h3>
                <span class="collapsible-toggle">‚ñº</span>
            </div>
            <div class="collapsible-content">
                <div class="github-config" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                    <div class="config-item">
                        <label><strong>Repository:</strong> </label>
                        <span id="repoInfo">krasyid822/file-container</span>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">Files stored permanently in GitHub repo</div>
                    </div>
                    <div class="config-item">
                        <label><strong>Token Status:</strong> </label>
                        <span id="tokenStatus">‚ùå Not configured</span>
                        <button onclick="configureGitHubToken()" class="btn" style="margin-left: 10px; padding: 5px 10px; font-size: 12px;">üîß Setup Token</button>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">Required for permanent storage</div>
                    </div>
                    <div class="config-item">
                        <label><strong>Storage Mode:</strong> </label>
                        <select id="storageMode" onchange="changeStorageMode()" style="padding: 5px;">
                            <option value="github">üåê GitHub Storage (Permanent)</option>
                        </select>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">All files stored permanently in GitHub repository</div>
                    </div>
                    <div class="config-item">
                        <button onclick="testGitHubConnection()" class="btn" style="padding: 5px 10px; font-size: 12px;">üß™ Test Connection</button>
                        <button onclick="validateGitHubStorage()" class="btn" style="padding: 5px 10px; font-size: 12px; margin-left: 5px;">‚úÖ Validate Storage</button>
                        <button onclick="initializeGitHubStorage()" class="btn" style="padding: 5px 10px; font-size: 12px; margin-left: 5px;">üöÄ Initialize Storage</button>
                    </div>
                    <div class="config-item" style="grid-column: 1 / -1; margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                        <label><strong>üóÇÔ∏è Storage Management:</strong></label>
                        <button onclick="resetStorageFolder()" class="btn" style="padding: 5px 10px; font-size: 12px; background: #dc3545; color: white; margin-left: 10px;">üóëÔ∏è Reset Storage Folder</button>
                        <div style="font-size: 11px; color: #666; margin-top: 2px;">Delete and recreate storage folder (removes all stored files)</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sync Status and Progress -->
        <div class="collapsible-section collapsed" id="syncStatusSection">
            <div class="collapsible-header" onclick="toggleCollapsible('syncStatusSection')">
                <h3>üîÑ Sync Status & Progress</h3>
                <span class="collapsible-toggle">‚ñº</span>
            </div>
            <div class="collapsible-content">
                <!-- Real-time Progress -->
                <div id="progressContainer" class="progress-container" style="position: relative; right: auto; top: auto; max-width: none; margin-bottom: 15px;">
                    <!-- Global Progress Bar -->
                    <div id="globalProgress" class="global-progress" style="display: none;">
                        <div class="progress-bar">
                            <div id="globalProgressFill" class="progress-fill"></div>
                        </div>
                        <div id="globalProgressText" class="progress-text">Initializing...</div>
                    </div>
                    
                    <!-- Active Operations Container -->
                    <div id="activeOperations" class="active-operations"></div>
                    
                    <!-- Individual Operation Progress -->
                    <div id="operationProgress" class="operation-progress" style="display: none;">
                        <div id="operationProgressFill" class="operation-progress-fill"></div>
                        <div id="operationStatus" class="operation-status">Ready</div>
                    </div>
                </div>
                
                <!-- Sync Status Indicator -->
                <div id="syncStatus" class="sync-status">
                    <div class="sync-indicator">
                        <span id="syncIcon" class="sync-icon">üîÑ</span>
                        <span id="syncText" class="sync-text">Auto-sync files & folders enabled</span>
                        <span id="lastSyncTime" class="last-sync">Never</span>
                        <button id="toggleAutoSync" class="sync-toggle" onclick="toggleAutoSync()">Disable</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cache Clear Notice -->
            <div class="collapsible-section collapsed" id="cacheNoticeSection">
                <div class="collapsible-header" onclick="toggleCollapsible('cacheNoticeSection')">
                    <h3>üí° Troubleshooting & Logs</h3>
                    <span class="collapsible-toggle">‚ñº</span>
                </div>
                <div class="collapsible-content">
                    <div style="background: rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 6px; font-size: 13px; border-left: 3px solid #ffd700; margin-bottom: 15px;">
                        <strong>Jika melihat error 404 API:</strong> Hard refresh browser Anda!
                        <br>‚Ä¢ Windows/Linux: <kbd style="background: rgba(0,0,0,0.2); padding: 2px 4px; border-radius: 3px;">Ctrl + F5</kbd>
                        ‚Ä¢ Mac: <kbd style="background: rgba(0,0,0,0.2); padding: 2px 4px; border-radius: 3px;">Cmd + Shift + R</kbd>
                        <br>‚Ä¢ Atau buka Developer Tools (F12) ‚Üí Application/Storage ‚Üí Clear Storage
                    </div>
                    
                    <!-- Log Viewer -->
                    <div class="log-container">
                        <div class="log-header">
                            <h4>üìã Activity Log</h4>
                            <div class="log-controls">
                                <button class="btn-filter active" data-filter="all" onclick="filterLogs('all')">All</button>
                                <button class="btn-filter" data-filter="error" onclick="filterLogs('error')">Errors</button>
                                <button class="btn-filter" data-filter="warning" onclick="filterLogs('warning')">Warnings</button>
                                <button class="btn-export" onclick="exportLogs()">üì• Export</button>
                                <button class="btn-clear" onclick="clearLogs()">üóëÔ∏è Clear</button>
                            </div>
                        </div>
                        <div id="logViewer" class="log-viewer">
                            <div class="log-entry info">
                                <span class="log-time">--:--:--</span>
                                <span class="log-type">INFO</span>
                                <span class="log-message">Log system initialized. Activities will appear here.</span>
                            </div>
                        </div>
                        <div class="log-stats">
                            <div class="log-stat">
                                <span>‚ÑπÔ∏è Info:</span>
                                <span id="logCountInfo" class="log-stat-count info">0</span>
                            </div>
                            <div class="log-stat">
                                <span>‚úÖ Success:</span>
                                <span id="logCountSuccess" class="log-stat-count success">0</span>
                            </div>
                            <div class="log-stat">
                                <span>‚ö†Ô∏è Warning:</span>
                                <span id="logCountWarning" class="log-stat-count warning">0</span>
                            </div>
                            <div class="log-stat">
                                <span>‚ùå Error:</span>
                                <span id="logCountError" class="log-stat-count error">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- <p>Real GitHub Repository Storage dengan Auto-Chunking (20MB chunks)</p> -->
            <!-- <div class="github-badge">
                üåê GitHub API Integration
            </div> -->
            
            
        </div>

        <div class="main-content">
            <!-- Toast Container for Floating Notifications -->
            <div id="toastContainer" class="toast-container"></div>
            
            <!-- Legacy Alert Area (hidden) -->
            <div id="alertArea" style="display: none;"></div>

            <!-- Storage Info -->
            <div class="storage-info">
                <div>
                    <strong>üíæ JSON File Storage:</strong> 
                    <span id="storageUsed">0 KB</span> across <span id="fileCount">0</span> data files
                </div>
                <div class="storage-bar">
                    <div class="storage-fill" id="storageFill"></div>
                </div>
                <div id="storageDetails" style="font-size: 12px; margin-top: 8px; color: #666;"></div>
                
                <!-- Network Usage Info -->
                <div id="networkUsage" class="network-usage" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 12px;">
                    <strong>üìä Network Usage:</strong>
                    <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                        <span>Requests: <span id="requestCount">0</span></span>
                        <span>Cache hits: <span id="cacheHits">0</span></span>
                        <span>Data saved: <span id="dataSaved">0 KB</span></span>
                    </div>
                </div>
                
                <div class="data-management">
                    <div class="utilities-dropdown">
                        <button class="utilities-btn" onclick="toggleUtilitiesDropdown()">
                            üõ†Ô∏è Utilities
                            <span style="margin-left: auto;">‚ñº</span>
                        </button>
                        <div class="utilities-dropdown-content" id="utilitiesDropdown">
                            <button class="dropdown-item" onclick="exportAllData(); closeUtilitiesDropdown();">
                                üì§ Export All Data
                            </button>
                            <button class="dropdown-item" onclick="document.getElementById('importFile').click(); closeUtilitiesDropdown();">
                                üì• Import Data
                            </button>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item" onclick="refreshDataFiles(); closeUtilitiesDropdown();">
                                üìä Refresh Data
                            </button>
                            <button class="dropdown-item" onclick="showDataFilesList(); closeUtilitiesDropdown();">
                                üìã Show Data Files
                            </button>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item" onclick="testNotifications(); closeUtilitiesDropdown();">
                                üîî Test Notifications
                            </button>
                            <button class="dropdown-item" onclick="testLargeFileSupport(); closeUtilitiesDropdown();">
                                üìÅ Large File Info
                            </button>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item" onclick="showPublicLinksManager(); closeUtilitiesDropdown();">
                                üîó Manage Public Links
                            </button>
                        </div>
                    </div>
                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
                </div>
            </div>

            <!-- Breadcrumb Navigation -->
            <div class="breadcrumb-container">
                <button class="back-button" id="backButton" onclick="goBack()" style="display: none;">
                    ‚Üê Kembali
                </button>
                <div class="breadcrumb" id="breadcrumb">
                    <a href="#" onclick="loadFolder('')">üè† Home</a>
                </div>
            </div>

            <!-- Tab Navigation System -->
            <div class="tab-container">
                <div class="tab-nav">
                    <button class="tab-button active" onclick="switchTab('browser')">üóÇÔ∏è File Browser</button>
                </div>
                
                <div class="tab-content">
                    <!-- File Browser Tab -->
                    <div id="browserTab" class="tab-panel active">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0;">üóÇÔ∏è File & Folder Browser</h3>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <div class="view-toggle">
                                    <button class="view-btn active" id="listViewBtn" onclick="switchView('list')" title="List View">
                                        üìã List
                                    </button>
                                    <button class="view-btn" id="gridViewBtn" onclick="switchView('grid')" title="Grid View">
                                        ‚äû Grid
                                    </button>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px; margin-left: 15px;">
                                    <label style="font-size: 12px; font-weight: 500;">
                                        <input type="checkbox" id="autoPreviewToggle" onchange="toggleAutoPreview()" style="margin-right: 5px;">
                                        üñºÔ∏è Auto Preview
                                    </label>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Quick Actions -->
                        <div class="quick-actions" style="margin-bottom: 15px; display: flex; gap: 12px; flex-wrap: wrap; justify-content: flex-start;">
                            <button class="btn btn-secondary" id="upLevelBtn" onclick="goUpOneLevel()" style="display: none;">
                                ‚¨ÜÔ∏è Up Level
                            </button>
                            <button class="btn btn-primary" onclick="triggerFileUpload()">
                                üìé Upload Files
                            </button>
                            <button class="btn btn-primary" onclick="triggerFolderUpload()">
                                üìÅ Upload Folder
                            </button>
                            <button class="btn btn-success" onclick="showCreateFolderDialog()">
                                ‚ûï Create Folder
                            </button>
                        </div>
                        
                        <!-- Hidden file inputs for uploads -->
                        <input type="file" id="quickFileInput" multiple style="display: none;" onchange="handleQuickFileUpload(event)">
                        <input type="file" id="quickFolderInput" webkitdirectory directory multiple style="display: none;" onchange="handleQuickFolderUpload(event)">
                        
                        <!-- File Selection Preview (for when files are selected) -->
                        <div id="quickSelectedFilesPreview" class="selected-files-preview" style="display: none; margin-bottom: 15px;">
                            <h4>Selected Files:</h4>
                            <div id="quickSelectedFilesList" class="selected-files-list"></div>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-primary" onclick="uploadSelectedFiles()">üì§ Upload Selected Files</button>
                                <button class="btn btn-secondary" onclick="clearFileSelection()">‚ùå Clear Selection</button>
                            </div>
                        </div>
                        
                        <!-- Create Folder Dialog (inline) -->
                        <div id="createFolderDialog" class="create-folder-dialog" style="display: none; margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                            <h4>üìÅ Create New Folder</h4>
                            <div class="form-group" style="margin-bottom: 10px;">
                                <label for="quickFolderName">Folder Name:</label>
                                <input type="text" id="quickFolderName" class="form-control" placeholder="Enter folder name" style="margin-bottom: 8px;">
                            </div>
                            <div class="form-group" style="margin-bottom: 10px;">
                                <label for="quickFolderPassword">Security Password (Optional):</label>
                                <input type="password" id="quickFolderPassword" class="form-control" placeholder="Leave empty for no password" style="margin-bottom: 8px;">
                                <small class="help-text" style="color: #666; font-size: 0.9em;">You can create folders without password for easier access</small>
                            </div>
                            <div style="margin-top: 10px;">
                                <button class="btn btn-primary" onclick="createFolderInBrowser()">üìÅ Create Folder</button>
                                <button class="btn btn-secondary" onclick="hideCreateFolderDialog()">‚ùå Cancel</button>
                            </div>
                        </div>
                        
                        <!-- Multi-select toolbar -->
                        <div id="multiSelectToolbar" class="multi-select-toolbar">
                            <span class="select-count" id="selectCount">0 selected</span>
                            <button onclick="downloadSelectedItems()">üì• Download Selected</button>
                            <button onclick="deleteSelectedItems()" class="btn-danger">üóëÔ∏è Delete Selected</button>
                            <button onclick="clearMultiSelection()">‚ùå Clear Selection</button>
                        </div>

                        <!-- Select all checkbox -->
                        <div class="select-all-container" id="selectAllContainer" style="display: none;">
                            <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll(this.checked)">
                            <label for="selectAllCheckbox">Select All</label>
                            <span id="selectionInfo" style="margin-left: auto; color: #666; font-size: 0.9em;"></span>
                        </div>

                        <!-- File list loading status and cache info -->
                        <div id="loadingStatus" class="loading-status" style="display: none;">
                            <span class="loading-text">Loading files...</span>
                            <span class="cache-info" id="cacheInfo"></span>
                        </div>
                        
                        <div id="fileList" class="file-list">
                            <!-- Files and folders will be loaded here -->
                        </div>
                        
                        <!-- Pagination Controls -->
                        <div id="paginationContainer" class="pagination-container" style="display: none;">
                            <div class="pagination-info">
                                <span id="fileCount">Loading files...</span>
                                <span class="cache-status" id="cacheStatus"></span>
                            </div>
                            <div class="pagination-controls">
                                <button id="prevPage" class="pagination-btn" onclick="changePage(currentPage - 1)" disabled>
                                    ‚Üê Previous
                                </button>
                                <span class="pagination-numbers" id="paginationNumbers"></span>
                                <button id="nextPage" class="pagination-btn" onclick="changePage(currentPage + 1)" disabled>
                                    Next ‚Üí
                                </button>
                            </div>
                            <div class="pagination-options">
                                <label for="itemsPerPage">Items per page:</label>
                                <select id="itemsPerPage" onchange="changeItemsPerPage(this.value)">
                                    <option value="10">10</option>
                                    <option value="20" selected>20</option>
                                    <option value="50">50</option>
                                    <option value="100">100</option>
                                </select>
                                <button class="btn-small" onclick="refreshFileList(true)">üîÑ Refresh</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Password Verification Modal -->
    <div id="passwordModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePasswordModal()">&times;</span>
            <h3>üîê Password Required</h3>
            <p id="passwordMessage">This folder is password protected. Please enter the password to access it.</p>
            <div class="form-group">
                <label for="folderAccessPassword">Enter Folder Password:</label>
                <input type="password" id="folderAccessPassword" placeholder="Enter password">
            </div>
            <div class="form-group">
                <button class="btn btn-primary" onclick="verifyFolderPassword()">üîì Access Folder</button>
                <button class="btn" onclick="closePasswordModal()">‚ùå Cancel</button>
            </div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                <p style="font-size: 0.9em; color: #666;">Forgot your password?</p>
                <button class="btn btn-warning" onclick="showPasswordRecovery()" style="font-size: 0.9em;">üîÑ Reset Password</button>
            </div>
        </div>
    </div>

    <!-- Password Recovery Modal -->
    <div id="passwordRecoveryModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePasswordRecoveryModal()">&times;</span>
            <h3>üîÑ Password Recovery</h3>
            <p>You can reset the password for this folder. This will remove the password protection.</p>
            <div class="form-group">
                <label>‚ö†Ô∏è Warning: This action cannot be undone</label>
                <p style="font-size: 0.9em; color: #666;">
                    Removing the password will make this folder accessible to anyone with access to your storage.
                </p>
            </div>
            <div class="form-group">
                <button class="btn btn-danger" onclick="removePasswordProtection()">üîì Remove Password Protection</button>
                <button class="btn" onclick="closePasswordRecoveryModal()">‚ùå Cancel</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeDeleteModal()">&times;</span>
            <h3>Konfirmasi Penghapusan</h3>
            <p id="deleteMessage"></p>
            <div class="form-group">
                <label for="deletePassword">Masukkan Sandi Folder:</label>
                <input type="password" id="deletePassword" placeholder="Sandi keamanan">
            </div>
            <button class="btn btn-danger" onclick="confirmDelete()">üóëÔ∏è Hapus</button>
            <button class="btn" onclick="closeDeleteModal()">‚ùå Batal</button>
        </div>
    </div>

    <script>
        // ============================================================================
        // GITHUB API REAL STORAGE SYSTEM
        // ============================================================================
        
        // GitHub API Configuration
        const GITHUB_CONFIG = {
            OWNER: 'krasyid822',  // GitHub username
            REPO: 'file-container',  // Repository name
            BRANCH: 'main',  // Target branch
            DATA_PATH: 'storage/',  // Storage path in repo (moved to root to avoid GitHub Pages deployment)
            API_BASE: 'https://api.github.com',
            TOKEN: localStorage.getItem('github_token') || null
        };
        
        // ============================================================================
        // LOG SYSTEM
        // ============================================================================
        
        // Log storage
        let appLogs = [];
        let logCounts = { info: 0, success: 0, warning: 0, error: 0, debug: 0 };
        let currentLogFilter = 'all';
        const MAX_LOGS = 500; // Maximum logs to keep
        
        // Add log entry
        function addLog(message, type = 'info', details = null) {
            const timestamp = new Date();
            const timeStr = timestamp.toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            
            const logEntry = {
                time: timeStr,
                timestamp: timestamp.getTime(),
                type: type.toLowerCase(),
                message: message,
                details: details
            };
            
            appLogs.unshift(logEntry);
            
            // Trim old logs
            if (appLogs.length > MAX_LOGS) {
                const removed = appLogs.pop();
                if (logCounts[removed.type]) logCounts[removed.type]--;
            }
            
            // Update counts
            if (logCounts[logEntry.type] !== undefined) {
                logCounts[logEntry.type]++;
            }
            
            // Render if log viewer exists
            renderLogs();
            updateLogStats();
            
            // Also log to console
            const consoleMethod = type === 'error' ? 'error' : type === 'warning' ? 'warn' : 'log';
            console[consoleMethod](`[${type.toUpperCase()}] ${message}`, details || '');
        }
        
        // Render logs to viewer
        function renderLogs() {
            const viewer = document.getElementById('logViewer');
            if (!viewer) return;
            
            const filteredLogs = currentLogFilter === 'all' 
                ? appLogs 
                : appLogs.filter(log => log.type === currentLogFilter);
            
            if (filteredLogs.length === 0) {
                viewer.innerHTML = `
                    <div class="log-entry info">
                        <span class="log-time">--:--:--</span>
                        <span class="log-type">INFO</span>
                        <span class="log-message">No logs to display${currentLogFilter !== 'all' ? ' for this filter' : ''}.</span>
                    </div>
                `;
                return;
            }
            
            viewer.innerHTML = filteredLogs.map(log => `
                <div class="log-entry ${log.type}">
                    <span class="log-time">${log.time}</span>
                    <span class="log-type">${log.type}</span>
                    <span class="log-message">${escapeHtml(log.message)}${log.details ? ' | ' + escapeHtml(JSON.stringify(log.details)) : ''}</span>
                </div>
            `).join('');
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            if (typeof text !== 'string') text = String(text);
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Update log statistics
        function updateLogStats() {
            const infoEl = document.getElementById('logCountInfo');
            const successEl = document.getElementById('logCountSuccess');
            const warningEl = document.getElementById('logCountWarning');
            const errorEl = document.getElementById('logCountError');
            
            if (infoEl) infoEl.textContent = logCounts.info;
            if (successEl) successEl.textContent = logCounts.success;
            if (warningEl) warningEl.textContent = logCounts.warning;
            if (errorEl) errorEl.textContent = logCounts.error;
        }
        
        // Filter logs
        function filterLogs(filter) {
            currentLogFilter = filter;
            
            // Update filter buttons
            document.querySelectorAll('.log-controls .btn-filter').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filter);
            });
            
            renderLogs();
        }
        
        // Clear logs
        function clearLogs() {
            if (confirm('Are you sure you want to clear all logs?')) {
                appLogs = [];
                logCounts = { info: 0, success: 0, warning: 0, error: 0, debug: 0 };
                renderLogs();
                updateLogStats();
                addLog('Logs cleared', 'info');
            }
        }
        
        // Export logs
        function exportLogs() {
            if (appLogs.length === 0) {
                showAlert('No logs to export', 'warning');
                return;
            }
            
            const exportData = {
                exportDate: new Date().toISOString(),
                totalLogs: appLogs.length,
                counts: logCounts,
                logs: appLogs
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `file-container-logs-${new Date().toISOString().slice(0,10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addLog('Logs exported successfully', 'success');
        }
        
        // Collapsible section toggle function
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            
            const toggle = section.querySelector('.collapsible-toggle');
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                toggle.textContent = '‚ñ≤';
            } else {
                section.classList.add('collapsed');
                toggle.textContent = '‚ñº';
            }
        }
        
        // Function to load token from file if available
        async function loadTokenFromFile() {
            try {
                const response = await fetch('./.token-api.txt');
                if (response.ok) {
                    const token = (await response.text()).trim();
                    if (token && token.startsWith('ghp_')) {
                        setGitHubToken(token);
                        console.log('üîë GitHub token loaded from .token-api.txt');
                        return true;
                    }
                }
            } catch (error) {
                console.log('üìÑ No .token-api.txt file found, using localStorage token');
            }
            return false;
        }
        
        // Initialize token on load
        (async () => {
            if (!GITHUB_CONFIG.TOKEN) {
                await loadTokenFromFile();
            }
            // Update token status after loading
            updateTokenStatus();
        })();
        
        // Debug: Check if token exists
        console.log('üîß GitHub Config loaded:', {
            hasToken: !!GITHUB_CONFIG.TOKEN,
            config: GITHUB_CONFIG
        });
        
        let db;
        const DB_NAME = 'FileContainerDB';
        const DB_VERSION = 1;
        // Configuration constants
        const CHUNK_SIZE = 20 * 1024 * 1024; // 20MB chunks (optimized for large files)
        
        // GitHub API Authentication
        function setGitHubToken(token) {
            GITHUB_CONFIG.TOKEN = token;
            localStorage.setItem('github_token', token);
            showAlert('‚úÖ GitHub token configured successfully!', 'success');
        }
        
        function getGitHubToken() {
            if (!GITHUB_CONFIG.TOKEN) {
                const token = prompt('Masukkan GitHub Personal Access Token Anda:\n\n1. Buka GitHub Settings > Developer settings > Personal access tokens\n2. Generate new token dengan scope: repo\n3. Copy dan paste token di sini:');
                if (token) {
                    setGitHubToken(token);
                }
            }
            return GITHUB_CONFIG.TOKEN;
        }
        
        // GitHub API Helper Functions with Request Deduplication
        async function githubApiRequest(endpoint, method = 'GET', data = null) {
            const token = getGitHubToken();
            if (!token) {
                throw new Error('GitHub token required');
            }
            
            // Create request key for deduplication
            const requestKey = `${method}:${endpoint}:${data ? JSON.stringify(data) : ''}`;
            
            // Check for pending request
            if (pendingRequests.has(requestKey)) {
                console.log(`üîÑ Reusing pending request: ${method} ${endpoint}`);
                return await pendingRequests.get(requestKey);
            }
            
            // Check if endpoint is already a full URL or just a path
            const url = endpoint.startsWith('http') ? endpoint : `${GITHUB_CONFIG.API_BASE}${endpoint}`;
            console.log(`üåê GitHub API Request: ${method} ${url}`);
            addLog(`API Request: ${method} ${endpoint.split('/').pop()}`, 'debug');
            
            const headers = {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            };

            const options = {
                method,
                headers,
                body: data ? JSON.stringify(data) : null
            };

            // Create and store the request promise
            const requestPromise = (async () => {
                try {
                    // Track network request
                    trackNetworkRequest();
                    
                    const response = await fetch(url, options);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        console.error(`‚ùå GitHub API Error: ${response.status} - ${errorData.message || response.statusText}`);
                        addLog(`API Error: ${response.status} - ${errorData.message || response.statusText}`, 'error');
                        throw new Error(`GitHub API error: ${response.status} - ${errorData.message || response.statusText}`);
                    }

                    console.log(`‚úÖ GitHub API Success: ${method} ${url}`);
                    const result = await response.json();
                    
                    // Cache GET requests temporarily
                    if (method === 'GET' && result) {
                        setTimeout(() => {
                            // Remove from cache after 30 seconds for GET requests
                            pendingRequests.delete(requestKey);
                        }, 30000);
                    } else {
                        // Remove immediately for non-GET requests
                        pendingRequests.delete(requestKey);
                    }
                    
                    return result;
                } catch (error) {
                    pendingRequests.delete(requestKey);
                    throw error;
                }
            })();
            
            // Store the promise
            pendingRequests.set(requestKey, requestPromise);
            
            return await requestPromise;
        }
        
        // Get file from GitHub repository (supports large files)
        async function getFileFromGitHub(filePath) {
            try {
                console.log(`üìÇ Fetching file: ${filePath}`);
                const endpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filePath}`;
                const response = await githubApiRequest(endpoint);
                
                console.log(`üìã GitHub API response for ${filePath}:`, {
                    hasContent: !!response.content,
                    size: response.size,
                    hasDownloadUrl: !!response.download_url
                });
                
                if (response.content) {
                    // Decode base64 content
                    const content = atob(response.content.replace(/\n/g, ''));
                    console.log(`‚úÖ File loaded via content field (${content.length} chars)`);
                    return {
                        content: content,
                        sha: response.sha,
                        path: response.path
                    };
                }
                
                // If no content but file exists (large file > 1MB), use download_url
                if (response.download_url && response.size > 0) {
                    console.log(`üì• Large file detected (${response.size} bytes), using download_url: ${response.download_url}`);
                    
                    // Try multiple methods to download large files
                    // Method 1: Direct fetch with Authorization
                    try {
                        const token = GITHUB_CONFIG.TOKEN;
                        const downloadResponse = await fetch(response.download_url, {
                            headers: token ? { 'Authorization': `token ${token}` } : {}
                        });
                        
                        if (downloadResponse.ok) {
                            const content = await downloadResponse.text();
                            console.log(`‚úÖ Large file downloaded via direct fetch (${content.length} chars)`);
                            return {
                                content: content,
                                sha: response.sha,
                                path: response.path
                            };
                        } else {
                            console.warn(`‚ö†Ô∏è Direct fetch failed: ${downloadResponse.status} ${downloadResponse.statusText}`);
                        }
                    } catch (downloadError) {
                        console.warn('‚ö†Ô∏è Direct download failed, trying raw.githubusercontent.com:', downloadError.message);
                    }
                    
                    // Method 2: Use raw.githubusercontent.com URL
                    try {
                        const rawUrl = `https://raw.githubusercontent.com/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/${GITHUB_CONFIG.BRANCH}/${filePath}`;
                        console.log(`üì• Trying raw URL: ${rawUrl}`);
                        
                        const token = GITHUB_CONFIG.TOKEN;
                        const rawResponse = await fetch(rawUrl, {
                            headers: token ? { 'Authorization': `token ${token}` } : {}
                        });
                        
                        if (rawResponse.ok) {
                            const content = await rawResponse.text();
                            console.log(`‚úÖ Large file downloaded via raw URL (${content.length} chars)`);
                            return {
                                content: content,
                                sha: response.sha,
                                path: response.path
                            };
                        } else {
                            console.error(`‚ùå Raw URL fetch failed: ${rawResponse.status} ${rawResponse.statusText}`);
                        }
                    } catch (rawError) {
                        console.error('‚ùå Raw URL download failed:', rawError.message);
                    }
                    
                    // Method 3: Use Blob API endpoint for very large files
                    try {
                        if (response.sha) {
                            const blobEndpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/git/blobs/${response.sha}`;
                            console.log(`üì• Trying Blob API: ${blobEndpoint}`);
                            
                            const blobResponse = await githubApiRequest(blobEndpoint);
                            if (blobResponse.content) {
                                const content = atob(blobResponse.content.replace(/\n/g, ''));
                                console.log(`‚úÖ Large file downloaded via Blob API (${content.length} chars)`);
                                return {
                                    content: content,
                                    sha: response.sha,
                                    path: response.path
                                };
                            }
                        }
                    } catch (blobError) {
                        console.error('‚ùå Blob API download failed:', blobError.message);
                    }
                }
                
                console.warn(`‚ö†Ô∏è Could not retrieve content for: ${filePath}`);
                return null;
            } catch (error) {
                if (error.message.includes('404')) {
                    console.log(`üìÇ File not found: ${filePath}`);
                    return null; // File doesn't exist
                }
                console.error(`‚ùå Error fetching file ${filePath}:`, error);
                throw error;
            }
        }
        
        // Save file to GitHub repository
        async function saveFileToGitHub(filePath, content, message = 'Update file', sha = null) {
            try {
                const endpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filePath}`;
                
                // If no SHA provided, check if file exists and get SHA
                if (!sha) {
                    try {
                        const existingFile = await getFileFromGitHub(filePath);
                        if (existingFile && existingFile.sha) {
                            sha = existingFile.sha;
                            console.log(`üìù File exists, updating with SHA: ${sha.substring(0, 8)}...`);
                        }
                    } catch (error) {
                        // File doesn't exist, we'll create a new one
                        console.log(`üìÑ Creating new file: ${filePath}`);
                    }
                }
                
                // Encode content to base64
                const encodedContent = btoa(unescape(encodeURIComponent(content)));
                
                const data = {
                    message: message,
                    content: encodedContent,
                    branch: GITHUB_CONFIG.BRANCH
                };
                
                // Include SHA if updating existing file
                if (sha) {
                    data.sha = sha;
                }
                
                const response = await githubApiRequest(endpoint, 'PUT', data);
                console.log(`‚úÖ File saved to GitHub: ${filePath}`);
                return response;
            } catch (error) {
                console.error('GitHub save error:', error);
                throw error;
            }
        }
        
        // Delete file from GitHub repository
        async function deleteFileFromGitHub(filePath, sha, message = 'Delete file') {
            try {
                const endpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filePath}`;
                
                const data = {
                    message: message,
                    sha: sha,
                    branch: GITHUB_CONFIG.BRANCH
                };
                
                const response = await githubApiRequest(endpoint, 'DELETE', data);
                return response;
            } catch (error) {
                console.error('GitHub delete error:', error);
                throw error;
            }
        }
        
        // ============================================================================
        // GITHUB STORAGE SYSTEM
        // ============================================================================
        
        let storageMode = 'github'; // GitHub-only storage mode
        
        // Force GitHub storage mode
        localStorage.setItem('storage_mode', 'github');
        
        console.log('üíæ Storage mode: GitHub only');
        
        
        async function saveFileWithGitHubChunking(fileData, fileContent) {
            const fileId = fileData.id;
            const contentSize = fileContent.length;
            const totalChunks = Math.ceil(contentSize / CHUNK_SIZE);
            const isChunked = contentSize > CHUNK_SIZE;
            
            console.log(`üíæ Saving file "${fileData.name}" (${formatFileSize(contentSize)}) to GitHub`);
            console.log(`üìä Chunking info: size=${contentSize}, chunkSize=${CHUNK_SIZE}, totalChunks=${totalChunks}, isChunked=${isChunked}`);
            
            try {
                // Save file content (chunked if necessary) FIRST
                // This ensures chunks exist before metadata references them
                const savedChunks = [];
                
                if (!isChunked) {
                    // Single chunk
                    const chunkPath = `${GITHUB_CONFIG.DATA_PATH}chunks/${fileId}_chunk_0.txt`;
                    console.log(`üì§ Saving single chunk: ${chunkPath}`);
                    await saveFileToGitHub(chunkPath, fileContent, `Add content: ${fileData.name}`);
                    savedChunks.push(0);
                    console.log(`‚úÖ File stored as single chunk in GitHub`);
                } else {
                    // Multiple chunks - save each chunk
                    for (let i = 0; i < totalChunks; i++) {
                        const start = i * CHUNK_SIZE;
                        const end = Math.min(start + CHUNK_SIZE, contentSize);
                        const chunkData = fileContent.slice(start, end);
                        const chunkPath = `${GITHUB_CONFIG.DATA_PATH}chunks/${fileId}_chunk_${i}.txt`;
                        
                        console.log(`üì§ Saving chunk ${i + 1}/${totalChunks}: ${chunkPath} (${chunkData.length} chars)`);
                        await saveFileToGitHub(chunkPath, chunkData, `Add chunk ${i}/${totalChunks - 1}: ${fileData.name}`);
                        savedChunks.push(i);
                    }
                    console.log(`‚úÖ File "${fileData.name}" saved in ${savedChunks.length} chunks to GitHub`);
                }
                
                // Save file metadata AFTER chunks are saved
                const metadataPath = `${GITHUB_CONFIG.DATA_PATH}files/${fileId}.json`;
                const metadata = {
                    id: fileData.id,
                    name: fileData.name,
                    folder: fileData.folder,
                    size: fileData.size,
                    mimetype: fileData.mimetype,
                    uploadDate: fileData.uploadDate || new Date().toISOString(),
                    isChunked: isChunked,
                    totalChunks: totalChunks,
                    totalSize: contentSize,
                    savedChunks: savedChunks,
                    storageType: 'github',
                    createdAt: new Date().toISOString()
                };
                
                console.log(`üì§ Saving metadata: ${metadataPath}`, metadata);
                await saveFileToGitHub(metadataPath, JSON.stringify(metadata, null, 2), `Add file: ${fileData.name}`);
                
                addLog(`File saved: ${fileData.name} (${totalChunks} chunks)`, 'success');
                showAlert('‚úÖ File saved to GitHub repository successfully!', 'success');
                return true;
                
            } catch (error) {
                console.error('GitHub storage failed:', error);
                addLog(`File save failed: ${fileData.name} - ${error.message}`, 'error');
                showAlert('‚ùå GitHub save failed: ' + error.message, 'error');
                throw error;
            }
        }
        
        async function getFileFromGitHubChunks(fileInfo) {
            try {
                // Use the fileInfo object directly if it's passed, or treat as ID for backward compatibility
                let fileId, metadata;
                
                if (typeof fileInfo === 'string') {
                    // Backward compatibility - fileInfo is actually fileId
                    fileId = fileInfo;
                    
                    console.log(`üìã Loading file metadata for ID: ${fileId}`);
                    
                    // Get file metadata
                    const metadataPath = `${GITHUB_CONFIG.DATA_PATH}files/${fileId}.json`;
                    const metadataFile = await getFileFromGitHub(metadataPath);
                    
                    if (!metadataFile) {
                        throw new Error(`Metadata not found for file: ${fileId}`);
                    }
                    
                    metadata = JSON.parse(metadataFile.content);
                    console.log(`‚úÖ Loaded metadata for ${fileId}:`, {
                        name: metadata.name,
                        isChunked: metadata.isChunked,
                        totalChunks: metadata.totalChunks,
                        totalSize: metadata.totalSize,
                        originalSize: metadata.size
                    });
                } else {
                    // New usage - fileInfo is the metadata object
                    metadata = fileInfo;
                    fileId = metadata.id;
                    
                    console.log(`üìã Using provided metadata for: ${metadata.name} (ID: ${fileId})`);
                    
                    // ALWAYS load complete metadata from GitHub to ensure we have chunking info
                    console.log(`üìã Loading complete metadata from GitHub to get chunking info`);
                    const metadataPath = `${GITHUB_CONFIG.DATA_PATH}files/${fileId}.json`;
                    const metadataFile = await getFileFromGitHub(metadataPath);
                    
                    if (metadataFile) {
                        metadata = JSON.parse(metadataFile.content);
                        console.log(`‚úÖ Loaded complete metadata:`, {
                            name: metadata.name,
                            isChunked: metadata.isChunked,
                            totalChunks: metadata.totalChunks,
                            totalSize: metadata.totalSize,
                            savedChunks: metadata.savedChunks
                        });
                    } else {
                        console.warn(`‚ö†Ô∏è Could not load metadata from GitHub, using provided info`);
                    }
                }
                
                // ========== CHECK FOR INLINE DATA FIRST ==========
                // Some files store data directly in the metadata JSON (older format or small files)
                if (metadata.data && metadata.data.length > 0) {
                    console.log(`üìã File has inline data in metadata, using directly`);
                    console.log(`üìä Inline data size: ${metadata.data.length} characters`);
                    addLog(`File downloaded: ${metadata.name} (inline data)`, 'success');
                    
                    return {
                        ...metadata,
                        content: metadata.data,
                        reconstructedSize: metadata.data.length
                    };
                }
                
                // ========== NO INLINE DATA - LOAD FROM CHUNKS ==========
                // Determine if file is chunked and how many chunks
                const isChunked = metadata.isChunked || (metadata.totalChunks && metadata.totalChunks > 1);
                let totalChunks = metadata.totalChunks || 1;
                
                // If totalChunks is still 1 but we have totalSize, recalculate
                if (totalChunks === 1 && metadata.totalSize && metadata.totalSize > CHUNK_SIZE) {
                    totalChunks = Math.ceil(metadata.totalSize / CHUNK_SIZE);
                    console.log(`üìä Recalculated totalChunks from totalSize: ${totalChunks}`);
                }
                
                console.log(`üì¶ File chunking info: isChunked=${isChunked}, totalChunks=${totalChunks}`);
                
                // Get file chunks
                const chunks = [];
                let loadErrors = [];
                
                for (let i = 0; i < totalChunks; i++) {
                    const chunkPath = `${GITHUB_CONFIG.DATA_PATH}chunks/${fileId}_chunk_${i}.txt`;
                    console.log(`üì• Loading chunk ${i + 1}/${totalChunks}: ${chunkPath}`);
                    
                    try {
                        const chunkFile = await getFileFromGitHub(chunkPath);
                        
                        if (chunkFile && chunkFile.content) {
                            console.log(`‚úÖ Chunk ${i} loaded, size: ${chunkFile.content.length} characters`);
                            chunks.push({
                                index: i,
                                data: chunkFile.content
                            });
                        } else {
                            console.error(`‚ùå Failed to load chunk ${i}: no content returned`);
                            loadErrors.push(i);
                        }
                    } catch (chunkError) {
                        console.error(`‚ùå Error loading chunk ${i}:`, chunkError);
                        loadErrors.push(i);
                    }
                }
                
                if (chunks.length === 0) {
                    console.error(`‚ùå No chunks loaded for file ${fileId}. Attempted ${totalChunks} chunks.`);
                    addLog(`Download failed: No chunks found for ${metadata.name}`, 'error');
                    throw new Error(`No chunks found for file ${fileId}. The file may not have been uploaded correctly.`);
                }
                
                if (loadErrors.length > 0) {
                    console.warn(`‚ö†Ô∏è Some chunks failed to load: ${loadErrors.join(', ')}`);
                    addLog(`Warning: ${loadErrors.length} chunks failed to load for ${metadata.name}`, 'warning');
                }
                
                console.log(`üì¶ Loaded ${chunks.length}/${totalChunks} chunks`);
                
                // Sort chunks and reconstruct file
                chunks.sort((a, b) => a.index - b.index);
                const reconstructedContent = chunks.map(chunk => chunk.data).join('');
                
                console.log(`üîß Reconstructed content size: ${reconstructedContent.length} characters`);
                console.log(`üìä Expected size: ${metadata.totalSize || metadata.size || 'unknown'}`);
                
                // Verify content integrity
                if (metadata.totalSize && reconstructedContent.length !== metadata.totalSize) {
                    console.warn(`‚ö†Ô∏è Content size mismatch! Expected: ${metadata.totalSize}, Got: ${reconstructedContent.length}`);
                }
                
                addLog(`File downloaded: ${metadata.name} (${chunks.length} chunks)`, 'success');
                
                return {
                    ...metadata,
                    content: reconstructedContent,
                    reconstructedSize: reconstructedContent.length
                };
                
            } catch (error) {
                console.error('‚ùå GitHub retrieval failed:', error);
                addLog(`Download error: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function deleteFileInfoFromGitHub(fileInfo) {
            try {
                const filePaths = [];
                
                // Add metadata file
                filePaths.push(`${GITHUB_CONFIG.DATA_PATH}files/${fileInfo.id}.json`);
                
                // Add chunk files if it's a chunked file
                if (fileInfo.isChunked && fileInfo.totalChunks) {
                    for (let i = 0; i < fileInfo.totalChunks; i++) {
                        filePaths.push(`${GITHUB_CONFIG.DATA_PATH}chunks/${fileInfo.id}_chunk_${i}.txt`);
                    }
                }
                
                // Delete all files
                const deletePromises = filePaths.map(async (path) => {
                    try {
                        await deleteFileFromGitHub_internal(path, `Delete ${fileInfo.name}`);
                    } catch (error) {
                        console.warn(`Failed to delete ${path}:`, error);
                    }
                });
                
                await Promise.all(deletePromises);
                return true;
                
            } catch (error) {
                console.error('GitHub delete failed:', error);
                throw error;
            }
        }
        
        async function deleteFileFromGitHub_internal(path, message) {
            try {
                // First get the file to get its SHA
                const fileResponse = await githubApiRequest(
                    `${GITHUB_CONFIG.API_BASE}/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${path}`,
                    'GET'
                );
                
                if (!fileResponse || !fileResponse.sha) {
                    console.warn(`File not found for deletion: ${path}`);
                    return;
                }
                
                // Delete the file
                await githubApiRequest(
                    `${GITHUB_CONFIG.API_BASE}/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${path}`,
                    'DELETE',
                    {
                        message: message || `Delete ${path}`,
                        sha: fileResponse.sha
                    }
                );
                
            } catch (error) {
                if (error.message && error.message.includes('404')) {
                    console.warn(`File not found for deletion: ${path}`);
                } else {
                    throw error;
                }
            }
        }
        
        async function getGitHubFileList() {
            try {
                const filesPath = `${GITHUB_CONFIG.DATA_PATH}files`;
                console.log(`üîç Getting file list from GitHub: ${filesPath}`);
                
                // Get contents of the files directory
                const response = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filesPath}`,
                    'GET'
                );
                
                if (!response || !Array.isArray(response)) {
                    console.log('üìÅ No files directory or empty response');
                    return [];
                }
                
                console.log(`üìÅ Found ${response.length} items in files directory`);
                const fileList = [];
                
                // Process each file metadata
                for (const item of response) {
                    if (item.name.endsWith('.json') && item.type === 'file' && item.name !== '.gitkeep') {
                        try {
                            console.log(`üìã Processing metadata file: ${item.name}`);
                            
                            // Check file size - GitHub API doesn't return content for files >1MB
                            if (item.size > 1024 * 1024) { // 1MB
                                console.log(`üìã Large metadata file detected (${formatFileSize(item.size)}), using download URL`);
                                try {
                                    // Use download_url for large files
                                    const response = await fetch(item.download_url);
                                    if (response.ok) {
                                        const metadataContent = await response.text();
                                        console.log(`üìã Downloaded large metadata content for ${item.name}:`, metadataContent.substring(0, 200) + '...');
                                        
                                        const metadata = JSON.parse(metadataContent);
                                        console.log(`‚úÖ Parsed large metadata for ${item.name}:`, {
                                            name: metadata.name,
                                            folder: metadata.folder,
                                            size: metadata.size,
                                            id: metadata.id
                                        });
                                        
                                        // Ensure required fields exist
                                        if (metadata.name && metadata.folder) {
                                            fileList.push(metadata);
                                            console.log(`‚úÖ Loaded large file metadata: ${metadata.name} in folder ${metadata.folder}`);
                                        } else {
                                            console.warn(`‚ùå Missing required fields in large metadata for ${item.name}:`, metadata);
                                        }
                                    } else {
                                        console.error(`‚ùå Failed to download large metadata for ${item.name}:`, response.status);
                                    }
                                } catch (error) {
                                    console.error(`‚ùå Error processing large metadata for ${item.name}:`, error);
                                }
                            } else {
                                // Use regular GitHub API for small files
                                const metadataResponse = await githubApiRequest(item.url, 'GET');
                                console.log(`üìã Raw GitHub response for ${item.name}:`, {
                                    hasContent: !!metadataResponse?.content,
                                    contentLength: metadataResponse?.content?.length || 0,
                                    encoding: metadataResponse?.encoding,
                                    type: metadataResponse?.type,
                                    size: metadataResponse?.size
                                });
                                
                                if (metadataResponse && metadataResponse.content) {
                                    const metadataContent = atob(metadataResponse.content);
                                    console.log(`üìã Raw metadata content for ${item.name}:`, metadataContent.substring(0, 200) + '...');
                                    
                                    const metadata = JSON.parse(metadataContent);
                                    console.log(`‚úÖ Parsed metadata for ${item.name}:`, {
                                        name: metadata.name,
                                        folder: metadata.folder,
                                        size: metadata.size,
                                        id: metadata.id
                                    });
                                    
                                    // Ensure required fields exist
                                    if (metadata.name && metadata.folder) {
                                        fileList.push(metadata);
                                        console.log(`‚úÖ Loaded file metadata: ${metadata.name} in folder ${metadata.folder}`);
                                    } else {
                                        console.warn(`‚ùå Missing required fields in metadata for ${item.name}:`, metadata);
                                    }
                                } else {
                                    console.warn(`‚ùå No content in metadata response for ${item.name}`);
                                    console.log(`üìã Full response object:`, metadataResponse);
                                }
                            }
                        } catch (error) {
                            console.warn(`Failed to parse metadata for ${item.name}:`, error);
                        }
                    }
                }
                
                console.log(`üìÅ Successfully loaded ${fileList.length} files from GitHub`);
                return fileList;
                
            } catch (error) {
                if (error.message.includes('404')) {
                    console.log('üìÅ Storage directory not found, initializing...');
                    await initializeGitHubStorage();
                    return []; // Return empty array for first time setup
                }
                console.error('Failed to get GitHub file list:', error);
                return [];
            }
        }
        
        async function saveGitHubFolder(folderData) {
            try {
                const folderPath = `${GITHUB_CONFIG.DATA_PATH}folders/${folderData.id}.json`;
                const folderContent = JSON.stringify(folderData, null, 2);
                
                await saveFileToGitHub(folderPath, folderContent, `Create folder: ${folderData.name}`);
                showAlert('‚úÖ Folder saved to GitHub repository!', 'success');
                return true;
                
            } catch (error) {
                console.error('GitHub folder save failed:', error);
                showAlert('‚ö†Ô∏è GitHub folder save failed, using local storage', 'warning');
                return await saveFolder(folderData);
            }
        }
        
        async function deleteGitHubFolder(folderName) {
            try {
                // Delete folder metadata file
                const folderPath = `${GITHUB_CONFIG.DATA_PATH}folders/${folderName}.json`;
                
                try {
                    const existingFile = await getFileFromGitHub(folderPath);
                    if (existingFile && existingFile.sha) {
                        await deleteFileFromGitHub(folderPath, existingFile.sha, `Delete folder: ${folderName}`);
                        console.log(`üìÅ Folder metadata deleted: ${folderPath}`);
                    }
                } catch (error) {
                    console.warn(`Folder metadata not found: ${folderPath}`);
                }
                
                // Delete all files in this folder
                const githubFiles = await getGitHubFileList();
                const folderFiles = githubFiles.filter(f => f.folder === folderName);
                
                for (const file of folderFiles) {
                    await deleteFileInfoFromGitHub(file);
                }
                
                console.log(`‚úÖ GitHub folder "${folderName}" deleted successfully`);
                return true;
                
            } catch (error) {
                console.error('GitHub folder delete failed:', error);
                throw error;
            }
        }
        
        async function deleteFileDB(fileId) {
            try {
                const transaction = db.transaction(['files', 'chunks'], 'readwrite');
                
                // Delete file metadata
                await transaction.objectStore('files').delete(fileId);
                
                // Delete file chunks
                await deleteFileChunks(fileId);
                
                console.log(`‚úÖ File deleted from IndexedDB: ${fileId}`);
                return true;
                
            } catch (error) {
                console.error('IndexedDB file delete failed:', error);
                throw error;
            }
        }
        
        async function initializeGitHubStorage() {
            try {
                console.log('üöÄ Initializing GitHub storage structure...');
                
                // Create main storage directory with README
                const readmeContent = `# File Container Storage

This directory contains files and folders uploaded via File Container app.

## Structure
- \`files/\` - File metadata and chunked data
- \`folders/\` - Folder configurations and metadata

## Usage
- Files are automatically chunked into 20MB segments for optimal performance
- Each file has metadata stored as JSON
- Folders can have password protection

Last updated: ${new Date().toISOString()}
Generated by File Container App`;

                await saveFileToGitHub(
                    `${GITHUB_CONFIG.DATA_PATH}README.md`,
                    readmeContent,
                    'Initialize File Container storage structure'
                );

                // Create files directory with a placeholder
                const filesPlaceholder = `# Files Directory

This directory contains uploaded file metadata and data chunks.

Files are stored as JSON with the following structure:
- Metadata: File info, upload date, folder, etc.
- Data: Base64 encoded content (chunked if >20MB for large file support)

Created: ${new Date().toISOString()}`;

                await saveFileToGitHub(
                    `${GITHUB_CONFIG.DATA_PATH}files/.gitkeep`,
                    filesPlaceholder,
                    'Create files directory'
                );

                // Create folders directory with a placeholder
                const foldersPlaceholder = `# Folders Directory

This directory contains folder configurations and metadata.

Each folder is stored as JSON with:
- Folder name and ID
- Password hash (if protected)
- Creation date
- Metadata

Created: ${new Date().toISOString()}`;

                await saveFileToGitHub(
                    `${GITHUB_CONFIG.DATA_PATH}folders/.gitkeep`,
                    foldersPlaceholder,
                    'Create folders directory'
                );

                console.log('‚úÖ GitHub storage structure initialized successfully');
                showAlert('‚úÖ GitHub storage initialized! Ready to store files.', 'success');
                
                return true;
            } catch (error) {
                console.error('Failed to initialize GitHub storage:', error);
                showAlert('‚ùå Failed to initialize GitHub storage: ' + error.message, 'error');
                return false;
            }
        }
        
        async function resetStorageFolder() {
            if (!confirm('‚ö†Ô∏è WARNING: This will delete ALL stored files and folders!\n\nThis action cannot be undone. Are you sure you want to continue?')) {
                return;
            }
            
            if (!confirm('üîÑ Final confirmation: Delete entire storage folder and recreate it?\n\nAll your uploaded files and folders will be permanently lost.')) {
                return;
            }
            
            try {
                console.log('üóëÔ∏è Starting storage folder reset...');
                showAlert('üóëÔ∏è Resetting storage folder...', 'warning');
                
                // Delete entire storage directory from GitHub
                const storagePath = GITHUB_CONFIG.DATA_PATH.replace(/\/$/, ''); // Remove trailing slash
                
                try {
                    // Get current SHA of the storage directory
                    const dirResponse = await githubApiRequest(
                        `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${storagePath}`,
                        'GET'
                    );
                    
                    if (Array.isArray(dirResponse)) {
                        // Delete all files in the storage directory
                        for (const item of dirResponse) {
                            if (item.type === 'file') {
                                await githubApiRequest(
                                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${item.path}`,
                                    'DELETE',
                                    {
                                        message: 'Reset storage: Delete ' + item.name,
                                        sha: item.sha
                                    }
                                );
                            }
                        }
                        
                        // Delete subdirectories recursively
                        for (const item of dirResponse) {
                            if (item.type === 'dir') {
                                await deleteGitHubDirectory(item.path);
                            }
                        }
                    }
                    
                } catch (error) {
                    if (!error.message.includes('404')) {
                        throw error;
                    }
                    console.log('üìÅ Storage directory not found, proceeding with recreation...');
                }
                
                // Clear local IndexedDB
                if (db) {
                    try {
                        const transaction = db.transaction(['folders', 'files', 'chunks'], 'readwrite');
                        await transaction.objectStore('folders').clear();
                        await transaction.objectStore('files').clear();
                        await transaction.objectStore('chunks').clear();
                        console.log('üóëÔ∏è Local IndexedDB cleared');
                    } catch (error) {
                        console.warn('Warning: Could not clear IndexedDB:', error);
                    }
                }
                
                // Recreate storage structure
                console.log('üîÑ Recreating storage structure...');
                const success = await initializeGitHubStorage();
                
                if (success) {
                    showAlert('‚úÖ Storage folder reset successfully! All data has been cleared.', 'success');
                    
                    // Refresh the file list
                    if (typeof refreshFileList === 'function') {
                        await refreshFileList(true);
                    }
                } else {
                    showAlert('‚ö†Ô∏è Storage folder was cleared but recreation failed. You may need to initialize storage manually.', 'warning');
                }
                
            } catch (error) {
                console.error('Failed to reset storage folder:', error);
                showAlert('‚ùå Failed to reset storage folder: ' + error.message, 'error');
            }
        }
        
        // Helper function to delete GitHub directory recursively
        async function deleteGitHubDirectory(dirPath) {
            try {
                const dirResponse = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${dirPath}`,
                    'GET'
                );
                
                if (Array.isArray(dirResponse)) {
                    // Delete all files first
                    for (const item of dirResponse) {
                        if (item.type === 'file') {
                            await githubApiRequest(
                                `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${item.path}`,
                                'DELETE',
                                {
                                    message: 'Reset storage: Delete ' + item.name,
                                    sha: item.sha
                                }
                            );
                        }
                    }
                    
                    // Then delete subdirectories
                    for (const item of dirResponse) {
                        if (item.type === 'dir') {
                            await deleteGitHubDirectory(item.path);
                        }
                    }
                }
                
            } catch (error) {
                if (!error.message.includes('404')) {
                    console.warn(`Could not delete directory ${dirPath}:`, error);
                }
            }
        }
        
        async function getAllGitHubFolders() {
            try {
                const foldersPath = `${GITHUB_CONFIG.DATA_PATH}folders`;
                
                // Get contents of the folders directory
                const response = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${foldersPath}`,
                    'GET'
                );
                
                if (!response || !Array.isArray(response)) {
                    return [];
                }
                
                const folderList = [];
                
                // Process each folder metadata
                for (const item of response) {
                    if (item.name.endsWith('.json') && item.type === 'file') {
                        try {
                            const folderResponse = await githubApiRequest(item.url, 'GET');
                            if (folderResponse && folderResponse.content) {
                                const folderContent = atob(folderResponse.content);
                                const folderData = JSON.parse(folderContent);
                                folderList.push(folderData);
                            }
                        } catch (error) {
                            console.warn(`Failed to parse folder data for ${item.name}:`, error);
                        }
                    }
                }
                
                return folderList;
                
            } catch (error) {
                if (error.message.includes('404')) {
                    console.log('üìÅ Folders directory not found, will be created when first folder is added');
                    return [];
                }
                console.error('Error loading GitHub folders:', error);
                return [];
            }
        }
        
        async function getAllGitHubFiles() {
            try {
                // Similar to folders, combine sources
                const indexedFiles = await getAllFiles();
                return indexedFiles;
                
            } catch (error) {
                console.error('Error loading GitHub files:', error);
                return await getAllFiles();
            }
        }
        
        // Initialize IndexedDB
        async function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    console.log('‚úÖ IndexedDB initialized successfully');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Create folders store
                    if (!db.objectStoreNames.contains('folders')) {
                        const foldersStore = db.createObjectStore('folders', { keyPath: 'id' });
                        foldersStore.createIndex('name', 'name', { unique: true });
                    }
                    
                    // Create files store
                    if (!db.objectStoreNames.contains('files')) {
                        const filesStore = db.createObjectStore('files', { keyPath: 'id' });
                        filesStore.createIndex('folder', 'folder', { unique: false });
                        filesStore.createIndex('name', 'name', { unique: false });
                    }
                    
                    // Create chunks store for large files
                    if (!db.objectStoreNames.contains('chunks')) {
                        const chunksStore = db.createObjectStore('chunks', { keyPath: 'id' });
                        chunksStore.createIndex('fileId', 'fileId', { unique: false });
                        chunksStore.createIndex('chunkIndex', 'chunkIndex', { unique: false });
                    }
                    
                    console.log('üì¶ Database stores created');
                };
            });
        }
        
        // Real storage functions
        async function saveFolder(folderData) {
            const transaction = db.transaction(['folders'], 'readwrite');
            const store = transaction.objectStore('folders');
            return store.put(folderData);
        }
        
        async function getAllFolders() {
            const transaction = db.transaction(['folders'], 'readonly');
            const store = transaction.objectStore('folders');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function deleteFolderDB(folderId) {
            const transaction = db.transaction(['folders', 'files', 'chunks'], 'readwrite');
            
            // Delete folder
            await transaction.objectStore('folders').delete(folderId);
            
            // Delete all files in folder
            const filesStore = transaction.objectStore('files');
            const filesIndex = filesStore.index('folder');
            const filesToDelete = await new Promise((resolve, reject) => {
                const request = filesIndex.getAll(folderId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            
            // Delete files and their chunks
            for (const file of filesToDelete) {
                await filesStore.delete(file.id);
                await deleteFileChunks(file.id);
            }
        }
        
        async function saveFileWithChunking(fileData, fileContent) {
            const fileId = fileData.id;
            const contentSize = fileContent.length;
            
            console.log(`üíæ Saving file "${fileData.name}" (${formatFileSize(contentSize)})`);
            
            // Save file metadata
            const transaction = db.transaction(['files'], 'readwrite');
            await transaction.objectStore('files').put({
                ...fileData,
                isChunked: contentSize > CHUNK_SIZE,
                totalChunks: Math.ceil(contentSize / CHUNK_SIZE),
                totalSize: contentSize
            });
            
            // If file is small, store directly
            if (contentSize <= CHUNK_SIZE) {
                const chunkTransaction = db.transaction(['chunks'], 'readwrite');
                await chunkTransaction.objectStore('chunks').put({
                    id: `${fileId}_chunk_0`,
                    fileId: fileId,
                    chunkIndex: 0,
                    data: fileContent,
                    size: contentSize
                });
                console.log(`‚úÖ File stored as single chunk`);
                return true; // Return success
            }
            
            // Split large files into chunks
            const chunks = [];
            for (let i = 0; i < contentSize; i += CHUNK_SIZE) {
                const chunkData = fileContent.slice(i, i + CHUNK_SIZE);
                chunks.push({
                    id: `${fileId}_chunk_${Math.floor(i / CHUNK_SIZE)}`,
                    fileId: fileId,
                    chunkIndex: Math.floor(i / CHUNK_SIZE),
                    data: chunkData,
                    size: chunkData.length
                });
            }
            
            // Save all chunks
            const chunkTransaction = db.transaction(['chunks'], 'readwrite');
            const chunksStore = chunkTransaction.objectStore('chunks');
            for (const chunk of chunks) {
                await chunksStore.put(chunk);
            }
            
            console.log(`‚úÖ File "${fileData.name}" saved in ${chunks.length} chunks`);
            return true; // Return success
        }
        
        async function getFileWithChunks(fileId) {
            try {
                console.log(`üìã Loading file from IndexedDB: ${fileId}`);
                
                // Get file metadata
                const fileTransaction = db.transaction(['files'], 'readonly');
                const file = await new Promise((resolve, reject) => {
                    const request = fileTransaction.objectStore('files').get(fileId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                if (!file) {
                    console.error(`‚ùå File metadata not found in IndexedDB: ${fileId}`);
                    return null;
                }
                
                console.log(`‚úÖ File metadata loaded:`, {
                    name: file.name,
                    size: file.size,
                    originalSize: file.originalSize
                });
                
                // Get all chunks for this file
                const chunkTransaction = db.transaction(['chunks'], 'readonly');
                const chunksStore = chunkTransaction.objectStore('chunks');
                const chunksIndex = chunksStore.index('fileId');
                
                const chunks = await new Promise((resolve, reject) => {
                    const request = chunksIndex.getAll(fileId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                console.log(`üì¶ Found ${chunks.length} chunks in IndexedDB`);
                
                if (chunks.length === 0) {
                    console.error(`‚ùå No chunks found for file: ${fileId}`);
                    return null;
                }
                
                // Sort chunks by index and reconstruct file
                chunks.sort((a, b) => a.chunkIndex - b.chunkIndex);
                const reconstructedContent = chunks.map(chunk => {
                    console.log(`üì• Processing chunk ${chunk.chunkIndex}, size: ${chunk.data.length}`);
                    return chunk.data;
                }).join('');
                
                console.log(`üîß Reconstructed content size: ${reconstructedContent.length} characters`);
                console.log(`üìä Expected size: ${file.size || file.originalSize || 'unknown'}`);
                
                // Verify content integrity
                const expectedSize = file.size || file.originalSize;
                if (expectedSize && reconstructedContent.length !== expectedSize) {
                    console.warn(`‚ö†Ô∏è Content size mismatch! Expected: ${expectedSize}, Got: ${reconstructedContent.length}`);
                }
                
                return {
                    ...file,
                    content: reconstructedContent,
                    reconstructedSize: reconstructedContent.length
                };
                
            } catch (error) {
                console.error('‚ùå Error loading file from IndexedDB:', error);
                return null;
            }
        }
        
        async function getAllFiles() {
            const transaction = db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        
        async function deleteFileChunks(fileId) {
            const transaction = db.transaction(['chunks'], 'readwrite');
            const store = transaction.objectStore('chunks');
            const index = store.index('fileId');
            
            const chunks = await new Promise((resolve, reject) => {
                const request = index.getAll(fileId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            
            for (const chunk of chunks) {
                await store.delete(chunk.id);
            }
        }
        
        async function deleteFileComplete(fileId) {
            const transaction = db.transaction(['files', 'chunks'], 'readwrite');
            
            // Delete file metadata
            await transaction.objectStore('files').delete(fileId);
            
            // Delete all chunks
            await deleteFileChunks(fileId);
        }
        
        async function getStorageStats() {
            const [folders, files, chunks] = await Promise.all([
                getAllFolders(),
                getAllFiles(),
                new Promise((resolve, reject) => {
                    const transaction = db.transaction(['chunks'], 'readonly');
                    const request = transaction.objectStore('chunks').getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                })
            ]);
            
            const totalSize = chunks.reduce((sum, chunk) => sum + chunk.size, 0);
            const chunkedFiles = files.filter(f => f.isChunked).length;
            
            return {
                totalFolders: folders.length,
                totalFiles: files.length,
                totalChunks: chunks.length,
                totalSize: totalSize,
                chunkedFiles: chunkedFiles,
                averageChunkSize: chunks.length > 0 ? totalSize / chunks.length : 0
            };
        }

        // GitHub Configuration Functions
        function configureGitHubToken() {
            const currentToken = GITHUB_CONFIG.TOKEN;
            const tokenPreview = currentToken ? `${currentToken.substring(0, 8)}...` : 'None';
            
            const instructions = `
üîß GitHub Personal Access Token Setup:

Current Token: ${tokenPreview}

üìã Instructions:
1. Buka: https://github.com/settings/tokens
2. Click "Generate new token (classic)"
3. Set name: "File Container App"
4. Select scopes: ‚úÖ repo (full repository access)
5. Click "Generate token"
6. Copy token dan paste di bawah ini

‚ö†Ô∏è Simpan token ini dengan aman - tidak akan ditampilkan lagi!
            `;
            
            const token = prompt(instructions);
            if (token && token.trim()) {
                setGitHubToken(token.trim());
                updateTokenStatus();
            }
        }
        
        function updateTokenStatus() {
            const tokenElement = document.getElementById('tokenStatus');
            if (GITHUB_CONFIG.TOKEN) {
                const preview = `${GITHUB_CONFIG.TOKEN.substring(0, 8)}...`;
                tokenElement.innerHTML = `‚úÖ Configured (${preview})`;
                tokenElement.style.color = '#28a745';
            } else {
                tokenElement.innerHTML = '‚ùå Not configured';
                tokenElement.style.color = '#dc3545';
            }
        }
        
        function changeStorageMode() {
            // Storage mode is locked to GitHub only
            const mode = 'github';
            storageMode = mode;
            localStorage.setItem('storage_mode', mode);
            
            showAlert('üåê Storage: GitHub Only - All data stored in repository', 'info');
        }
        
        async function testGitHubConnection() {
            if (!GITHUB_CONFIG.TOKEN) {
                showAlert('‚ùå GitHub token not configured', 'error');
                return;
            }
            
            try {
                showAlert('üîÑ Testing GitHub connection...', 'info');
                
                // Test repository access
                const repoInfo = await githubApiRequest(`/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}`);
                
                // Test file creation
                const testPath = `${GITHUB_CONFIG.DATA_PATH}test/connection-test.txt`;
                const testContent = `Connection test: ${new Date().toISOString()}`;
                
                await saveFileToGitHub(testPath, testContent, 'Connection test');
                
                showAlert(`‚úÖ GitHub connection successful! Repo: ${repoInfo.full_name}`, 'success');
                
                // Clean up test file
                setTimeout(async () => {
                    try {
                        const testFile = await getFileFromGitHub(testPath);
                        if (testFile) {
                            await deleteFileFromGitHub(testPath, testFile.sha, 'Clean up connection test');
                        }
                    } catch (error) {
                        console.log('Test cleanup failed:', error);
                    }
                }, 3000);
                
            } catch (error) {
                console.error('GitHub connection test failed:', error);
                showAlert(`‚ùå GitHub connection failed: ${error.message}`, 'error');
            }
        }
        
        // Debug: Verify testGitHubConnection is defined
        console.log('üîß testGitHubConnection defined:', typeof testGitHubConnection);
        
        async function validateGitHubConfig() {
            // Auto-configure GitHub mode if token is available
            if (GITHUB_CONFIG.TOKEN && storageMode !== 'github') {
                console.log('üîß GitHub token detected, validating configuration...');
                
                try {
                    // Test GitHub connection
                    const response = await githubApiRequest(
                        `${GITHUB_CONFIG.API_BASE}/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}`,
                        'GET'
                    );
                    
                    if (response && response.name) {
                        console.log('‚úÖ GitHub configuration validated');
                    }
                } catch (error) {
                    console.error('GitHub validation failed:', error);
                    showAlert('‚ùå GitHub storage unavailable. Please check configuration.', 'error');
                    throw error; // Don't fallback to IndexedDB
                }
            } else if (!GITHUB_CONFIG.TOKEN) {
                showAlert('‚ö†Ô∏è GitHub token required for storage', 'warning');
                throw new Error('GitHub token required');
            }
        }
        
        async function validateGitHubStorage() {
            if (!GITHUB_CONFIG.TOKEN) {
                showAlert('‚ö†Ô∏è GitHub token belum dikonfigurasi. Klik "Setup GitHub Token" untuk penyimpanan persistent.', 'warning');
                return false;
            }
            
            try {
                showAlert('üîÑ Validating...', 'info');
                
                // Test repository access
                const repoResponse = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}`,
                    'GET'
                );
                
                if (!repoResponse) {
                    throw new Error('Repository not accessible');
                }
                
                // Test storage directory structure
                try {
                    await githubApiRequest(
                        `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${GITHUB_CONFIG.DATA_PATH}`,
                        'GET'
                    );
                    console.log('‚úÖ Storage directory exists');
                } catch (error) {
                    if (error.message.includes('404')) {
                        console.log('üìÅ Storage directory not found, creating...');
                        await initializeGitHubStorage();
                    } else {
                        throw error;
                    }
                }
                
                showAlert('‚úÖ Validated and ready!', 'success');
                console.log('‚úÖ GitHub storage validation completed');
                return true;
                
            } catch (error) {
                console.error('GitHub storage validation failed:', error);
                showAlert(`‚ùå GitHub storage validation failed: ${error.message}`, 'error');
                return false;
            }
        }

        // File-based storage configuration (for backward compatibility)
        const FILE_CONFIG = {
            DATA_PATH: './data/',
            INDEX_FILE: 'index.json',
            MAX_FILE_SIZE: 2 * 1024 * 1024 * 1024, // 2GB per data file
            FILE_PREFIX: 'files-',
            FILE_EXTENSION: '.json'
        };

        let currentFolder = '';
        let deleteItem = null;
        let dataIndex = null;
        let allDataFiles = [];
        let selectedFiles = [];
        
        // Navigation history for back button
        let navigationHistory = [];
        let currentHistoryIndex = -1;
        
        // View mode for file browser
        let currentViewMode = 'list'; // 'list' or 'grid'
        
        // Auto-sync and real-time features
        let autoSyncInterval = null;
        let syncInProgress = false;
        let autoSyncEnabled = true;
        let lastSyncTime = null;
        const AUTO_SYNC_INTERVAL = 5000; // 5 seconds
        const PROGRESS_UPDATE_INTERVAL = 100; // 100ms for smooth progress
        
        // Storage for progress tracking
        let currentOperations = new Map();
        let operationCounter = 0;

        // ============================================================================
        // NETWORK OPTIMIZATION AND CACHING
        // ============================================================================
        
        // Pagination and lazy loading
        const FILES_PER_PAGE = 20;
        let currentPage = 1;
        let totalFiles = 0;
        let allFilesCache = new Map(); // Cache for file metadata
        let cacheTimestamp = null;
        const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache
        
        // Incremental sync tracking
        let lastSyncHash = null;
        let incrementalMode = true; // Enable incremental loading
        
        // Network traffic optimization
        let loadedFileIds = new Set(); // Track which files have been loaded
        let pendingRequests = new Map(); // Prevent duplicate requests
        
        // Network usage tracking
        let networkStats = {
            requests: 0,
            cacheHits: 0,
            dataSaved: 0
        };

        // ============================================================================
        // TAB SYSTEM FUNCTIONS
        // ============================================================================
        
        function switchTab(tabName) {
            // Remove active class from all tab buttons and panels
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
            
            // Add active class to clicked button and corresponding panel
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Switch view mode between list and grid
        function switchView(viewMode) {
            currentViewMode = viewMode;
            
            // Update button states
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(viewMode + 'ViewBtn').classList.add('active');
            
            // Update file list class
            const fileList = document.getElementById('fileList');
            fileList.className = `file-list ${viewMode}-view`;
            
            // Save preference
            localStorage.setItem('viewMode', viewMode);
            
            // Re-render file list with new view mode
            loadFileList();
        }

        // ============================================================================
        // UTILITIES DROPDOWN FUNCTIONS
        // ============================================================================
        
        function toggleUtilitiesDropdown() {
            const dropdown = document.getElementById('utilitiesDropdown');
            dropdown.classList.toggle('show');
        }
        
        function closeUtilitiesDropdown() {
            const dropdown = document.getElementById('utilitiesDropdown');
            dropdown.classList.remove('show');
        }
        
        // Close dropdown when clicking outside
        window.onclick = function(event) {
            if (!event.target.matches('.utilities-btn') && !event.target.closest('.utilities-dropdown')) {
                closeUtilitiesDropdown();
            }
        }

        // ============================================================================
        // PUBLIC LINK FUNCTIONALITY
        // ============================================================================

        // Storage for public links
        let publicLinks = JSON.parse(localStorage.getItem('publicLinks') || '{}');

        // Create public link for file or folder
        function createPublicLink(type, id, name = '') {
            const modal = document.getElementById('publicLinkModal');
            if (!modal) {
                // Create modal if it doesn't exist
                createPublicLinkModal();
            }
            
            // Set modal data
            window.currentLinkData = {
                type: type,
                id: id,
                name: name || id,
                created: new Date().toISOString()
            };
            
            // Show modal
            document.getElementById('publicLinkModal').style.display = 'block';
            document.getElementById('linkItemName').textContent = name || id;
            document.getElementById('linkItemType').textContent = type === 'file' ? 'File' : 'Folder';
            
            // Reset form
            document.getElementById('linkExpiry').value = '24h';
            document.getElementById('linkPassword').value = '';
            document.getElementById('linkPermissions').value = 'view';
            
            // Clear previous generated link
            document.getElementById('generatedLinkSection').style.display = 'none';
        }

        // Generate the actual public link
        function generatePublicLink() {
            const expiry = document.getElementById('linkExpiry').value;
            const password = document.getElementById('linkPassword').value;
            const permissions = document.getElementById('linkPermissions').value;
            
            if (!window.currentLinkData) return;
            
            let linkId, linkData;
            
            // Check if we're in edit mode
            if (window.currentLinkData.editMode && window.currentLinkData.editLinkId) {
                // Edit existing link
                linkId = window.currentLinkData.editLinkId;
                const existingLink = publicLinks[linkId];
                
                // Calculate expiry time
                let expiryTime = null;
                if (expiry !== 'never') {
                    const duration = parseInt(expiry.slice(0, -1));
                    const unit = expiry.slice(-1);
                    const multiplier = unit === 'h' ? 3600000 : unit === 'd' ? 86400000 : 604800000; // h, d, w
                    expiryTime = Date.now() + (duration * multiplier);
                }
                
                // Update existing link data
                linkData = {
                    ...existingLink,
                    permissions: permissions,
                    password: password || null,
                    expiryTime: expiryTime
                };
                
                showAlert('üîó Public link updated successfully!', 'success');
            } else {
                // Create new link
                linkId = 'link_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                // Calculate expiry time
                let expiryTime = null;
                if (expiry !== 'never') {
                    const duration = parseInt(expiry.slice(0, -1));
                    const unit = expiry.slice(-1);
                    const multiplier = unit === 'h' ? 3600000 : unit === 'd' ? 86400000 : 604800000; // h, d, w
                    expiryTime = Date.now() + (duration * multiplier);
                }
                
                // Create link object
                linkData = {
                    id: linkId,
                    type: window.currentLinkData.type,
                    targetId: window.currentLinkData.id,
                    targetName: window.currentLinkData.name,
                    permissions: permissions,
                    password: password || null,
                    expiryTime: expiryTime,
                    created: window.currentLinkData.created,
                    accessCount: 0,
                    lastAccessed: null
                };
                
                showAlert('üîó Public link generated successfully!', 'success');
            }
            
            // Save to storage
            publicLinks[linkId] = linkData;
            localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
            
            // Generate the actual URL - ensure it points to index.html
            let baseUrl = window.location.origin + window.location.pathname;
            
            // If the pathname doesn't end with .html, ensure we point to index.html
            if (!baseUrl.endsWith('.html')) {
                // Remove trailing slash if present
                if (baseUrl.endsWith('/')) {
                    baseUrl = baseUrl.slice(0, -1);
                }
                // Add index.html
                baseUrl += '/index.html';
            }
            
            const publicUrl = `${baseUrl}?share=${linkId}`;
            
            // Show generated link
            document.getElementById('generatedLink').value = publicUrl;
            document.getElementById('generatedLinkSection').style.display = 'block';
            
            // Update stats
            updateLinkStats(linkData);
            
            showAlert('üîó Public link generated successfully!', 'success');
        }

        // Copy link to clipboard
        async function copyPublicLink() {
            const linkInput = document.getElementById('generatedLink');
            try {
                await navigator.clipboard.writeText(linkInput.value);
                showAlert('üìã Link copied to clipboard!', 'success');
            } catch (err) {
                // Fallback for older browsers
                linkInput.select();
                document.execCommand('copy');
                showAlert('üìã Link copied to clipboard!', 'success');
            }
        }

        // Generate QR code for link
        function generateQRCode() {
            const link = document.getElementById('generatedLink').value;
            if (!link) return;
            
            // Simple QR code generation using a service
            const qrContainer = document.getElementById('qrCodeContainer');
            qrContainer.innerHTML = `
                <h5>QR Code</h5>
                <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(link)}" 
                     alt="QR Code" style="max-width: 200px; border: 1px solid #ddd; border-radius: 8px;">
                <p style="margin-top: 10px; font-size: 12px; color: #666;">Scan with mobile device</p>
            `;
            qrContainer.style.display = 'block';
        }

        // Update link statistics
        function updateLinkStats(linkData) {
            const statsHtml = `
                <h5>Link Statistics</h5>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value">${linkData.accessCount}</div>
                        <div class="stat-label">Total Access</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${linkData.lastAccessed ? new Date(linkData.lastAccessed).toLocaleDateString() : 'Never'}</div>
                        <div class="stat-label">Last Accessed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${linkData.expiryTime ? new Date(linkData.expiryTime).toLocaleDateString() : 'Never'}</div>
                        <div class="stat-label">Expires</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${linkData.permissions.toUpperCase()}</div>
                        <div class="stat-label">Permissions</div>
                    </div>
                </div>
            `;
            document.getElementById('linkStats').innerHTML = statsHtml;
            document.getElementById('linkStats').style.display = 'block';
        }

        // Close public link modal
        function closePublicLinkModal() {
            document.getElementById('publicLinkModal').style.display = 'none';
            
            // Reset form and edit mode
            document.getElementById('linkExpiry').value = '24h';
            document.getElementById('linkPassword').value = '';
            document.getElementById('linkPermissions').value = 'view';
            document.getElementById('generatedLinkSection').style.display = 'none';
            document.getElementById('linkStats').style.display = 'none';
            
            window.currentLinkData = null;
        }

        // Check if shared link is accessed
        function checkSharedLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            
            if (shareId) {
                // Ensure publicLinks is loaded
                if (!publicLinks) {
                    publicLinks = JSON.parse(localStorage.getItem('publicLinks') || '{}');
                }
                
                if (publicLinks[shareId]) {
                    handleSharedLinkAccess(shareId);
                } else {
                    showAlert('‚ùå Shared link not found or invalid', 'error');
                    // Clean up URL
                    const url = new URL(window.location);
                    url.searchParams.delete('share');
                    window.history.replaceState({}, document.title, url);
                }
            }
        }

        // Handle shared link access
        function handleSharedLinkAccess(shareId) {
            const linkData = publicLinks[shareId];
            
            // Check if link is expired
            if (linkData.expiryTime && Date.now() > linkData.expiryTime) {
                showAlert('‚è∞ This shared link has expired', 'error');
                return;
            }
            
            // Check if password is required
            if (linkData.password) {
                const enteredPassword = prompt('This shared link is password protected. Please enter the password:');
                if (enteredPassword !== linkData.password) {
                    showAlert('‚ùå Incorrect password', 'error');
                    return;
                }
            }
            
            // Update access stats
            linkData.accessCount++;
            linkData.lastAccessed = Date.now();
            localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
            
            // Show shared content
            showSharedContent(linkData);
        }

        // Show shared content
        async function showSharedContent(linkData) {
            showAlert('üîó Loading shared content...', 'info');
            
            if (linkData.type === 'file') {
                // Download the shared file
                try {
                    await downloadFile(linkData.targetId);
                    showAlert(`üì• Downloading shared file: ${linkData.targetName}`, 'success');
                } catch (error) {
                    console.error('Error downloading shared file:', error);
                    showAlert('‚ùå Error downloading shared file', 'error');
                }
            } else if (linkData.type === 'folder') {
                // Navigate to shared folder
                try {
                    // For shared folders, we need to set the current folder and load it
                    const folderPath = linkData.targetId;
                    
                    // Clear URL parameters to avoid confusion
                    const url = new URL(window.location);
                    url.searchParams.delete('share');
                    window.history.replaceState({}, document.title, url);
                    
                    // Load the shared folder
                    await loadFolder(folderPath);
                    showAlert(`üìÅ Opened shared folder: ${linkData.targetName}`, 'success');
                } catch (error) {
                    console.error('Error loading shared folder:', error);
                    showAlert('‚ùå Error loading shared folder', 'error');
                }
            }
        }

        // ============================================================================
        // FILE SELECTION PREVIEW FUNCTIONS
        // ============================================================================
        
        function updateFileSelectionPreview() {
            // This function is no longer needed as upload functionality is now integrated
            // into the file browser Quick Actions
        }
        
        function getFileIcon(fileName) {
            const ext = fileName.split('.').pop().toLowerCase();
            const iconMap = {
                'pdf': 'üìÑ',
                'doc': 'üìù', 'docx': 'üìù',
                'xls': 'üìä', 'xlsx': 'üìä',
                'ppt': 'üìä', 'pptx': 'üìä',
                'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'png': 'üñºÔ∏è', 'gif': 'üñºÔ∏è',
                'mp4': 'üé•', 'avi': 'üé•', 'mov': 'üé•',
                'mp3': 'üéµ', 'wav': 'üéµ',
                'zip': 'üì¶', 'rar': 'üì¶',
                'txt': 'üìÑ',
                'js': '‚ö°', 'html': 'üåê', 'css': 'üé®'
            };
            return iconMap[ext] || 'üìÑ';
        }
        
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function removeSelectedFile(index) {
            selectedFiles.splice(index, 1);
            updateFileSelectionPreview();
        }

        // ============================================================================
        // NETWORK OPTIMIZATION AND CACHING FUNCTIONS
        // ============================================================================

        // Check if cache is still valid
        function isCacheValid() {
            return cacheTimestamp && (Date.now() - cacheTimestamp) < CACHE_DURATION;
        }

        // Clear expired cache
        function clearExpiredCache() {
            if (!isCacheValid()) {
                console.log('üóëÔ∏è Clearing expired cache');
                allFilesCache.clear();
                loadedFileIds.clear();
                cacheTimestamp = null;
                lastSyncHash = null;
            }
        }

        // Generate hash for incremental sync
        function generateFileListHash(fileList) {
            const simplified = fileList.map(f => `${f.id}:${f.uploadDate}`).sort().join('|');
            return btoa(simplified).substring(0, 16);
        }

        // Network usage tracking functions
        function trackNetworkRequest(size = 0) {
            networkStats.requests++;
            updateNetworkUsageDisplay();
        }

        function trackCacheHit(size = 0) {
            networkStats.cacheHits++;
            networkStats.dataSaved += size;
            updateNetworkUsageDisplay();
        }

        function updateNetworkUsageDisplay() {
            const requestCount = document.getElementById('requestCount');
            const cacheHits = document.getElementById('cacheHits');
            const dataSaved = document.getElementById('dataSaved');
            
            if (requestCount) requestCount.textContent = networkStats.requests;
            if (cacheHits) cacheHits.textContent = networkStats.cacheHits;
            if (dataSaved) dataSaved.textContent = formatFileSize(networkStats.dataSaved);
        }

        function resetNetworkStats() {
            networkStats = {
                requests: 0,
                cacheHits: 0,
                dataSaved: 0
            };
            updateNetworkUsageDisplay();
        }

        // Data compression utilities (simple compression for metadata)
        function compressMetadata(metadata) {
            try {
                // Remove unnecessary fields for display
                const compressed = {
                    i: metadata.id,
                    n: metadata.name,
                    f: metadata.folder,
                    s: metadata.size,
                    m: metadata.mimetype,
                    u: metadata.uploadDate,
                    h: metadata.sha,
                    c: metadata.hasContent
                };
                
                // Only include chunking info if present
                if (metadata.isChunked) {
                    compressed.ch = metadata.totalChunks;
                    compressed.ts = metadata.totalSize;
                }
                
                return compressed;
            } catch (error) {
                console.warn('Failed to compress metadata:', error);
                return metadata;
            }
        }

        function decompressMetadata(compressed) {
            try {
                const metadata = {
                    id: compressed.i || compressed.id,
                    name: compressed.n || compressed.name,
                    folder: compressed.f || compressed.folder,
                    size: compressed.s || compressed.size,
                    mimetype: compressed.m || compressed.mimetype,
                    uploadDate: compressed.u || compressed.uploadDate,
                    sha: compressed.h || compressed.sha,
                    hasContent: compressed.c !== undefined ? compressed.c : compressed.hasContent
                };
                
                // Restore chunking info if present
                if (compressed.ch) {
                    metadata.isChunked = true;
                    metadata.totalChunks = compressed.ch;
                    metadata.totalSize = compressed.ts;
                }
                
                return metadata;
            } catch (error) {
                console.warn('Failed to decompress metadata:', error);
                return compressed;
            }
        }

        // Batch operations for better performance
        async function processBatchedRequests(requests, batchSize = 5) {
            const results = [];
            
            for (let i = 0; i < requests.length; i += batchSize) {
                const batch = requests.slice(i, i + batchSize);
                const batchResults = await Promise.allSettled(batch);
                
                results.push(...batchResults.map(result => 
                    result.status === 'fulfilled' ? result.value : null
                ).filter(Boolean));
                
                // Small delay between batches to avoid rate limiting
                if (i + batchSize < requests.length) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            return results;
        }

        // Get cached file metadata
        function getCachedFile(fileId) {
            if (isCacheValid() && allFilesCache.has(fileId)) {
                console.log(`üìã Using cached metadata for: ${fileId}`);
                const file = allFilesCache.get(fileId);
                trackCacheHit(file.size || 0);
                return file;
            }
            return null;
        }

        // Cache file metadata
        function cacheFileMetadata(file) {
            allFilesCache.set(file.id, {
                ...file,
                cachedAt: Date.now()
            });
            
            if (!cacheTimestamp) {
                cacheTimestamp = Date.now();
            }
        }

        // Intelligent file list loading with pagination
        async function getOptimizedFileList(page = 1, limit = FILES_PER_PAGE, forceRefresh = false) {
            try {
                // Clear expired cache
                clearExpiredCache();
                
                // Use cache if available and not forcing refresh
                if (!forceRefresh && isCacheValid() && allFilesCache.size > 0) {
                    console.log(`üìã Using cached file list (${allFilesCache.size} files)`);
                    const cachedFiles = Array.from(allFilesCache.values());
                    const startIndex = (page - 1) * limit;
                    const endIndex = startIndex + limit;
                    
                    // Track cache usage
                    trackCacheHit(cachedFiles.length * 1024); // Estimate 1KB per file metadata
                    
                    return {
                        files: cachedFiles.slice(startIndex, endIndex),
                        totalFiles: cachedFiles.length,
                        totalPages: Math.ceil(cachedFiles.length / limit),
                        currentPage: page,
                        fromCache: true
                    };
                }

                console.log(`üîç Loading optimized file list (page ${page}, limit ${limit})`);
                
                // Get lightweight file list first (metadata only)
                const allFiles = await getGitHubFileListOptimized();
                
                // Update cache
                allFiles.forEach(file => cacheFileMetadata(file));
                
                // Generate hash for incremental sync
                const currentHash = generateFileListHash(allFiles);
                const hasChanges = lastSyncHash !== currentHash;
                lastSyncHash = currentHash;
                
                // Return paginated results
                const startIndex = (page - 1) * limit;
                const endIndex = startIndex + limit;
                
                console.log(`üìã Loaded ${allFiles.length} files, showing ${startIndex + 1}-${Math.min(endIndex, allFiles.length)}`);
                
                return {
                    files: allFiles.slice(startIndex, endIndex),
                    totalFiles: allFiles.length,
                    totalPages: Math.ceil(allFiles.length / limit),
                    currentPage: page,
                    fromCache: false,
                    hasChanges
                };
                
            } catch (error) {
                console.error('‚ùå Error in optimized file list loading:', error);
                throw error;
            }
        }

        // Optimized version of getGitHubFileList - loads only metadata, no content
        async function getGitHubFileListOptimized() {
            try {
                const filesPath = `${GITHUB_CONFIG.DATA_PATH}files`;
                console.log(`üîç Getting optimized file list from GitHub: ${filesPath}`);
                
                // Get contents of the files directory
                const response = await githubApiRequest(
                    `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${filesPath}`,
                    'GET'
                );
                
                if (!response || !Array.isArray(response)) {
                    console.log('üìÅ No files directory or empty response');
                    return [];
                }
                
                console.log(`üìÅ Found ${response.length} metadata files`);
                const fileList = [];
                
                // Process metadata files with minimal data transfer
                for (const item of response) {
                    if (item.name.endsWith('.json') && item.type === 'file' && item.name !== '.gitkeep') {
                        try {
                            // Check if we already have this file in cache
                            const fileId = item.name.replace('.json', '');
                            const cached = getCachedFile(fileId);
                            
                            if (cached && cached.sha === item.sha) {
                                // File hasn't changed, use cache
                                fileList.push(cached);
                                continue;
                            }
                            
                            // Only load metadata, not file content
                            let metadata = null;
                            
                            if (item.size > 1024 * 1024) { // 1MB
                                // For large metadata files, use download URL but only get metadata
                                console.log(`üìã Loading large metadata file efficiently: ${item.name}`);
                                const response = await fetch(item.download_url);
                                if (response.ok) {
                                    const metadataContent = await response.text();
                                    const fullMetadata = JSON.parse(metadataContent);
                                    
                                    // Extract only essential metadata, exclude heavy 'data' field
                                    metadata = {
                                        id: fullMetadata.id,
                                        name: fullMetadata.name,
                                        folder: fullMetadata.folder,
                                        size: fullMetadata.size,
                                        mimetype: fullMetadata.mimetype,
                                        uploadDate: fullMetadata.uploadDate,
                                        sha: item.sha,
                                        // Don't include 'data' field to save bandwidth
                                        hasContent: !!fullMetadata.data
                                    };
                                }
                            } else {
                                // For small files, use GitHub API
                                const metadataResponse = await githubApiRequest(item.url, 'GET');
                                if (metadataResponse && metadataResponse.content) {
                                    const metadataContent = atob(metadataResponse.content);
                                    const fullMetadata = JSON.parse(metadataContent);
                                    
                                    // Extract only essential metadata
                                    metadata = {
                                        id: fullMetadata.id,
                                        name: fullMetadata.name,
                                        folder: fullMetadata.folder,
                                        size: fullMetadata.size,
                                        mimetype: fullMetadata.mimetype,
                                        uploadDate: fullMetadata.uploadDate,
                                        sha: item.sha,
                                        hasContent: !!fullMetadata.data
                                    };
                                }
                            }
                            
                            if (metadata && metadata.name && metadata.folder) {
                                fileList.push(metadata);
                                console.log(`‚úÖ Loaded optimized metadata: ${metadata.name}`);
                            }
                            
                        } catch (error) {
                            console.warn(`Failed to parse optimized metadata for ${item.name}:`, error);
                        }
                    }
                }
                
                console.log(`üìÅ Successfully loaded ${fileList.length} files with optimized metadata`);
                return fileList;
                
            } catch (error) {
                console.error('‚ùå Error loading optimized GitHub file list:', error);
                throw error;
            }
        }

        // ============================================================================
        // REAL-TIME PROGRESS AND SYNC SYSTEM
        // ============================================================================

        // Progress Management Functions
        function createOperation(title, type = 'upload') {
            const id = ++operationCounter;
            const operation = {
                id,
                title,
                type,
                progress: 0,
                status: 'Starting...',
                startTime: Date.now()
            };
            
            currentOperations.set(id, operation);
            
            // Auto-expand sync status section when upload starts
            if (type === 'upload') {
                expandSyncStatusSection();
            }
            
            renderOperations();
            addLog(`Operation started: ${title}`, 'info');
            return id;
        }

        function updateOperation(id, progress, status) {
            const operation = currentOperations.get(id);
            if (operation) {
                operation.progress = Math.min(100, Math.max(0, progress));
                operation.status = status;
                renderOperations();
            }
        }

        function completeOperation(id, finalStatus = 'Completed') {
            const operation = currentOperations.get(id);
            if (operation) {
                operation.progress = 100;
                operation.status = finalStatus;
                renderOperations();
                addLog(`Operation completed: ${operation.title} - ${finalStatus}`, 'success');
                
                // Remove after 3 seconds
                setTimeout(() => {
                    currentOperations.delete(id);
                    renderOperations();
                    
                    // Auto-collapse sync status section when all operations complete
                    if (currentOperations.size === 0) {
                        setTimeout(() => {
                            collapseSyncStatusSection();
                        }, 2000);
                    }
                }, 3000);
            }
        }
        
        // Helper functions to expand/collapse sync status section
        function expandSyncStatusSection() {
            const section = document.getElementById('syncStatusSection');
            if (section && section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                const toggle = section.querySelector('.collapsible-toggle');
                if (toggle) toggle.textContent = '‚ñ≤';
                
                // Scroll to make it visible
                section.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        function collapseSyncStatusSection() {
            const section = document.getElementById('syncStatusSection');
            if (section && !section.classList.contains('collapsed') && currentOperations.size === 0) {
                section.classList.add('collapsed');
                const toggle = section.querySelector('.collapsible-toggle');
                if (toggle) toggle.textContent = '‚ñº';
            }
        }

        function renderOperations() {
            const container = document.getElementById('activeOperations');
            const globalProgress = document.getElementById('globalProgress');
            const globalProgressBar = document.getElementById('globalProgressFill'); // Updated to match new ID
            const globalProgressText = document.getElementById('globalProgressText');
            const syncSection = document.getElementById('syncStatusSection');
            
            // Check if elements exist before proceeding
            if (!container || !globalProgress || !globalProgressBar || !globalProgressText) {
                console.warn('‚ö†Ô∏è Progress elements not found, skipping operations render');
                return;
            }
            
            // Clear existing operations
            container.innerHTML = '';
            
            if (currentOperations.size === 0) {
                globalProgress.style.display = 'none';
                // Remove highlight from sync section
                if (syncSection) syncSection.classList.remove('has-active-operations');
                return;
            }
            
            // Show global progress and highlight sync section
            globalProgress.style.display = 'block';
            if (syncSection) syncSection.classList.add('has-active-operations');
            
            // Calculate overall progress
            let totalProgress = 0;
            let activeOperations = 0;
            
            currentOperations.forEach(operation => {
                totalProgress += operation.progress;
                activeOperations++;
                
                // Create operation UI
                const operationEl = document.createElement('div');
                operationEl.className = 'operation-item';
                operationEl.innerHTML = `
                    <div class="operation-title">${operation.title}</div>
                    <div class="operation-progress">
                        <div class="operation-progress-fill" style="width: ${operation.progress}%"></div>
                    </div>
                    <div class="operation-status">${operation.status} (${operation.progress.toFixed(1)}%)</div>
                `;
                container.appendChild(operationEl);
            });
            
            // Update global progress
            const avgProgress = activeOperations > 0 ? totalProgress / activeOperations : 0;
            globalProgressBar.style.width = `${avgProgress}%`;
            globalProgressText.textContent = `${activeOperations} active operation${activeOperations !== 1 ? 's' : ''} ‚Ä¢ ${avgProgress.toFixed(1)}%`;
        }

        // Auto-Sync Functions
        function initializeAutoSync() {
            console.log('üîÑ Initializing auto-sync system...');
            updateSyncStatus('Auto-sync files & folders enabled', false);
            
            if (autoSyncEnabled) {
                startAutoSync();
            }
        }

        function startAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
            }
            
            autoSyncInterval = setInterval(async () => {
                if (!syncInProgress && autoSyncEnabled) {
                    await performAutoSync();
                }
            }, AUTO_SYNC_INTERVAL);
            
            console.log(`üîÑ Auto-sync started with ${AUTO_SYNC_INTERVAL/1000}s interval`);
        }

        function stopAutoSync() {
            if (autoSyncInterval) {
                clearInterval(autoSyncInterval);
                autoSyncInterval = null;
            }
            console.log('‚è∏Ô∏è Auto-sync stopped');
        }

        async function performAutoSync() {
            if (syncInProgress) return;
            
            syncInProgress = true;
            updateSyncStatus('Syncing...', true);
            
            try {
                console.log('üîÑ Performing optimized auto-sync...');
                
                // Create sync operation
                const syncId = createOperation('Auto-sync files & folders', 'sync');
                
                // Check for incremental updates first
                updateOperation(syncId, 10, 'Checking for changes...');
                
                // Only refresh if cache is expired or force refresh
                const needsRefresh = !isCacheValid();
                
                if (needsRefresh) {
                    // Update file list with optimization
                    updateOperation(syncId, 30, 'Refreshing file list...');
                    await loadFileList(currentPage, false); // Don't force refresh unless needed
                    
                    // Update folder list
                    updateOperation(syncId, 60, 'Refreshing folder list...');
                    await loadFolders();
                    
                    // Update storage stats
                    updateOperation(syncId, 80, 'Updating storage statistics...');
                    await updateStorageInfo();
                } else {
                    updateOperation(syncId, 70, 'Using cached data...');
                    console.log('üìã Auto-sync using cached data, no network request needed');
                }
                
                // Complete sync
                updateOperation(syncId, 100, 'Auto-sync completed');
                completeOperation(syncId, needsRefresh ? '‚úÖ Files & folders refreshed' : 'üìã Cached data');
                
                lastSyncTime = new Date();
                updateSyncStatus('Auto-sync files & folders enabled', false);
                
                console.log(`‚úÖ Auto-sync completed successfully (${needsRefresh ? 'files & folders refreshed' : 'cached'})`);
                
            } catch (error) {
                console.error('‚ùå Auto-sync failed:', error);
                updateSyncStatus('Sync failed', false);
                // Remove annoying auto-sync popup - only show in console
                // showAlert('‚ùå Auto-sync failed: ' + error.message, 'error');
            } finally {
                syncInProgress = false;
            }
        }

        function updateSyncStatus(text, isActive) {
            const syncIcon = document.getElementById('syncIcon');
            const syncText = document.getElementById('syncText');
            const lastSyncEl = document.getElementById('lastSyncTime');
            const toggleBtn = document.getElementById('toggleAutoSync');
            
            if (syncIcon) {
                syncIcon.className = isActive ? 'sync-icon syncing' : 'sync-icon';
                syncIcon.textContent = isActive ? 'üîÑ' : (autoSyncEnabled ? 'üîÑ' : '‚è∏Ô∏è');
            }
            
            if (syncText) {
                syncText.textContent = text;
            }
            
            if (lastSyncEl && lastSyncTime) {
                const timeAgo = getTimeAgo(lastSyncTime);
                lastSyncEl.textContent = timeAgo;
            }
            
            if (toggleBtn) {
                toggleBtn.textContent = autoSyncEnabled ? 'Disable' : 'Enable';
                toggleBtn.className = autoSyncEnabled ? 'sync-toggle' : 'sync-toggle disabled';
            }
        }

        function toggleAutoSync() {
            autoSyncEnabled = !autoSyncEnabled;
            
            if (autoSyncEnabled) {
                startAutoSync();
                updateSyncStatus('Auto-sync files & folders enabled', false);
                // Remove annoying popup - status visible in UI
                // showAlert('üîÑ Auto-sync enabled', 'info');
            } else {
                stopAutoSync();
                updateSyncStatus('Auto-sync disabled', false);
                // Remove annoying popup - status visible in UI  
                // showAlert('‚è∏Ô∏è Auto-sync disabled', 'info');
            }
        }

        function toggleAutoPreview() {
            const autoPreviewToggle = document.getElementById('autoPreviewToggle');
            const isEnabled = autoPreviewToggle.checked;
            
            // Save preference to localStorage
            localStorage.setItem('autoPreviewEnabled', isEnabled);
            
            if (isEnabled) {
                showAlert('üñºÔ∏è Auto preview enabled - media will load automatically', 'info');
                // Refresh the current file list to load previews
                refreshFileList();
            } else {
                showAlert('üñºÔ∏è Auto preview disabled - click to load previews', 'info');
                // Refresh the current file list to show placeholders
                refreshFileList();
            }
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            return date.toLocaleDateString();
        }
        
        // Initialize page
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Debug: Clear potential old API cache and service workers
                console.log('üßπ Clearing caches and checking for service workers...');
                
                // Initialize auto preview setting from localStorage
                const autoPreviewEnabled = localStorage.getItem('autoPreviewEnabled') === 'true';
                const autoPreviewToggle = document.getElementById('autoPreviewToggle');
                if (autoPreviewToggle) {
                    autoPreviewToggle.checked = autoPreviewEnabled;
                }
                
                // Unregister any service workers
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (let registration of registrations) {
                        console.log('üóëÔ∏è Unregistering service worker:', registration.scope);
                        await registration.unregister();
                    }
                }
                
                // Clear application caches if available
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    for (let cacheName of cacheNames) {
                        console.log('üóëÔ∏è Deleting cache:', cacheName);
                        await caches.delete(cacheName);
                    }
                }
                
                // Override fetch to detect any old API calls
                const originalFetch = window.fetch;
                window.fetch = function(...args) {
                    const url = args[0];
                    if (typeof url === 'string' && (url.includes('/api/files') || url.includes('/api/folders'))) {
                        console.error('üö® Detected old API call to:', url);
                        console.trace('üîç Call stack:');
                        return Promise.reject(new Error('Old API endpoints disabled. Using GitHub/IndexedDB storage.'));
                    }
                    return originalFetch.apply(this, args);
                };
                
                showAlert('üöÄ Initializing...', 'info');
                addLog('Application starting...', 'info');
                
                // Check if we need to show cache clear instructions
                const lastCacheClear = localStorage.getItem('lastCacheClear');
                const now = Date.now();
                if (!lastCacheClear || (now - parseInt(lastCacheClear)) > 86400000) { // 24 hours
                    showAlert('üí° Jika mengalami error 404 API, lakukan hard refresh (Ctrl+F5)', 'warning', 5000);
                    localStorage.setItem('lastCacheClear', now.toString());
                }
                
                // Force validate GitHub configuration and storage mode
                await validateGitHubConfig();
                
                // Validate GitHub storage (required for GitHub-only mode)
                await validateGitHubStorage();
                
                await loadAllData();
                await loadFolders();
                await loadFileList();
                setupDragAndDrop();
                await updateStorageInfo();
                
                // Initialize navigation (with delay to ensure DOM elements are ready)
                setTimeout(() => {
                    updateBackButton();
                }, 100);
                
                // Initialize view mode
                const savedViewMode = localStorage.getItem('viewMode') || 'list';
                switchView(savedViewMode);
                
                // Initialize auto-sync system
                initializeAutoSync();
                
                showAlert('‚úÖ Ready! Your files are now stored', 'success');
                addLog('Application initialized successfully', 'success');
            } catch (error) {
                console.error('Initialization error:', error);
                addLog('Initialization failed: ' + error.message, 'error');
                showAlert('Error initializing storage: ' + error.message, 'error');
            }
        });

        // Load data index file
        async function loadDataIndex() {
            try {
                const response = await fetch(FILE_CONFIG.DATA_PATH + FILE_CONFIG.INDEX_FILE);
                if (!response.ok) {
                    throw new Error('Index file not found');
                }
                dataIndex = await response.json();
                console.log('Data index loaded:', dataIndex);
            } catch (error) {
                console.error('Error loading data index:', error);
                // Create default index if not exists
                dataIndex = {
                    version: "2.0",
                    lastUpdate: new Date().toISOString(),
                    dataFiles: [{
                        filename: "files-001.json",
                        fileNumber: 1,
                        currentSize: 0,
                        maxSize: FILE_CONFIG.MAX_FILE_SIZE,
                        active: true,
                        created: new Date().toISOString()
                    }],
                    totalDataFiles: 1,
                    totalFolders: 0,
                    totalFiles: 0,
                    totalSizeBytes: 0
                };
                showAlert('‚ö†Ô∏è Mode offline: Menggunakan data lokal. Data tidak akan tersimpan permanen.', 'warning');
            }
        }

        // Initialize GitHub-only storage system
        async function loadAllData() {
            try {
                // No IndexedDB initialization needed for GitHub-only mode
                await updateStorageInfo();
                console.log('‚úÖ GitHub storage system initialized');
            } catch (error) {
                console.error('‚ùå Failed to initialize GitHub storage:', error);
                showAlert('Error initializing GitHub storage: ' + error.message, 'error');
            }
        }

        // Legacy function for compatibility - replaced with IndexedDB
        async function loadAllDataFiles() {
            // No longer needed - data comes from IndexedDB
            console.log('‚ÑπÔ∏è Using IndexedDB instead of JSON files');
            return Promise.resolve();
        }

        // Get all folders from GitHub
        async function getFoldersData() {
            // This function is deprecated - use loadFolders() instead for GitHub-only storage
            return {};
        }

        // Get all files from GitHub
        async function getFilesData() {
            // This function is deprecated - use GitHub file list instead
            return [];
        }

        // Save data to appropriate JSON file
        async function saveData(newFolders = null, newFiles = null) {
            try {
                // In a real GitHub Pages environment, this would need a backend service
                // For demo purposes, we'll show what the data would look like
                
                if (newFolders !== null) {
                    // Update folders in the first data file
                    if (allDataFiles.length > 0) {
                        allDataFiles[0].data.folders = newFolders;
                    }
                }

                if (newFiles !== null) {
                    // Distribute files across data files based on size
                    await distributeFilesAcrossDataFiles(newFiles);
                }

                // Update metadata
                updateDataIndex();
                updateStorageInfo();

                showAlert('‚ö†Ô∏è Demo Mode: Data changes tidak tersimpan secara permanen. Dalam implementasi nyata, data akan disimpan ke file JSON di repository.', 'warning');
                
            } catch (error) {
                console.error('Error saving data:', error);
                showAlert('Error saving data: ' + error.message, 'error');
            }
        }

        // Wrapper functions for backward compatibility - now use IndexedDB
        async function saveFoldersData(foldersData) {
            // Convert object to array and save each folder
            for (const [folderName, folderData] of Object.entries(foldersData)) {
                await saveFolder({
                    id: folderName,
                    name: folderName,
                    ...folderData
                });
            }
        }

        async function saveFilesData(filesData) {
            try {
                console.log('üíæ Starting saveFilesData for', filesData.length, 'data files');
                
                // Use the global storageMode variable
                console.log('üìä Using storage mode:', storageMode);
                
                let allSuccessful = true;
                let totalFilesSaved = 0;
                
                // Process each data file container
                for (const dataFile of filesData) {
                    console.log(`üóÇÔ∏è Processing data file with ${dataFile.data.files.length} files`);
                    
                    // Process each file in this data container
                    for (const file of dataFile.data.files) {
                        console.log(`üíæ Saving individual file: ${file.name} (${formatFileSize(file.size)})`);
                        
                        let fileSuccess = false;
                        
                        if (storageMode === 'github') {
                            try {
                                console.log(`üíæ Attempting GitHub storage for: ${file.name}`);
                                const githubSuccess = await saveFileWithGitHubChunking(file, file.data);
                                console.log(`üíæ GitHub save result for ${file.name}:`, githubSuccess);
                                fileSuccess = githubSuccess;
                            } catch (error) {
                                console.error(`‚ùå GitHub save failed for ${file.name}:`, error);
                                if (storageMode === 'github') {
                                    allSuccessful = false;
                                    continue;
                                }
                            }
                        }
                        
                        if (!fileSuccess) {
                            console.error(`‚ùå Failed to save file: ${file.name}`);
                            allSuccessful = false;
                        } else {
                            console.log(`‚úÖ Successfully saved file: ${file.name}`);
                            totalFilesSaved++;
                        }
                    }
                }
                
                console.log(`üíæ Save operation completed. Files saved: ${totalFilesSaved}, Overall success: ${allSuccessful}`);
                return allSuccessful;
                
            } catch (error) {
                console.error('‚ùå Error in saveFilesData:', error);
                return false;
            }
        }

        // Distribute files across multiple JSON files based on size
        async function distributeFilesAcrossDataFiles(files) {
            try {
                // Clear existing files from all data files
                allDataFiles.forEach(fileData => {
                    fileData.data.files = [];
                });

                let currentFileIndex = 0;
                let currentSize = JSON.stringify(allDataFiles[currentFileIndex]?.data || {}).length;

                for (const file of files) {
                    const fileSize = JSON.stringify(file).length;
                    
                    // Check if adding this file would exceed the limit
                    if (currentSize + fileSize > FILE_CONFIG.MAX_FILE_SIZE && 
                        allDataFiles[currentFileIndex]?.data.files.length > 0) {
                        
                        // Need a new data file
                        currentFileIndex++;
                        currentSize = 0;
                        
                        // Create new data file if doesn't exist
                        if (currentFileIndex >= allDataFiles.length) {
                            await createNewDataFile(currentFileIndex + 1);
                        }
                    }

                    // Add file to current data file
                    if (allDataFiles[currentFileIndex]) {
                        allDataFiles[currentFileIndex].data.files.push(file);
                        currentSize += fileSize;
                        allDataFiles[currentFileIndex].info.currentSize = currentSize;
                    }
                }

                console.log(`Files distributed across ${currentFileIndex + 1} data files`);
                
            } catch (error) {
                console.error('Error distributing files:', error);
                throw error;
            }
        }

        // Create new data file when needed
        async function createNewDataFile(fileNumber) {
            try {
                const filename = `${FILE_CONFIG.FILE_PREFIX}${fileNumber.toString().padStart(3, '0')}${FILE_CONFIG.FILE_EXTENSION}`;
                
                const newDataFile = {
                    version: "2.0",
                    metadata: {
                        created: new Date().toISOString(),
                        lastUpdate: new Date().toISOString(),
                        fileNumber: fileNumber,
                        totalFiles: dataIndex.totalDataFiles + 1,
                        maxSizeBytes: FILE_CONFIG.MAX_FILE_SIZE,
                        currentSizeBytes: 0
                    },
                    folders: {},
                    files: []
                };

                const newFileInfo = {
                    filename: filename,
                    fileNumber: fileNumber,
                    currentSize: 0,
                    maxSize: FILE_CONFIG.MAX_FILE_SIZE,
                    active: true,
                    created: new Date().toISOString()
                };

                // Add to data index
                dataIndex.dataFiles.push(newFileInfo);
                dataIndex.totalDataFiles++;

                // Add to loaded data files
                allDataFiles.push({
                    info: newFileInfo,
                    data: newDataFile
                });

                console.log(`Created new data file: ${filename}`);
                showAlert(`üìÑ File data baru dibuat: ${filename}`, 'success');

            } catch (error) {
                console.error('Error creating new data file:', error);
                throw error;
            }
        }

        // Update data index metadata
        function updateDataIndex() {
            if (!dataIndex) return;

            const allFolders = getFoldersData();
            const allFiles = getFilesData();
            
            dataIndex.lastUpdate = new Date().toISOString();
            dataIndex.totalFolders = Object.keys(allFolders).length;
            dataIndex.totalFiles = allFiles.length;
            dataIndex.totalSizeBytes = JSON.stringify(allFiles).length;

            // Update individual file sizes
            allDataFiles.forEach((fileData, index) => {
                if (dataIndex.dataFiles[index]) {
                    dataIndex.dataFiles[index].currentSize = JSON.stringify(fileData.data).length;
                }
            });
        }

        // Simple hash function for password (client-side only)
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hash = await crypto.subtle.digest('SHA-256', data);
            return Array.from(new Uint8Array(hash))
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        // File to base64 conversion
        function fileToBase64(file, progressCallback = null) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                
                reader.onprogress = (event) => {
                    if (progressCallback && event.lengthComputable) {
                        const percentComplete = (event.loaded / event.total) * 100;
                        progressCallback(percentComplete);
                    }
                };
                
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(error);
            });
        }

        // Enhanced file to base64 with progress for large files
        async function fileToBase64WithProgress(file, fileName) {
            if (file.size > 50 * 1024 * 1024) { // Show progress for files > 50MB (with 20MB chunks)
                let progressToast = null;
                
                const progressCallback = (percent) => {
                    const message = `Memproses "${fileName}": ${Math.round(percent)}%`;
                    if (progressToast) {
                        // Update existing toast message
                        const messageDiv = progressToast.querySelector('.toast-message');
                        if (messageDiv) {
                            messageDiv.textContent = message;
                        }
                    } else {
                        progressToast = showAlert(message, 'info', 0); // Persistent toast
                    }
                };
                
                try {
                    const result = await fileToBase64(file, progressCallback);
                    
                    // Hide progress toast
                    if (progressToast) {
                        hideToast(progressToast);
                    }
                    
                    showAlert(`File "${fileName}" berhasil diproses (${formatFileSize(file.size)})`, 'success');
                    return result;
                } catch (error) {
                    if (progressToast) {
                        hideToast(progressToast);
                    }
                    throw error;
                }
            } else {
                return await fileToBase64(file);
            }
        }

        // Base64 to file download - FIXED VERSION
        function downloadBase64File(base64Data, filename) {
            try {
                console.log(`üì• Starting download for: ${filename}`);
                console.log(`üìä Base64 data length: ${base64Data.length} characters`);
                
                // Remove data URL prefix if present (e.g., "data:image/png;base64,")
                let cleanBase64 = base64Data;
                if (base64Data.includes(',')) {
                    cleanBase64 = base64Data.split(',')[1];
                    console.log(`üßπ Cleaned base64 data length: ${cleanBase64.length} characters`);
                }
                
                // Convert base64 to binary data
                const binaryString = atob(cleanBase64);
                console.log(`üî¢ Binary string length: ${binaryString.length} bytes`);
                
                // Create Uint8Array from binary string
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                console.log(`üì¶ Created Uint8Array with ${bytes.length} bytes`);
                
                // Create blob with correct MIME type
                const blob = new Blob([bytes], { type: 'application/octet-stream' });
                console.log(`üíæ Created blob with size: ${blob.size} bytes`);
                
                // Create download URL and trigger download
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                
                // Trigger download
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL object
                URL.revokeObjectURL(url);
                
                console.log(`‚úÖ Download triggered for: ${filename} (${blob.size} bytes)`);
                
            } catch (error) {
                console.error('‚ùå Error in downloadBase64File:', error);
                showAlert(`Error downloading file: ${error.message}`, 'error');
            }
        }

        // Update storage info
        async function updateStorageInfo() {
            try {
                // Get stats based on storage mode  
                let stats = { totalSize: 0, totalFiles: 0, totalFolders: 0, totalChunks: 0, chunkedFiles: 0 };
                
                if (storageMode === 'github') {
                    try {
                        const githubFiles = await getGitHubFileList();
                        const githubStats = {
                            totalFiles: githubFiles.length,
                            totalSize: githubFiles.reduce((sum, file) => sum + (file.totalSize || file.size || 0), 0),
                            totalChunks: githubFiles.reduce((sum, file) => sum + (file.totalChunks || 1), 0),
                            chunkedFiles: githubFiles.filter(file => file.isChunked).length,
                            totalFolders: new Set(githubFiles.map(file => file.folder).filter(f => f)).size
                        };
                        
                        stats = githubStats;
                    } catch (error) {
                        console.warn('Failed to get GitHub stats:', error);
                        stats = await getStorageStats();
                    }
                } else {
                    // IndexedDB only
                    stats = await getStorageStats();
                }
                
                const totalSizeBytes = stats.totalSize || 0;
                const totalSizeKB = (totalSizeBytes / 1024).toFixed(2);
                const totalSizeMB = (totalSizeBytes / (1024 * 1024)).toFixed(2);
                
                document.getElementById('storageUsed').textContent = 
                    totalSizeBytes > 1024 * 1024 ? totalSizeMB + ' MB' : totalSizeKB + ' KB';
                
                document.getElementById('fileCount').textContent = stats.totalChunks || 0;
                
                // Update storage details with current mode info
                const storageDetails = document.getElementById('storageDetails');
                const storageTypeText = storageMode === 'github' ? 'üåê GitHub Repository Storage' :
                                      'üíæ Local IndexedDB Storage';
                
                storageDetails.innerHTML = 
                    `ÔøΩ ${stats.totalFiles || 0} files dalam ${stats.totalFolders || 0} folders ‚Ä¢ ` +
                    `üì¶ ${stats.totalChunks || 0} chunks ‚Ä¢ ` +
                    `üîó ${stats.chunkedFiles || 0} chunked files ‚Ä¢ ` +
                    storageTypeText;
                
                console.log('üìä Storage Stats:', stats);
            } catch (error) {
                console.error('Error updating storage info:', error);
                document.getElementById('storageUsed').textContent = 'Error';
                document.getElementById('fileCount').textContent = '0';
            }
        }

        // Refresh data files from IndexedDB
        async function refreshDataFiles() {
            try {
                showAlert('üîÑ Refreshing files and folders...', 'success');
                await loadAllData();
                await loadFolders();
                await loadFileList();
                await updateStorageInfo();
                showAlert('‚úÖ Files and folders refreshed successfully!', 'success');
            } catch (error) {
                showAlert('Error refreshing data: ' + error.message, 'error');
            }
        }

        // Show data files list
        function showDataFilesList() {
            if (!dataIndex || !dataIndex.dataFiles) {
                showAlert('No data files information available', 'error');
                return;
            }

            let filesList = 'üìã Data Files:\n\n';
            dataIndex.dataFiles.forEach((file, index) => {
                const sizeKB = (file.currentSize / 1024).toFixed(1);
                const maxSizeKB = (file.maxSize / 1024).toFixed(0);
                const percentage = ((file.currentSize / file.maxSize) * 100).toFixed(1);
                
                filesList += `${index + 1}. ${file.filename}\n`;
                filesList += `   Size: ${sizeKB} KB / ${maxSizeKB} KB (${percentage}%)\n`;
                filesList += `   Status: ${file.active ? '‚úÖ Active' : '‚ùå Inactive'}\n`;
                filesList += `   Created: ${new Date(file.created).toLocaleString('id-ID')}\n\n`;
            });

            alert(filesList);
        }

        // Show public links manager
        function showPublicLinksManager() {
            // Create modal if it doesn't exist
            if (!document.getElementById('linksManagerModal')) {
                createLinksManagerModal();
            }
            
            // Populate and show modal
            populateLinksManager();
            document.getElementById('linksManagerModal').style.display = 'block';
        }

        // Create links manager modal
        function createLinksManagerModal() {
            const modalHtml = `
                <div id="linksManagerModal" class="links-manager-modal">
                    <div class="links-manager-content">
                        <div class="public-link-header">
                            <h3>üîó Manage Public Links</h3>
                            <button class="close-modal" onclick="closeLinksManager()">&times;</button>
                        </div>
                        
                        <div class="manager-actions">
                            <button class="btn" onclick="cleanupExpiredLinks()">üßπ Clean Expired</button>
                            <button class="btn" onclick="exportPublicLinks()">ÔøΩ Export Links</button>
                            <button class="btn btn-danger" onclick="deleteAllLinks()">üóëÔ∏è Delete All</button>
                        </div>

                        <div id="linksTableContainer">
                            <!-- Table will be populated here -->
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // Populate links manager with current links
        function populateLinksManager() {
            const container = document.getElementById('linksTableContainer');
            const links = Object.entries(publicLinks);
            
            if (links.length === 0) {
                container.innerHTML = `
                    <div class="no-links-message">
                        <h4>ÔøΩ No Public Links Found</h4>
                        <p>Create your first public link by clicking the üîó share button on any file or folder.</p>
                    </div>
                `;
                return;
            }

            let tableHtml = `
                <div class="selection-actions" id="selectionActions">
                    <span class="selected-count" id="selectedCount">0 links selected</span>
                    <div style="margin-left: auto; display: flex; gap: 10px;">
                        <button class="btn-small btn-delete-link" onclick="deleteSelectedLinks()">üóëÔ∏è Delete Selected</button>
                        <button class="btn-small btn-copy-small" onclick="exportSelectedLinks()">üì§ Export Selected</button>
                        <button class="btn-small" onclick="clearSelection()">‚ùå Clear Selection</button>
                    </div>
                </div>

                <table class="links-table">
                    <thead>
                        <tr>
                            <th class="checkbox-cell">
                                <input type="checkbox" id="selectAll" class="link-checkbox" onchange="toggleSelectAll()" title="Select All">
                            </th>
                            <th>Name</th>
                            <th>Type</th>
                            <th>Status</th>
                            <th>Access Count</th>
                            <th>Expires</th>
                            <th>Created</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            links.forEach(([linkId, link]) => {
                const isExpired = link.expiryTime && Date.now() > link.expiryTime;
                const status = isExpired ? 'expired' : 'active';
                const statusText = isExpired ? '‚è∞ Expired' : '‚úÖ Active';
                const expiry = link.expiryTime ? new Date(link.expiryTime).toLocaleDateString() : 'Never';
                const created = new Date(link.created).toLocaleDateString();
                const protection = link.password ? 'üîí' : '';
                
                // Generate the link URL
                let baseUrl = window.location.origin + window.location.pathname;
                if (!baseUrl.endsWith('.html')) {
                    if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
                    baseUrl += '/index.html';
                }
                const linkUrl = `${baseUrl}?share=${linkId}`;

                tableHtml += `
                    <tr class="link-row" data-link-id="${linkId}" onclick="showLinkStatistics('${linkId}', event)">
                        <td class="checkbox-cell">
                            <input type="checkbox" class="link-checkbox" value="${linkId}" onchange="updateSelection()" onclick="event.stopPropagation()">
                        </td>
                        <td>
                            <strong>${link.targetName}</strong> ${protection}
                            <div class="link-url">${linkUrl}</div>
                        </td>
                        <td>${link.type === 'file' ? 'üìÑ File' : 'üìÅ Folder'}</td>
                        <td><span class="link-status status-${status}">${statusText}</span></td>
                        <td>${link.accessCount}</td>
                        <td>${expiry}</td>
                        <td>${created}</td>
                        <td class="link-actions-cell" onclick="event.stopPropagation()">
                            <button class="btn-small btn-copy-small" onclick="copyLinkUrl('${linkUrl}')" title="Copy Link">üìã</button>
                            <button class="btn-small btn-edit" onclick="editPublicLink('${linkId}')" title="Edit">‚úèÔ∏è</button>
                            <button class="btn-small btn-delete-link" onclick="deletePublicLink('${linkId}')" title="Delete">üóëÔ∏è</button>
                        </td>
                    </tr>
                `;
            });

            tableHtml += `</tbody></table>
                <div class="statistics-panel" id="statisticsPanel">
                    <div class="stats-header">
                        <h4 id="statsTitle">Link Statistics</h4>
                        <button class="btn-small" onclick="hideStatistics()">‚ùå Close</button>
                    </div>
                    <div id="statisticsContent">
                        <!-- Statistics content will be populated here -->
                    </div>
                </div>
            `;
            container.innerHTML = tableHtml;
        }

        // Close links manager
        function closeLinksManager() {
            document.getElementById('linksManagerModal').style.display = 'none';
        }

        // Multi-selection functions
        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAll');
            const linkCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll)');
            
            linkCheckboxes.forEach(checkbox => {
                checkbox.checked = selectAllCheckbox.checked;
            });
            
            updateSelection();
        }

        function updateSelection() {
            const linkCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll)');
            const selectedCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll):checked');
            const selectAllCheckbox = document.getElementById('selectAll');
            const selectionActions = document.getElementById('selectionActions');
            const selectedCount = document.getElementById('selectedCount');
            
            // Update select all checkbox state
            if (selectedCheckboxes.length === 0) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = false;
            } else if (selectedCheckboxes.length === linkCheckboxes.length) {
                selectAllCheckbox.indeterminate = false;
                selectAllCheckbox.checked = true;
            } else {
                selectAllCheckbox.indeterminate = true;
            }
            
            // Update row highlighting
            document.querySelectorAll('.link-row').forEach(row => {
                const checkbox = row.querySelector('.link-checkbox');
                if (checkbox && checkbox.checked) {
                    row.classList.add('selected');
                } else {
                    row.classList.remove('selected');
                }
            });
            
            // Show/hide selection actions
            if (selectedCheckboxes.length > 0) {
                selectionActions.classList.add('show');
                selectedCount.textContent = `${selectedCheckboxes.length} link${selectedCheckboxes.length === 1 ? '' : 's'} selected`;
            } else {
                selectionActions.classList.remove('show');
            }
        }

        function clearSelection() {
            document.querySelectorAll('.link-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateSelection();
        }

        function deleteSelectedLinks() {
            const selectedCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll):checked');
            const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                showAlert('üì≠ No links selected', 'info');
                return;
            }
            
            const linkNames = selectedIds.map(id => publicLinks[id]?.targetName).filter(Boolean);
            const confirmMessage = `Are you sure you want to delete ${selectedIds.length} selected link${selectedIds.length === 1 ? '' : 's'}?\n\n${linkNames.join('\n')}\n\nThis action cannot be undone.`;
            
            if (confirm(confirmMessage)) {
                selectedIds.forEach(linkId => {
                    delete publicLinks[linkId];
                });
                
                localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
                showAlert(`üóëÔ∏è ${selectedIds.length} link${selectedIds.length === 1 ? '' : 's'} deleted successfully`, 'success');
                
                // Refresh the manager
                populateLinksManager();
            }
        }

        function exportSelectedLinks() {
            const selectedCheckboxes = document.querySelectorAll('.link-checkbox:not(#selectAll):checked');
            const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                showAlert('üì≠ No links selected', 'info');
                return;
            }
            
            const selectedLinks = selectedIds.map(id => publicLinks[id]).filter(Boolean);
            
            const exportData = {
                exportDate: new Date().toISOString(),
                totalLinks: selectedLinks.length,
                links: selectedLinks.map(link => ({
                    name: link.targetName,
                    type: link.type,
                    permissions: link.permissions,
                    hasPassword: !!link.password,
                    accessCount: link.accessCount,
                    created: link.created,
                    expires: link.expiryTime ? new Date(link.expiryTime).toISOString() : null,
                    lastAccessed: link.lastAccessed ? new Date(link.lastAccessed).toISOString() : null
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `selected-links-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert(`üì§ ${selectedLinks.length} selected link${selectedLinks.length === 1 ? '' : 's'} exported successfully`, 'success');
        }

        // Statistics functions
        function showLinkStatistics(linkId, event) {
            // Don't show statistics if clicking on checkbox or action buttons
            if (event.target.type === 'checkbox' || event.target.tagName === 'BUTTON') {
                return;
            }
            
            const link = publicLinks[linkId];
            if (!link) return;
            
            const statisticsPanel = document.getElementById('statisticsPanel');
            const statsTitle = document.getElementById('statsTitle');
            const statisticsContent = document.getElementById('statisticsContent');
            
            statsTitle.textContent = `Statistics: ${link.targetName}`;
            
            // Calculate statistics
            const now = Date.now();
            const isExpired = link.expiryTime && now > link.expiryTime;
            const daysSinceCreated = Math.floor((now - new Date(link.created).getTime()) / (1000 * 60 * 60 * 24));
            const daysUntilExpiry = link.expiryTime ? Math.floor((link.expiryTime - now) / (1000 * 60 * 60 * 24)) : null;
            
            // Generate link URL
            let baseUrl = window.location.origin + window.location.pathname;
            if (!baseUrl.endsWith('.html')) {
                if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
                baseUrl += '/index.html';
            }
            const linkUrl = `${baseUrl}?share=${linkId}`;
            
            const statsHtml = `
                <div class="stats-grid-detailed">
                    <div class="stat-card">
                        <h4>Total Access</h4>
                        <div class="value">${link.accessCount}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Link Age</h4>
                        <div class="value">${daysSinceCreated} day${daysSinceCreated === 1 ? '' : 's'}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Status</h4>
                        <div class="value" style="color: ${isExpired ? '#dc3545' : '#28a745'}">${isExpired ? 'Expired' : 'Active'}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Time to Expiry</h4>
                        <div class="value">${daysUntilExpiry !== null ? (daysUntilExpiry > 0 ? `${daysUntilExpiry} day${daysUntilExpiry === 1 ? '' : 's'}` : 'Expired') : 'Never'}</div>
                    </div>
                </div>
                
                <div class="link-details">
                    <div class="detail-row">
                        <span class="detail-label">Name:</span>
                        <span class="detail-value">${link.targetName}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Type:</span>
                        <span class="detail-value">${link.type === 'file' ? 'üìÑ File' : 'üìÅ Folder'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Permissions:</span>
                        <span class="detail-value">${link.permissions.toUpperCase()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Password Protected:</span>
                        <span class="detail-value">${link.password ? 'üîí Yes' : 'üîì No'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Created:</span>
                        <span class="detail-value">${new Date(link.created).toLocaleString()}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Last Accessed:</span>
                        <span class="detail-value">${link.lastAccessed ? new Date(link.lastAccessed).toLocaleString() : 'Never'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Expires:</span>
                        <span class="detail-value">${link.expiryTime ? new Date(link.expiryTime).toLocaleString() : 'Never expires'}</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">Link URL:</span>
                        <span class="detail-value" style="font-family: 'Courier New', monospace; font-size: 12px; word-break: break-all;">${linkUrl}</span>
                    </div>
                </div>
                
                <div style="margin-top: 15px; text-align: center;">
                    <button class="btn-copy" onclick="copyLinkUrl('${linkUrl}')">üìã Copy Link</button>
                    <button class="btn" onclick="editPublicLink('${linkId}')">‚úèÔ∏è Edit Link</button>
                </div>
            `;
            
            statisticsContent.innerHTML = statsHtml;
            statisticsPanel.classList.add('show');
            
            // Scroll to statistics panel
            statisticsPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function hideStatistics() {
            const statisticsPanel = document.getElementById('statisticsPanel');
            statisticsPanel.classList.remove('show');
        }

        // Copy link URL to clipboard
        async function copyLinkUrl(url) {
            try {
                await navigator.clipboard.writeText(url);
                showAlert('üìã Link copied to clipboard!', 'success');
            } catch (err) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = url;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showAlert('üìã Link copied to clipboard!', 'success');
            }
        }

        // Edit public link
        function editPublicLink(linkId) {
            const link = publicLinks[linkId];
            if (!link) return;

            // Close manager modal
            closeLinksManager();

            // Set up edit mode
            window.currentLinkData = {
                type: link.type,
                id: link.targetId,
                name: link.targetName,
                created: link.created,
                editMode: true,
                editLinkId: linkId
            };

            // Create or show public link modal
            if (!document.getElementById('publicLinkModal')) {
                createPublicLinkModal();
            }

            // Populate form with existing data
            document.getElementById('publicLinkModal').style.display = 'block';
            document.getElementById('linkItemName').textContent = link.targetName;
            document.getElementById('linkItemType').textContent = link.type === 'file' ? 'File' : 'Folder';
            
            // Set form values
            if (link.expiryTime) {
                const diffMs = link.expiryTime - Date.now();
                const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));
                const diffDays = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
                
                if (diffHours <= 24) {
                    document.getElementById('linkExpiry').value = diffHours <= 1 ? '1h' : '24h';
                } else if (diffDays <= 7) {
                    document.getElementById('linkExpiry').value = '7d';
                } else {
                    document.getElementById('linkExpiry').value = '30d';
                }
            } else {
                document.getElementById('linkExpiry').value = 'never';
            }
            
            document.getElementById('linkPassword').value = link.password || '';
            document.getElementById('linkPermissions').value = link.permissions;
            
            // Show existing link if available
            let baseUrl = window.location.origin + window.location.pathname;
            if (!baseUrl.endsWith('.html')) {
                if (baseUrl.endsWith('/')) baseUrl = baseUrl.slice(0, -1);
                baseUrl += '/index.html';
            }
            const linkUrl = `${baseUrl}?share=${linkId}`;
            
            document.getElementById('generatedLink').value = linkUrl;
            document.getElementById('generatedLinkSection').style.display = 'block';
            updateLinkStats(link);
        }

        // Delete public link
        function deletePublicLink(linkId) {
            const link = publicLinks[linkId];
            if (!link) return;

            if (confirm(`Are you sure you want to delete the public link for "${link.targetName}"?\n\nThis action cannot be undone.`)) {
                delete publicLinks[linkId];
                localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
                showAlert('üóëÔ∏è Public link deleted successfully', 'success');
                
                // Refresh the manager
                populateLinksManager();
            }
        }

        // Delete all public links
        function deleteAllLinks() {
            const linkCount = Object.keys(publicLinks).length;
            if (linkCount === 0) {
                showAlert('üì≠ No links to delete', 'info');
                return;
            }

            if (confirm(`Are you sure you want to delete ALL ${linkCount} public links?\n\nThis action cannot be undone.`)) {
                publicLinks = {};
                localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
                showAlert(`üóëÔ∏è All ${linkCount} public links deleted`, 'success');
                
                // Refresh the manager
                populateLinksManager();
            }
        }

        // Export public links
        function exportPublicLinks() {
            const links = Object.values(publicLinks);
            if (links.length === 0) {
                showAlert('üì≠ No links to export', 'info');
                return;
            }

            const exportData = {
                exportDate: new Date().toISOString(),
                totalLinks: links.length,
                links: links.map(link => ({
                    name: link.targetName,
                    type: link.type,
                    permissions: link.permissions,
                    hasPassword: !!link.password,
                    accessCount: link.accessCount,
                    created: link.created,
                    expires: link.expiryTime ? new Date(link.expiryTime).toISOString() : null,
                    lastAccessed: link.lastAccessed ? new Date(link.lastAccessed).toISOString() : null
                }))
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `public-links-export-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showAlert('üì§ Public links exported successfully', 'success');
        }

        // Clean up expired public links
        function cleanupExpiredLinks() {
            const currentTime = Date.now();
            let removedCount = 0;
            
            Object.keys(publicLinks).forEach(linkId => {
                const link = publicLinks[linkId];
                if (link.expiryTime && currentTime > link.expiryTime) {
                    delete publicLinks[linkId];
                    removedCount++;
                }
            });
            
            localStorage.setItem('publicLinks', JSON.stringify(publicLinks));
            
            if (removedCount > 0) {
                showAlert(`üßπ Cleaned up ${removedCount} expired link(s)`, 'success');
            } else {
                showAlert('‚ú® No expired links found', 'info');
            }
        }

        // Load folders for dropdown
        async function loadFolders() {
            try {
                let foldersData = {};
                
                // Load folders directly from GitHub storage/folders directory
                console.log('üìÅ Loading folders from GitHub...');
                const foldersEndpoint = `/repos/${GITHUB_CONFIG.OWNER}/${GITHUB_CONFIG.REPO}/contents/${GITHUB_CONFIG.DATA_PATH}folders`;
                const folderFiles = await githubApiRequest(foldersEndpoint);
                
                if (Array.isArray(folderFiles)) {
                    for (const folderFile of folderFiles) {
                        if (folderFile.name.endsWith('.json') && folderFile.name !== '.gitkeep') {
                            try {
                                const folderContent = await getFileFromGitHub(folderFile.path);
                                if (folderContent && folderContent.content) {
                                    // Handle both base64 and plain text content
                                    let jsonContent;
                                    try {
                                        // Try base64 decode first
                                        jsonContent = atob(folderContent.content);
                                    } catch (atobError) {
                                        // If base64 fails, content might already be plain text
                                        jsonContent = folderContent.content;
                                    }
                                    
                                    const folderData = JSON.parse(jsonContent);
                                    foldersData[folderData.name] = folderData;
                                    console.log(`üìÅ Loaded folder: ${folderData.name}`);
                                }
                            } catch (error) {
                                console.warn(`Failed to load folder file ${folderFile.name}:`, error);
                            }
                        }
                    }
                }
                
                console.log(`üìÅ Loaded ${Object.keys(foldersData).length} folders from GitHub`);
                
                // Also check for folders from files (fallback method)
                const githubFiles = await getGitHubFileList();
                const folderSet = new Set();
                githubFiles.forEach(file => {
                    if (file.folder && !folderSet.has(file.folder) && !foldersData[file.folder]) {
                        folderSet.add(file.folder);
                        foldersData[file.folder] = {
                            id: file.folder,
                            name: file.folder,
                            createdAt: file.uploadDate || new Date().toISOString(),
                            password: '' // GitHub mode doesn't use folder passwords yet
                        };
                    }
                });
                
                // Note: targetFolder dropdown no longer exists - upload is now integrated in file browser
                const folders = Object.keys(foldersData);
                
                console.log(`üìÅ Total folders loaded: ${folders.length}`);
                return foldersData;
                
            } catch (error) {
                console.error('Error loading folders:', error);
                // Note: targetFolder dropdown no longer exists - upload is now integrated in file browser
                throw error;
            }
        }

        // Update parent folder dropdown (legacy function - no longer used)
        async function updateParentFolderDropdown() {
            // Note: This function is kept for backward compatibility but the parentFolder dropdown
            // no longer exists in the current UI - folder creation is now inline in file browser
        }

        // Upload files
        // Export all data
        async function exportAllData() {
            try {
                const exportData = {
                    version: "2.0",
                    exportDate: new Date().toISOString(),
                    dataIndex: dataIndex,
                    allFolders: await getFoldersData(),
                    allFiles: await getFilesData(),
                    dataFiles: allDataFiles.map(fileData => ({
                        info: fileData.info,
                        data: fileData.data
                    }))
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `file-container-complete-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                const sizeKB = (dataBlob.size / 1024).toFixed(1);
                showAlert(`‚úÖ Complete backup exported! Size: ${sizeKB} KB`, 'success');
                
            } catch (error) {
                showAlert('Error exporting data: ' + error.message, 'error');
            }
        }

        // Import data
        async function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (importedData.version === "2.0" && importedData.dataIndex) {
                        // Complete backup format
                        if (confirm('Import complete backup? This will replace all current data.')) {
                            dataIndex = importedData.dataIndex;
                            allDataFiles = importedData.dataFiles || [];
                            
                            await loadFolders();
                            await loadFileList();
                            await updateStorageInfo();
                            
                            showAlert(`‚úÖ Complete backup imported! ${importedData.allFiles?.length || 0} files restored.`, 'success');
                        }
                    } else if (importedData.folders && importedData.files) {
                        // Legacy format
                        if (confirm('Import legacy data? This will be merged with current data.')) {
                            const currentFolders = await getFoldersData();
                            const currentFiles = await getFilesData();
                            
                            const mergedFolders = { ...currentFolders, ...importedData.folders };
                            const mergedFiles = [...currentFiles, ...importedData.files];
                            
                            await saveData(mergedFolders, mergedFiles);
                            
                            showAlert('‚úÖ Legacy data imported and merged!', 'success');
                        }
                    } else {
                        showAlert('‚ùå Invalid file format!', 'error');
                    }
                } catch (error) {
                    showAlert('Error importing data: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // Confirm delete
        async function confirmDelete() {
            if (!deleteItem) return;

            const password = document.getElementById('deletePassword').value;

            try {
                let foldersData = {};
                
                // Get folders data from GitHub
                const githubFolders = await getAllGitHubFolders();
                githubFolders.forEach(folder => {
                    foldersData[folder.name] = folder;
                });
                
                const hashedPassword = password ? await hashPassword(password) : null;

                if (deleteItem.type === 'folder') {
                    // Delete folder
                    let folderExists = false;
                    let passwordValid = false;
                    
                    // Check if folder exists and verify password
                    if (foldersData[deleteItem.name]) {
                        folderExists = true;
                        const folderPassword = foldersData[deleteItem.name].password;
                        // Password valid if: folder has no password, or password matches
                        passwordValid = !folderPassword || hashedPassword === folderPassword;
                    }
                    
                    if (!folderExists) {
                        showAlert('Folder tidak ditemukan', 'error');
                        return;
                    }
                    
                    if (!passwordValid) {
                        showAlert('Sandi salah', 'error');
                        return;
                    }
                    
                    // Delete from GitHub
                    try {
                        await deleteGitHubFolder(deleteItem.name);
                        console.log('‚úÖ Folder deleted from GitHub');
                    } catch (error) {
                        console.error('Failed to delete from GitHub:', error);
                        throw error;
                    }
                    
                    showAlert(`‚úÖ Folder "${deleteItem.name}" berhasil dihapus!`, 'success');
                    await loadFolders();
                    await loadFileList();
                    
                } else if (deleteItem.type === 'file') {
                    // Delete file
                    let folderExists = false;
                    let passwordValid = false;
                    
                    if (foldersData[deleteItem.folder]) {
                        folderExists = true;
                        const folderPassword = foldersData[deleteItem.folder].password;
                        // Password valid if: folder has no password, or password matches
                        passwordValid = !folderPassword || hashedPassword === folderPassword;
                    } else {
                        // If folder doesn't exist in foldersData, allow deletion (orphan file)
                        folderExists = true;
                        passwordValid = true;
                    }
                    
                    if (!folderExists) {
                        showAlert('Folder tidak ditemukan', 'error');
                        return;
                    }
                    
                    if (!passwordValid) {
                        showAlert('Sandi salah', 'error');
                        return;
                    }
                    
                    // Delete from GitHub
                    try {
                        // Find and delete from GitHub
                        const githubFiles = await getGitHubFileList();
                        const targetFile = githubFiles.find(f => f.id === deleteItem.fileId);
                        
                        if (targetFile) {
                            await deleteFileInfoFromGitHub(targetFile);
                            console.log('‚úÖ File deleted from GitHub');
                        }
                    } catch (error) {
                        console.error('Failed to delete from GitHub:', error);
                        throw error;
                    }
                    
                    showAlert(`‚úÖ File "${deleteItem.name}" berhasil dihapus!`, 'success');
                }
                
                closeDeleteModal();
                loadFileList();
                
            } catch (error) {
                showAlert('Error deleting: ' + error.message, 'error');
            }
        }

        // ============================================================================
        // UPLOAD AND FOLDER CREATION FUNCTIONS
        // ============================================================================

        // Upload files function


        // ============================================================================
        // QUICK ACTIONS IN FILE BROWSER
        // ============================================================================

        // Variables for quick actions
        let quickSelectedFiles = [];

        // Trigger file upload
        function triggerFileUpload() {
            document.getElementById('quickFileInput').click();
        }

        // Trigger folder upload
        function triggerFolderUpload() {
            document.getElementById('quickFolderInput').click();
        }

        // Handle quick file upload
        async function handleQuickFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            quickSelectedFiles = files;
            updateQuickFileSelectionPreview();
            event.target.value = ''; // Clear input for next use
        }

        // Handle quick folder upload
        async function handleQuickFolderUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            try {
                await uploadFolderStructure(files);
                event.target.value = ''; // Clear input for next use
            } catch (error) {
                console.error('Folder upload error:', error);
                showAlert('Folder upload failed: ' + error.message, 'error');
            }
        }

        // Upload folder structure (maintains folder hierarchy)
        async function uploadFolderStructure(files) {
            const uploadId = createOperation(`Uploading folder structure (${files.length} files)`, 'upload');

            try {
                updateOperation(uploadId, 5, 'Analyzing folder structure...');

                // Group files by their folder paths
                const folderStructure = {};
                files.forEach(file => {
                    const pathParts = file.webkitRelativePath.split('/');
                    const folderPath = pathParts.slice(0, -1).join('/');
                    const targetFolder = currentFolder ? `${currentFolder}/${folderPath}` : folderPath;

                    if (!folderStructure[targetFolder]) {
                        folderStructure[targetFolder] = [];
                    }
                    folderStructure[targetFolder].push(file);
                });

                updateOperation(uploadId, 10, 'Creating folder structure...');

                // Create folders first
                const foldersToCreate = Object.keys(folderStructure).filter(path => path !== '');
                for (let i = 0; i < foldersToCreate.length; i++) {
                    const folderPath = foldersToCreate[i];
                    const progress = 10 + (i / foldersToCreate.length) * 20;
                    updateOperation(uploadId, progress, `Creating folder: ${folderPath}`);

                    // Create folder if it doesn't exist
                    try {
                        const folderData = {
                            id: folderPath,
                            name: folderPath,
                            displayName: folderPath.split('/').pop(),
                            parentFolder: folderPath.includes('/') ? folderPath.split('/').slice(0, -1).join('/') : (currentFolder || ''),
                            password: null,
                            createdAt: new Date().toISOString()
                        };

                        if (storageMode === 'github') {
                            const existingFolders = await getAllGitHubFolders();
                            if (!existingFolders.some(f => f.name === folderPath)) {
                                await saveGitHubFolder(folderData);
                            }
                        } else {
                            const localFolders = await getFoldersData();
                            if (!localFolders[folderPath]) {
                                await saveFolder(folderData);
                            }
                        }
                    } catch (error) {
                        console.warn(`Failed to create folder ${folderPath}:`, error);
                    }
                }

                updateOperation(uploadId, 30, 'Uploading files...');

                // Upload files
                const allFiles = Object.values(folderStructure).flat();
                await uploadFilesToFolders(allFiles, folderStructure, uploadId);

                updateOperation(uploadId, 95, 'Refreshing file list...');
                await loadFolders();
                await loadFileList();

                updateOperation(uploadId, 100, 'Folder upload completed');
                completeOperation(uploadId, `‚úÖ Folder structure uploaded (${files.length} files)`);
                showAlert(`‚úÖ Folder structure uploaded successfully! ${files.length} files processed.`, 'success');

            } catch (error) {
                console.error('Error uploading folder structure:', error);
                completeOperation(uploadId, '‚ùå Folder upload failed');
                showAlert('Error uploading folder structure: ' + error.message, 'error');
            }
        }

        // Upload files to their respective folders
        async function uploadFilesToFolders(files, folderStructure, uploadId) {
            const allDataFiles = [];
            allDataFiles.push({
                filename: `fileData_${Date.now()}.json`,
                data: { files: [] }
            });

            let processedFiles = 0;
            for (const [folderPath, folderFiles] of Object.entries(folderStructure)) {
                for (const file of folderFiles) {
                    const progress = 30 + (processedFiles / files.length) * 60;
                    updateOperation(uploadId, progress, `Uploading: ${file.name}`);

                    const base64Data = await fileToBase64WithProgress(file, file.name);
                    const fileInfo = {
                        id: Date.now() + Math.random().toString(36).substr(2, 9),
                        name: file.name,
                        folder: folderPath || currentFolder || 'default',
                        size: file.size,
                        mimetype: file.type,
                        uploadDate: new Date().toISOString(),
                        data: base64Data
                    };

                    allDataFiles[0].data.files.push(fileInfo);
                    processedFiles++;
                }
            }

            updateOperation(uploadId, 90, 'Saving to storage...');
            const saveSuccess = await saveFilesData(allDataFiles);
            if (!saveSuccess) {
                throw new Error('Failed to save files to storage');
            }
        }

        // Update quick file selection preview
        function updateQuickFileSelectionPreview() {
            const previewArea = document.getElementById('quickSelectedFilesPreview');
            const filesList = document.getElementById('quickSelectedFilesList');

            if (quickSelectedFiles.length === 0) {
                previewArea.style.display = 'none';
                return;
            }

            previewArea.style.display = 'block';
            filesList.innerHTML = '';

            quickSelectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'selected-file-item';
                fileItem.style.cssText = 'display: flex; align-items: center; padding: 8px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 5px; background: white;';

                const fileIcon = getFileIcon(file.name);
                const fileSize = formatFileSize(file.size);

                fileItem.innerHTML = `
                    <div style="margin-right: 10px; font-size: 20px;">${fileIcon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: bold; margin-bottom: 2px;">${file.name}</div>
                        <div style="font-size: 0.9em; color: #666;">${fileSize}</div>
                    </div>
                    <button onclick="removeQuickSelectedFile(${index})" style="background: #dc3545; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer;">‚úï</button>
                `;

                filesList.appendChild(fileItem);
            });
        }

        // Remove file from quick selection
        function removeQuickSelectedFile(index) {
            quickSelectedFiles.splice(index, 1);
            updateQuickFileSelectionPreview();
        }

        // Upload selected files to current folder
        async function uploadSelectedFiles() {
            if (quickSelectedFiles.length === 0) {
                showAlert('No files selected', 'error');
                return;
            }

            const targetFolder = currentFolder || 'default';
            const uploadId = createOperation(`Uploading ${quickSelectedFiles.length} file${quickSelectedFiles.length !== 1 ? 's' : ''}`, 'upload');

            try {
                updateOperation(uploadId, 10, 'Processing files...');

                const allDataFiles = [];
                allDataFiles.push({
                    filename: `fileData_${Date.now()}.json`,
                    data: { files: [] }
                });

                for (let i = 0; i < quickSelectedFiles.length; i++) {
                    const file = quickSelectedFiles[i];
                    const progress = 10 + (i / quickSelectedFiles.length) * 70;

                    updateOperation(uploadId, progress, `Processing: ${file.name}`);

                    const base64Data = await fileToBase64WithProgress(file, file.name);
                    const fileInfo = {
                        id: Date.now() + Math.random().toString(36).substr(2, 9),
                        name: file.name,
                        folder: targetFolder,
                        size: file.size,
                        mimetype: file.type,
                        uploadDate: new Date().toISOString(),
                        data: base64Data
                    };

                    allDataFiles[0].data.files.push(fileInfo);
                }

                updateOperation(uploadId, 80, 'Saving to storage...');
                const saveSuccess = await saveFilesData(allDataFiles);

                if (!saveSuccess) {
                    throw new Error('Failed to save files to storage');
                }

                updateOperation(uploadId, 95, 'Refreshing file list...');
                await loadFileList();
                await updateStorageInfo();

                // Save file count before clearing
                const uploadedFileCount = quickSelectedFiles.length;
                
                clearFileSelection();

                updateOperation(uploadId, 100, 'Upload completed');
                completeOperation(uploadId, `‚úÖ ${uploadedFileCount} files uploaded`);
                showAlert(`‚úÖ ${uploadedFileCount} file(s) uploaded successfully!`, 'success');

            } catch (error) {
                console.error('Upload error:', error);
                completeOperation(uploadId, '‚ùå Upload failed');
                showAlert('Upload failed: ' + error.message, 'error');
            }
        }

        // Clear file selection
        function clearFileSelection() {
            quickSelectedFiles = [];
            updateQuickFileSelectionPreview();
        }

        // Show create folder dialog
        function showCreateFolderDialog() {
            document.getElementById('createFolderDialog').style.display = 'block';
            document.getElementById('quickFolderName').focus();
        }

        // Hide create folder dialog
        function hideCreateFolderDialog() {
            document.getElementById('createFolderDialog').style.display = 'none';
            document.getElementById('quickFolderName').value = '';
            document.getElementById('quickFolderPassword').value = '';
        }

        // Create folder in browser
        async function createFolderInBrowser() {
            const name = document.getElementById('quickFolderName').value.trim();
            const password = document.getElementById('quickFolderPassword').value;

            if (!name) {
                showAlert('Folder name cannot be empty', 'error');
                return;
            }

            const sanitizedName = name.replace(/[^a-zA-Z0-9\-_\s]/g, '').trim();
            if (!sanitizedName) {
                showAlert('Invalid folder name', 'error');
                return;
            }

            // Create full folder path for subfolder
            const fullFolderPath = currentFolder ? `${currentFolder}/${sanitizedName}` : sanitizedName;

            try {
                // Check if folder already exists
                const githubFolders = await getAllGitHubFolders();
                const folderExists = githubFolders.some(folder => folder.name === fullFolderPath);

                if (folderExists) {
                    showAlert('Folder already exists', 'error');
                    return;
                }

                // Hash password only if provided
                let hashedPassword = null;
                if (password && password.trim()) {
                    hashedPassword = await hashPassword(password);
                }

                // Create folder data
                const folderData = {
                    id: fullFolderPath,
                    name: fullFolderPath,
                    displayName: sanitizedName,
                    parentFolder: currentFolder || '',
                    password: hashedPassword,
                    createdAt: new Date().toISOString()
                };

                // Save folder to GitHub
                await saveGitHubFolder(folderData);

                // Refresh lists
                await loadFolders();
                await loadFileList();

                hideCreateFolderDialog();

                const passwordText = hashedPassword ? 'with password' : 'without password';
                showAlert(`‚úÖ Folder "${sanitizedName}" created ${passwordText}!`, 'success');

            } catch (error) {
                console.error('Error creating folder:', error);
                showAlert('Error creating folder: ' + error.message, 'error');
            }
        }

        // Event listeners for upload functionality
        document.addEventListener('DOMContentLoaded', function() {
            // File input change handler
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(event) {
                    selectedFiles = Array.from(event.target.files);
                    updateFileSelectionPreview();
                });
            }
            
            // Target folder change handler
            const targetFolder = document.getElementById('targetFolder');
            if (targetFolder) {
                targetFolder.addEventListener('change', updateUploadButton);
            }
        });

        // Drag and drop functionality
        function setupDragAndDrop() {
            const fileSelectionArea = document.getElementById('fileSelectionArea');
            if (!fileSelectionArea) return;
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                fileSelectionArea.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                fileSelectionArea.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                fileSelectionArea.addEventListener(eventName, unhighlight, false);
            });

            function highlight() {
                fileSelectionArea.classList.add('dragover');
            }

            function unhighlight() {
                fileSelectionArea.classList.remove('dragover');
            }

            fileSelectionArea.addEventListener('drop', handleDrop, false);

            function handleDrop(e) {
                const dt = e.dataTransfer;
                selectedFiles = Array.from(dt.files);
                updateFileSelectionPreview();
            }
        }

        // Load file list with optimization and pagination
        async function loadFileList(page = null, forceRefresh = false) {
            try {
                const loadingStatus = document.getElementById('loadingStatus');
                const cacheInfo = document.getElementById('cacheInfo');
                const paginationContainer = document.getElementById('paginationContainer');
                
                // Show loading status
                loadingStatus.style.display = 'block';
                cacheInfo.textContent = forceRefresh ? 'Force refreshing...' : 'Loading...';
                
                console.log(`üìã Loading optimized file list for storage mode: ${storageMode}`);
                let foldersData = {};
                let filesData = [];
                
                // Load from GitHub repository with optimization
                try {
                    console.log(`üîç Loading files from GitHub with optimization...`);
                    const pageToLoad = page || currentPage;
                    const result = await getOptimizedFileList(pageToLoad, FILES_PER_PAGE, forceRefresh);
                    
                    filesData = result.files;
                    totalFiles = result.totalFiles;
                    currentPage = result.currentPage;
                    
                    // Update cache info
                    cacheInfo.textContent = result.fromCache ? 
                        `üìã From cache (${result.totalFiles} files)` : 
                        `üîÑ Fresh data (${result.totalFiles} files)`;
                    
                    console.log(`üìÅ Loaded ${filesData.length} files from GitHub (page ${currentPage})`);
                    
                    // Build folders data from all cached files
                    const folderSet = new Set();
                    Array.from(allFilesCache.values()).forEach(file => {
                        if (file.folder && !folderSet.has(file.folder)) {
                            folderSet.add(file.folder);
                            foldersData[file.folder] = {
                                id: file.folder,
                                name: file.folder,
                                createdAt: file.uploadDate || new Date().toISOString()
                            };
                        }
                    });
                    
                    // IMPORTANT: Also load folders from GitHub storage/folders directory
                    // This ensures folders without files are also shown
                    try {
                        const githubFolders = await getAllGitHubFolders();
                        console.log(`üìÅ Loaded ${githubFolders.length} folders from GitHub storage`);
                        
                        githubFolders.forEach(folder => {
                            // Add folder if not already in foldersData, or update with more complete data
                            if (!foldersData[folder.name] || !foldersData[folder.name].id) {
                                foldersData[folder.name] = {
                                    id: folder.id || folder.name,
                                    name: folder.name,
                                    displayName: folder.displayName || folder.name.split('/').pop(),
                                    parentFolder: folder.parentFolder || '',
                                    password: folder.password || null,
                                    createdAt: folder.createdAt || new Date().toISOString()
                                };
                            } else {
                                // Merge with existing data, preferring GitHub folder data
                                foldersData[folder.name] = {
                                    ...foldersData[folder.name],
                                    id: folder.id || folder.name,
                                    displayName: folder.displayName || folder.name.split('/').pop(),
                                    parentFolder: folder.parentFolder || foldersData[folder.name].parentFolder || '',
                                    password: folder.password || null
                                };
                            }
                        });
                        
                        addLog(`Loaded ${githubFolders.length} folders from storage`, 'info');
                    } catch (folderError) {
                        console.warn('‚ö†Ô∏è Could not load folders from GitHub storage:', folderError);
                        addLog('Warning: Could not load folders from storage', 'warning');
                    }
                    
                    // Update pagination UI
                    updatePaginationUI(result);
                    
                } catch (error) {
                    console.error('Failed to load from GitHub:', error);
                    throw error;
                }
                
                
                // Hide loading status
                loadingStatus.style.display = 'none';
                
                // Render the file list with current data
                await renderFileListOptimized(foldersData, filesData);
                
                // Show pagination if we have files
                if (totalFiles > FILES_PER_PAGE) {
                    paginationContainer.style.display = 'block';
                } else {
                    paginationContainer.style.display = 'none';
                }
                
                console.log(`‚úÖ File list loaded successfully (${filesData.length} files shown)`);
            } catch (error) {
                console.error('‚ùå Error loading file list:', error);
                document.getElementById('loadingStatus').style.display = 'none';
                showAlert('Error loading files: ' + error.message, 'error');
            }
        }

        // Optimized rendering function for file list
        async function renderFileListOptimized(foldersData, filesData) {
            try {
                const fileList = document.getElementById('fileList');
                fileList.innerHTML = '';

                // Update breadcrumb
                updateBreadcrumb();
                
                console.log(`üîç Rendering folders. Current folder: "${currentFolder}", Total folders: ${Object.keys(foldersData).length}`);

                // Show folders based on current location
                let folders = [];
                if (!currentFolder) {
                    // Show root folders (folders with no parent or empty parentFolder)
                    // Also include folders that don't have a "/" in their name (simple root folders)
                    folders = Object.keys(foldersData).filter(folderName => {
                        const folderData = foldersData[folderName];
                        const hasNoParent = !folderData.parentFolder || folderData.parentFolder === '';
                        const isSimpleRootFolder = !folderName.includes('/');
                        return hasNoParent || isSimpleRootFolder;
                    });
                } else {
                    // Show subfolders that belong to current folder
                    folders = Object.keys(foldersData).filter(folderName => {
                        const folderData = foldersData[folderName];
                        // Check if this folder's parent matches current folder
                        // Or if the folder name starts with currentFolder/ (nested path)
                        const matchesParent = folderData.parentFolder === currentFolder;
                        const isDirectChild = folderName.startsWith(currentFolder + '/') && 
                                             folderName.split('/').length === currentFolder.split('/').length + 1;
                        return matchesParent || isDirectChild;
                    });
                }
                
                console.log(`üìÅ Displaying ${folders.length} folders: ${folders.join(', ')}`);

                // Show folders
                folders.forEach(folder => {
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'folder-item';
                    const folderData = foldersData[folder];
                    const displayName = folderData.displayName || folder.split('/').pop() || folder;
                    const createdAt = folderData.createdAt ? new Date(folderData.createdAt).toLocaleString('id-ID') : 'N/A';
                    const escapedFolder = folder.replace(/'/g, "\\'");
                    
                    if (currentViewMode === 'grid') {
                        folderDiv.innerHTML = `
                            <input type="checkbox" class="item-checkbox" onchange="toggleItemSelection('folder', '${escapedFolder}', this)">
                            <div class="file-icon">üìÅ</div>
                            <div class="file-name">${displayName}</div>
                            <div class="file-info">Folder</div>
                            <div class="file-actions" style="margin-top: 10px;">
                                <button class="btn" onclick="loadFolder('${folder}')" style="margin: 2px; font-size: 11px;">üìÇ</button>
                                <button class="btn-share" onclick="createPublicLink('folder', '${folder}', '${displayName}')" style="margin: 2px; font-size: 11px;">üîó</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('folder', '${folder}')" style="margin: 2px; font-size: 11px;">üóëÔ∏è</button>
                            </div>
                        `;
                    } else {
                        folderDiv.innerHTML = `
                            <input type="checkbox" class="item-checkbox" onchange="toggleItemSelection('folder', '${escapedFolder}', this)">
                            <div class="file-icon">üìÅ</div>
                            <div class="file-details">
                                <div class="file-name">${displayName}</div>
                                <div class="file-info">
                                    Dibuat: ${createdAt}
                                </div>
                            </div>
                            <div class="file-actions">
                                <button class="btn" onclick="loadFolder('${folder}')">üìÇ Buka</button>
                                <button class="btn-share" onclick="createPublicLink('folder', '${folder}', '${displayName}')">üîó Share</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('folder', '${folder}')">üóëÔ∏è Hapus</button>
                            </div>
                        `;
                    }
                    fileList.appendChild(folderDiv);
                });

                // Show files in current folder
                const folderFiles = filesData.filter(file => file.folder === currentFolder);
                
                // Process files with lazy-loaded media preview
                for (const file of folderFiles) {
                    const fileDiv = document.createElement('div');
                    fileDiv.className = 'file-item';
                    fileDiv.dataset.fileId = file.id;
                    
                    // Store file data for multi-select
                    const fileDataJson = JSON.stringify(file).replace(/'/g, "&#39;").replace(/"/g, "&quot;");
                    
                    // For optimized loading, don't load media previews by default unless auto preview is enabled
                    let mediaPreview = '';
                    if (isImageFile(file.name, file.mimetype) || isVideoFile(file.name, file.mimetype)) {
                        const autoPreview = document.getElementById('autoPreviewToggle').checked;
                        
                        if (autoPreview) {
                            // Load preview directly if auto preview is enabled
                            try {
                                let fileWithContent = null;
                                if (storageMode === 'github') {
                                    fileWithContent = await getFileFromGitHubChunks(file);
                                } else {
                                    fileWithContent = await getFileWithChunks(file.id);
                                }
                                
                                if (fileWithContent) {
                                    if (isImageFile(file.name, file.mimetype)) {
                                        mediaPreview = createImagePreview(fileWithContent);
                                    } else if (isVideoFile(file.name, file.mimetype)) {
                                        mediaPreview = createVideoPreview(fileWithContent);
                                    }
                                }
                            } catch (error) {
                                console.warn(`Failed to load auto preview for ${file.name}:`, error);
                                mediaPreview = `
                                    <div class="media-preview-placeholder" onclick="loadMediaPreview('${file.id}', this)">
                                        <div class="preview-icon">‚ùå</div>
                                        <div class="preview-text">Preview failed - click to retry</div>
                                    </div>
                                `;
                            }
                        } else {
                            // Show a placeholder that can be loaded on demand
                            mediaPreview = `
                                <div class="media-preview-placeholder" onclick="loadMediaPreview('${file.id}', this)">
                                    <div class="preview-icon">${isImageFile(file.name, file.mimetype) ? 'üñºÔ∏è' : 'üé•'}</div>
                                    <div class="preview-text">Click to load preview</div>
                                </div>
                            `;
                        }
                    }
                    
                    const chunkInfo = file.isChunked ? `<br>üì¶ Chunked: ${file.totalChunks} parts` : '';
                    const escapedFileName = file.name.replace(/'/g, "\\'");
                    
                    if (currentViewMode === 'grid') {
                        fileDiv.innerHTML = `
                            <input type="checkbox" class="item-checkbox" onchange="toggleItemSelection('file', JSON.parse(this.closest('.file-item').dataset.fileData), this)">
                            <div class="file-icon">${getFileIcon(file.name)}</div>
                            <div class="file-name">${file.name}</div>
                            ${mediaPreview}
                            <div class="file-info">${formatFileSize(file.totalSize || file.size)}</div>
                            <div class="file-actions" style="margin-top: 10px;">
                                <button class="btn" onclick="downloadFile('${file.id}')" style="margin: 2px; font-size: 11px;">üì•</button>
                                <button class="btn-share" onclick="createPublicLink('file', '${file.id}', '${escapedFileName}')" style="margin: 2px; font-size: 11px;">üîó</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('file', '${escapedFileName}', '${file.folder}', '${file.id}')" style="margin: 2px; font-size: 11px;">üóëÔ∏è</button>
                            </div>
                        `;
                    } else {
                        fileDiv.innerHTML = `
                            <input type="checkbox" class="item-checkbox" onchange="toggleItemSelection('file', JSON.parse(this.closest('.file-item').dataset.fileData), this)">
                            <div class="file-icon">${getFileIcon(file.name)}</div>
                            <div class="file-details">
                                <div class="file-name">${file.name}</div>
                                ${mediaPreview}
                                <div class="file-info">
                                    Ukuran: ${formatFileSize(file.totalSize || file.size)}<br>
                                    Upload: ${new Date(file.uploadDate).toLocaleString('id-ID')}<br>
                                    Type: ${file.mimetype || 'Unknown'}${chunkInfo}
                                </div>
                            </div>
                            <div class="file-actions">
                                <button class="btn" onclick="downloadFile('${file.id}')">üì• Download</button>
                                <button class="btn-share" onclick="createPublicLink('file', '${file.id}', '${escapedFileName}')">üîó Share</button>
                                <button class="btn btn-danger" onclick="showDeleteModal('file', '${escapedFileName}', '${file.folder}', '${file.id}')">üóëÔ∏è Hapus</button>
                            </div>
                        `;
                    }
                    // Store file data in dataset for retrieval
                    fileDiv.dataset.fileData = JSON.stringify(file);
                    fileList.appendChild(fileDiv);
                }

                console.log(`üìã File list display completed: ${folders.length} folders, ${folderFiles.length} files shown`);
                
                if (folders.length === 0 && folderFiles.length === 0) {
                    fileList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Tidak ada file atau folder</p>';
                }
                
                // Update select all visibility and clear previous selections
                updateSelectAllVisibility();
                clearMultiSelection();
            } catch (error) {
                console.error('‚ùå Error rendering file list:', error);
                showAlert('Error displaying files: ' + error.message, 'error');
            }
        }

        // Load specific folder
        async function loadFolder(folderName) {
            // If it's an empty folder name (home), just load it directly
            if (!folderName) {
                await actuallyLoadFolder(folderName);
                return;
            }

            try {
                // Get folder data to check if it has password protection
                let folderData = null;
                
                if (storageMode === 'github') {
                    const githubFolders = await getAllGitHubFolders();
                    folderData = githubFolders.find(folder => folder.name === folderName);
                } else {
                    const localFolders = await getFoldersData();
                    folderData = localFolders[folderName];
                }

                // If folder has password protection, show password modal
                if (folderData && folderData.password) {
                    showPasswordModal(folderName, folderData);
                    return;
                }

                // If no password protection, load directly
                await actuallyLoadFolder(folderName);
                
            } catch (error) {
                console.error('Error loading folder:', error);
                showAlert('Error accessing folder: ' + error.message, 'error');
            }
        }

        // Go back to previous folder
        function goBack() {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const previousFolder = navigationHistory[currentHistoryIndex];
                currentFolder = previousFolder;
                loadFileList();
                updateBackButton();
            }
        }

        // Update back button visibility and state
        function updateBackButton() {
            const backButton = document.getElementById('backButton');
            const upLevelBtn = document.getElementById('upLevelBtn');
            
            // Check if elements exist before manipulating them
            if (!backButton || !upLevelBtn) {
                console.warn('‚ö†Ô∏è Navigation buttons not found, skipping button update');
                return;
            }
            
            // Handle back button (history-based)
            if (currentHistoryIndex > 0) {
                backButton.style.display = 'inline-flex';
                backButton.disabled = false;
            } else {
                backButton.style.display = 'none';
                backButton.disabled = true;
            }
            
            // Handle up level button (folder hierarchy-based)
            if (currentFolder && currentFolder.includes('/')) {
                // If we're in a subfolder, show up level button
                upLevelBtn.style.display = 'inline-flex';
                upLevelBtn.disabled = false;
            } else if (currentFolder && !currentFolder.includes('/')) {
                // If we're in root level folder, show up to home
                upLevelBtn.style.display = 'inline-flex';
                upLevelBtn.disabled = false;
            } else {
                // If we're at home, hide up level button
                upLevelBtn.style.display = 'none';
                upLevelBtn.disabled = true;
            }
        }

        // Go up one level in folder hierarchy
        function goUpOneLevel() {
            if (!currentFolder) return; // Already at root
            
            if (currentFolder.includes('/')) {
                // Go up one level in subfolder hierarchy
                const parentPath = currentFolder.substring(0, currentFolder.lastIndexOf('/'));
                loadFolder(parentPath);
            } else {
                // Go to root from top-level folder
                loadFolder('');
            }
        }

        // Update breadcrumb
        function updateBreadcrumb() {
            const breadcrumb = document.getElementById('breadcrumb');
            let html = '<a href="#" onclick="loadFolder(\'\')">üè† Home</a>';
            
            if (currentFolder) {
                html += ` / <span>${currentFolder}</span>`;
            }
            
            breadcrumb.innerHTML = html;
            updateBackButton();
        }

        // ============================================================================
        // PAGINATION AND OPTIMIZATION FUNCTIONS
        // ============================================================================

        // Update pagination UI elements
        function updatePaginationUI(result) {
            const fileCount = document.getElementById('fileCount');
            const cacheStatus = document.getElementById('cacheStatus');
            const paginationNumbers = document.getElementById('paginationNumbers');
            const prevPage = document.getElementById('prevPage');
            const nextPage = document.getElementById('nextPage');
            
            // Update file count and cache status
            const start = (result.currentPage - 1) * FILES_PER_PAGE + 1;
            const end = Math.min(result.currentPage * FILES_PER_PAGE, result.totalFiles);
            fileCount.textContent = `Showing ${start}-${end} of ${result.totalFiles} files`;
            
            if (result.fromCache) {
                cacheStatus.textContent = 'üìã Cached';
                cacheStatus.className = 'cache-status cached';
            } else {
                cacheStatus.textContent = 'üîÑ Fresh';
                cacheStatus.className = 'cache-status';
            }
            
            // Update pagination numbers
            const totalPages = result.totalPages;
            let numbersHtml = '';
            
            // Show page numbers (max 7 pages visible)
            let startPage = Math.max(1, result.currentPage - 3);
            let endPage = Math.min(totalPages, startPage + 6);
            
            if (endPage - startPage < 6) {
                startPage = Math.max(1, endPage - 6);
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const activeClass = i === result.currentPage ? ' active' : '';
                numbersHtml += `<span class="page-number${activeClass}" onclick="changePage(${i})">${i}</span>`;
            }
            
            paginationNumbers.innerHTML = numbersHtml;
            
            // Update prev/next buttons
            prevPage.disabled = result.currentPage <= 1;
            nextPage.disabled = result.currentPage >= totalPages;
        }

        // Change page
        async function changePage(page) {
            if (page < 1 || page > Math.ceil(totalFiles / FILES_PER_PAGE)) return;
            currentPage = page;
            await loadFileList(page);
        }

        // Change items per page
        async function changeItemsPerPage(newLimit) {
            FILES_PER_PAGE = parseInt(newLimit);
            currentPage = 1; // Reset to first page
            await loadFileList(1, true); // Force refresh
        }

        // Refresh file list
        async function refreshFileList(forceRefresh = false) {
            await loadFileList(currentPage, forceRefresh);
        }

        // Lazy load media preview
        async function loadMediaPreview(fileId, placeholderElement) {
            try {
                // Show loading state
                placeholderElement.innerHTML = `
                    <div class="preview-icon">‚è≥</div>
                    <div class="preview-text">Loading preview...</div>
                `;
                
                // Find file in cache first
                let file = getCachedFile(fileId);
                if (!file) {
                    // If not in cache, try to find in current page data
                    const allFiles = Array.from(allFilesCache.values());
                    file = allFiles.find(f => f.id === fileId);
                }
                
                if (!file) {
                    throw new Error('File not found');
                }
                
                let fileWithContent = null;
                
                // Load file content
                if (storageMode === 'github') {
                    fileWithContent = await getFileFromGitHubChunks(file);
                } else {
                    fileWithContent = await getFileWithChunks(file.id);
                }
                
                if (fileWithContent) {
                    let mediaPreview = '';
                    if (isImageFile(file.name, file.mimetype)) {
                        mediaPreview = createImagePreview(fileWithContent);
                    } else if (isVideoFile(file.name, file.mimetype)) {
                        mediaPreview = createVideoPreview(fileWithContent);
                    }
                    
                    // Replace placeholder with actual preview
                    placeholderElement.outerHTML = mediaPreview;
                } else {
                    throw new Error('Could not load file content');
                }
                
            } catch (error) {
                console.warn(`Failed to load preview for ${fileId}:`, error);
                placeholderElement.innerHTML = `
                    <div class="preview-icon">‚ùå</div>
                    <div class="preview-text">Preview failed</div>
                `;
            }
        }

        // Download file
        async function downloadFile(fileId) {
            // Create download operation
            const downloadId = createOperation('Downloading file', 'download');
            
            try {
                updateOperation(downloadId, 10, 'Locating file...');
                let fileWithContent = null;
                
                // Try to get file from appropriate storage based on mode
                if (storageMode === 'github') {
                    updateOperation(downloadId, 25, 'Searching GitHub repository...');
                    
                    // Find file info first
                    const allFiles = await getGitHubFileList();
                    const fileInfo = allFiles.find(f => f.id === fileId);
                    
                    if (fileInfo) {
                        updateOperation(downloadId, 50, `Reconstructing ${fileInfo.name}...`);
                        fileWithContent = await getFileFromGitHubChunks(fileInfo);
                    }
                } else {
                    updateOperation(downloadId, 50, 'Retrieving from local storage...');
                    // IndexedDB only
                    fileWithContent = await getFileWithChunks(fileId);
                }
                
                if (!fileWithContent) {
                    completeOperation(downloadId, '‚ùå File not found');
                    showAlert('File tidak ditemukan', 'error');
                    return;
                }
                
                updateOperation(downloadId, 80, `Preparing download for ${fileWithContent.name}...`);
                console.log(`üì• Downloading ${fileWithContent.name} (${formatFileSize(fileWithContent.totalSize || fileWithContent.size)})`);
                downloadBase64File(fileWithContent.content, fileWithContent.name);
                
                const storageText = storageMode === 'github' ? 'GitHub repository' : 
                                  'local storage';
                
                updateOperation(downloadId, 100, 'Download completed');
                completeOperation(downloadId, `‚úÖ Downloaded ${fileWithContent.name}`);
                showAlert(`‚úÖ File "${fileWithContent.name}" berhasil didownload dari ${storageText}!`, 'success');
            } catch (error) {
                console.error('Download error:', error);
                completeOperation(downloadId, '‚ùå Download failed');
                showAlert('Error downloading file: ' + error.message, 'error');
            }
        }

        // Show delete modal
        function showDeleteModal(type, name, folder = '', fileId = '') {
            deleteItem = { type, name, folder, fileId };
            document.getElementById('deleteMessage').textContent = 
                `Apakah Anda yakin ingin menghapus ${type === 'folder' ? 'folder' : 'file'} "${name}"?`;
            document.getElementById('deleteModal').style.display = 'block';
        }

        // Close delete modal
        function closeDeleteModal() {
            document.getElementById('deleteModal').style.display = 'none';
            document.getElementById('deletePassword').value = '';
            deleteItem = null;
        }

        // Password verification functions
        let pendingFolderAccess = null;

        function showPasswordModal(folderName, folderData) {
            pendingFolderAccess = { folderName, folderData };
            document.getElementById('passwordMessage').textContent = 
                `The folder "${folderData.displayName || folderName}" is password protected. Please enter the password to access it.`;
            document.getElementById('passwordModal').style.display = 'block';
            
            const passwordInput = document.getElementById('folderAccessPassword');
            passwordInput.focus();
            
            // Add Enter key listener
            passwordInput.onkeypress = function(event) {
                if (event.key === 'Enter') {
                    verifyFolderPassword();
                }
            };
        }

        function closePasswordModal() {
            document.getElementById('passwordModal').style.display = 'none';
            document.getElementById('folderAccessPassword').value = '';
            pendingFolderAccess = null;
        }

        async function verifyFolderPassword() {
            const password = document.getElementById('folderAccessPassword').value;

            if (!pendingFolderAccess) {
                showAlert('No folder access pending', 'error');
                return;
            }

            try {
                const hashedPassword = password ? await hashPassword(password) : null;
                
                if (hashedPassword === pendingFolderAccess.folderData.password) {
                    // Password correct, access the folder
                    closePasswordModal();
                    const folderName = pendingFolderAccess.folderName;
                    pendingFolderAccess = null;
                    
                    // Now actually load the folder
                    await actuallyLoadFolder(folderName);
                    showAlert(`‚úÖ Access granted to folder "${folderName}"`, 'success');
                } else {
                    showAlert('‚ùå Incorrect password', 'error');
                    document.getElementById('folderAccessPassword').value = '';
                    document.getElementById('folderAccessPassword').focus();
                }
            } catch (error) {
                console.error('Password verification error:', error);
                showAlert('Error verifying password', 'error');
            }
        }

        function showPasswordRecovery() {
            document.getElementById('passwordModal').style.display = 'none';
            document.getElementById('passwordRecoveryModal').style.display = 'block';
        }

        function closePasswordRecoveryModal() {
            document.getElementById('passwordRecoveryModal').style.display = 'none';
        }

        async function removePasswordProtection() {
            if (!pendingFolderAccess) {
                showAlert('No folder selected for password removal', 'error');
                return;
            }

            try {
                const folderData = pendingFolderAccess.folderData;
                const folderName = pendingFolderAccess.folderName;

                // Remove password from folder data
                folderData.password = null;

                // Save updated folder data
                if (storageMode === 'github') {
                    await saveGitHubFolder(folderData);
                } else {
                    await saveFolder(folderData);
                }

                closePasswordRecoveryModal();
                closePasswordModal();
                
                // Now load the folder
                await actuallyLoadFolder(folderName);
                showAlert(`‚úÖ Password protection removed from folder "${folderName}"`, 'success');
                
                // Refresh folder list to update UI
                await loadFolders();
                
                pendingFolderAccess = null;
            } catch (error) {
                console.error('Error removing password protection:', error);
                showAlert('Error removing password protection', 'error');
            }
        }

        // Separate function for actually loading folder (without password check)
        async function actuallyLoadFolder(folderName) {
            // Add to navigation history (only if not going back)
            if (currentHistoryIndex === -1 || navigationHistory[currentHistoryIndex] !== folderName) {
                // Remove any forward history if we're navigating to a new folder
                if (currentHistoryIndex < navigationHistory.length - 1) {
                    navigationHistory = navigationHistory.slice(0, currentHistoryIndex + 1);
                }
                navigationHistory.push(folderName);
                currentHistoryIndex = navigationHistory.length - 1;
            }
            
            currentFolder = folderName;
            await loadFileList();
            updateBackButton();
        }

        // Utility functions
        function showAlert(message, type = 'info', duration = 5000) {
            // Add to log system - clean message from emojis and add notification prefix
            const cleanMessage = message.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F600}-\u{1F64F}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{1F900}-\u{1F9FF}]|[\u{1FA00}-\u{1FA6F}]|[\u{1FA70}-\u{1FAFF}]|[\u{231A}-\u{231B}]|[\u{23E9}-\u{23F3}]|[\u{23F8}-\u{23FA}]|[\u{25AA}-\u{25AB}]|[\u{25B6}]|[\u{25C0}]|[\u{25FB}-\u{25FE}]|[\u{2614}-\u{2615}]|[\u{2648}-\u{2653}]|[\u{267F}]|[\u{2693}]|[\u{26A1}]|[\u{26AA}-\u{26AB}]|[\u{26BD}-\u{26BE}]|[\u{26C4}-\u{26C5}]|[\u{26CE}]|[\u{26D4}]|[\u{26EA}]|[\u{26F2}-\u{26F3}]|[\u{26F5}]|[\u{26FA}]|[\u{26FD}]|[\u{2702}]|[\u{2705}]|[\u{2708}-\u{270D}]|[\u{270F}]|[\u{2712}]|[\u{2714}]|[\u{2716}]|[\u{271D}]|[\u{2721}]|[\u{2728}]|[\u{2733}-\u{2734}]|[\u{2744}]|[\u{2747}]|[\u{274C}]|[\u{274E}]|[\u{2753}-\u{2755}]|[\u{2757}]|[\u{2763}-\u{2764}]|[\u{2795}-\u{2797}]|[\u{27A1}]|[\u{27B0}]|[\u{27BF}]|[\u{2934}-\u{2935}]|[\u{2B05}-\u{2B07}]|[\u{2B1B}-\u{2B1C}]|[\u{2B50}]|[\u{2B55}]|[\u{3030}]|[\u{303D}]|[\u{3297}]|[\u{3299}]/gu, '').trim();
            const logType = type === 'success' ? 'success' : type === 'error' ? 'error' : type === 'warning' ? 'warning' : 'info';
            addLog(`[Notification] ${cleanMessage}`, logType);
            
            const toastContainer = document.getElementById('toastContainer');
            
            // Limit number of toasts (max 5)
            const existingToasts = toastContainer.querySelectorAll('.toast');
            if (existingToasts.length >= 5) {
                // Remove oldest toast
                const oldestToast = existingToasts[0];
                hideToast(oldestToast);
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            // Add message container
            const messageDiv = document.createElement('div');
            messageDiv.className = 'toast-message';
            messageDiv.textContent = message;
            
            // Add close button
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '√ó';
            closeBtn.onclick = () => hideToast(toast);
            closeBtn.setAttribute('aria-label', 'Close notification');
            
            // Add progress bar (only if duration > 0)
            let progressBar = null;
            if (duration > 0) {
                progressBar = document.createElement('div');
                progressBar.className = 'toast-progress';
                progressBar.style.animationDuration = `${duration}ms`;
            }
            
            // Assemble toast
            toast.appendChild(messageDiv);
            toast.appendChild(closeBtn);
            if (progressBar) {
                toast.appendChild(progressBar);
            }
            
            // Add to container
            toastContainer.appendChild(toast);
            
            // Show animation
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });
            });
            
            // Auto hide (if duration > 0)
            let hideTimer = null;
            if (duration > 0) {
                hideTimer = setTimeout(() => {
                    hideToast(toast);
                }, duration);
            }
            
            // Store timer for manual close
            toast._hideTimer = hideTimer;
            
            return toast;
        }
        
        function hideToast(toast) {
            if (!toast || !toast.parentNode) return;
            
            if (toast._hideTimer) {
                clearTimeout(toast._hideTimer);
                toast._hideTimer = null;
            }
            
            toast.classList.remove('show');
            toast.classList.add('hide');
            
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 400);
        }
        
        // Clear all toasts
        function clearAllToasts() {
            const toastContainer = document.getElementById('toastContainer');
            const toasts = toastContainer.querySelectorAll('.toast');
            toasts.forEach(toast => hideToast(toast));
        }
        
        // Test notification system
        function testNotifications() {
            // Clear existing toasts first
            clearAllToasts();
            
            // Show demo notifications with delays
            setTimeout(() => showAlert('Data berhasil disimpan ke GitHub repository!', 'success'), 200);
            setTimeout(() => showAlert('Sedang memvalidasi koneksi ke server...', 'info', 3000), 800);
            setTimeout(() => showAlert('Token GitHub akan kedaluwarsa dalam 7 hari', 'warning'), 1400);
            setTimeout(() => showAlert('Gagal terhubung ke server backup', 'error'), 2000);
            setTimeout(() => showAlert('Folder "Documents" berhasil dibuat dengan 25 file', 'success', 4000), 2600);
        }
        
        // Test large file upload functionality
        function testLargeFileSupport() {
            // Clear existing toasts
            clearAllToasts();
            
            // Show demo of large file support
            setTimeout(() => showAlert('Sistem mendukung file hingga 2GB', 'info'), 200);
            setTimeout(() => showAlert('File besar akan dipecah menjadi chunk 20MB', 'info'), 800);
            setTimeout(() => showAlert('Progress bar akan tampil untuk file >50MB', 'info'), 1400);
            setTimeout(() => showAlert('File berhasil diupload dengan chunking system', 'success'), 2000);
        }
        
        // Legacy function for compatibility
        function showAlertLegacy(message, type) {
            const alertArea = document.getElementById('alertArea');
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            alertArea.innerHTML = '';
            alertArea.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // Media preview functions
        function isImageFile(filename, mimetype) {
            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg'];
            const imageMimeTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/bmp', 'image/webp', 'image/svg+xml'];
            
            const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return imageExtensions.includes(extension) || (mimetype && imageMimeTypes.includes(mimetype.toLowerCase()));
        }

        function isVideoFile(filename, mimetype) {
            const videoExtensions = ['.mp4', '.webm', '.ogg', '.avi', '.mov', '.wmv', '.flv', '.mkv'];
            const videoMimeTypes = ['video/mp4', 'video/webm', 'video/ogg', 'video/avi', 'video/quicktime', 'video/x-msvideo'];
            
            const extension = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return videoExtensions.includes(extension) || (mimetype && videoMimeTypes.includes(mimetype.toLowerCase()));
        }

        function createImagePreview(file) {
            // Clean base64 data (remove data URL prefix if present)
            let cleanBase64 = file.content;
            if (file.content && file.content.includes(',')) {
                cleanBase64 = file.content.split(',')[1];
            }
            
            return `
                <div class="media-preview">
                    <img src="data:${file.mimetype || 'image/jpeg'};base64,${cleanBase64}" 
                         alt="${file.name}" 
                         style="max-width: 200px; max-height: 150px; border-radius: 8px; cursor: pointer; object-fit: cover;"
                         onclick="showFullImage('${file.id}', '${file.name}', '${file.mimetype}', '${cleanBase64}')"
                         onerror="this.parentElement.innerHTML='<div class=\\'preview-icon\\'>üñºÔ∏è</div><div class=\\'preview-text\\'>Image preview failed</div>'" />
                </div>
            `;
        }

        function createVideoPreview(file) {
            // Clean base64 data (remove data URL prefix if present)
            let cleanBase64 = file.content;
            if (file.content && file.content.includes(',')) {
                cleanBase64 = file.content.split(',')[1];
            }
            
            return `
                <div class="media-preview">
                    <video controls style="max-width: 200px; max-height: 150px; border-radius: 8px;">
                        <source src="data:${file.mimetype || 'video/mp4'};base64,${cleanBase64}" type="${file.mimetype || 'video/mp4'}">
                        Your browser does not support the video tag.
                    </video>
                </div>
            `;
        }

        function showFullImage(fileId, fileName, mimetype, content) {
            try {
                // Create modal for full image view
                const modal = document.createElement('div');
                modal.className = 'image-modal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    cursor: pointer;
                `;
                
                modal.innerHTML = `
                    <div style="max-width: 90%; max-height: 90%; text-align: center;">
                        <img src="data:${mimetype || 'image/jpeg'};base64,${content}" 
                             style="max-width: 100%; max-height: 100%; border-radius: 8px;" 
                             alt="${fileName}"
                             onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkVycm9yIGxvYWRpbmcgaW1hZ2U8L3RleHQ+PC9zdmc+'" />
                        <div style="color: white; margin-top: 10px; font-size: 16px;">${fileName}</div>
                        <div style="color: #ccc; margin-top: 5px; font-size: 12px;">Click anywhere to close</div>
                    </div>
                `;
                
                modal.onclick = function() {
                    document.body.removeChild(modal);
                };
                
                document.body.appendChild(modal);
            } catch (error) {
                console.error('Error showing full image:', error);
                showAlert('Error displaying image: ' + error.message, 'error');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('deleteModal');
            if (event.target === modal) {
                closeDeleteModal();
            }
        }

        // Add public link modal creation function
        function createPublicLinkModal() {
            const modalHtml = `
                <!-- Public Link Modal -->
                <div id="publicLinkModal" class="public-link-modal">
                    <div class="public-link-modal-content">
                        <div class="public-link-header">
                            <h3>üîó Create Public Link</h3>
                            <button class="close-modal" onclick="closePublicLinkModal()">&times;</button>
                        </div>
                        
                        <div class="link-config-section">
                            <h4>üìÑ Item Details</h4>
                            <div class="config-row">
                                <div class="config-label">Type:</div>
                                <div class="config-input">
                                    <span id="linkItemType">File</span>
                                </div>
                            </div>
                            <div class="config-row">
                                <div class="config-label">Name:</div>
                                <div class="config-input">
                                    <span id="linkItemName">example.txt</span>
                                </div>
                            </div>
                        </div>

                        <div class="link-config-section">
                            <h4>‚öôÔ∏è Link Configuration</h4>
                            <div class="config-row">
                                <div class="config-label">Expiry Time:</div>
                                <div class="config-input">
                                    <select id="linkExpiry">
                                        <option value="1h">1 Hour</option>
                                        <option value="24h" selected>24 Hours</option>
                                        <option value="7d">7 Days</option>
                                        <option value="30d">30 Days</option>
                                        <option value="never">Never Expires</option>
                                    </select>
                                </div>
                            </div>
                            <div class="config-row">
                                <div class="config-label">Password Protection:</div>
                                <div class="config-input">
                                    <input type="text" id="linkPassword" placeholder="Optional password">
                                </div>
                            </div>
                            <div class="config-row">
                                <div class="config-label">Permissions:</div>
                                <div class="config-input">
                                    <select id="linkPermissions">
                                        <option value="view" selected>View Only</option>
                                        <option value="download">View & Download</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div style="text-align: center; margin: 25px 0;">
                            <button class="btn" onclick="generatePublicLink()" style="padding: 12px 30px; font-size: 16px;">
                                üîó Generate Link
                            </button>
                        </div>

                        <div id="generatedLinkSection" class="generated-link-section" style="display: none;">
                            <h4>üéâ Public Link Generated!</h4>
                            <div class="link-display">
                                <input type="text" id="generatedLink" class="link-input" readonly>
                            </div>
                            <div class="link-actions">
                                <button class="btn-copy" onclick="copyPublicLink()">üìã Copy Link</button>
                                <button class="btn-qr" onclick="generateQRCode()">üì± QR Code</button>
                            </div>
                            <div id="qrCodeContainer" class="qr-code-container" style="display: none;"></div>
                            <div id="linkStats" class="link-stats" style="display: none;"></div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Add a small delay to ensure everything is loaded
            setTimeout(() => {
                checkSharedLink();
            }, 100);
        });

        // Also check for shared links when the page becomes visible
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                checkSharedLink();
            }
        });

        // ============================================================================
        // MULTI-SELECT FUNCTIONALITY
        // ============================================================================
        
        // Store selected items
        let selectedItems = {
            files: [],    // Array of file objects
            folders: []   // Array of folder names
        };

        // Toggle item selection
        function toggleItemSelection(type, itemData, checkbox) {
            const itemElement = checkbox.closest(type === 'file' ? '.file-item' : '.folder-item');
            
            if (checkbox.checked) {
                // Add to selection
                if (type === 'file') {
                    if (!selectedItems.files.find(f => f.id === itemData.id)) {
                        selectedItems.files.push(itemData);
                    }
                } else {
                    if (!selectedItems.folders.includes(itemData)) {
                        selectedItems.folders.push(itemData);
                    }
                }
                itemElement.classList.add('selected');
            } else {
                // Remove from selection
                if (type === 'file') {
                    selectedItems.files = selectedItems.files.filter(f => f.id !== itemData.id);
                } else {
                    selectedItems.folders = selectedItems.folders.filter(f => f !== itemData);
                }
                itemElement.classList.remove('selected');
            }
            
            updateMultiSelectUI();
        }

        // Update multi-select toolbar and UI
        function updateMultiSelectUI() {
            const totalSelected = selectedItems.files.length + selectedItems.folders.length;
            const toolbar = document.getElementById('multiSelectToolbar');
            const selectCount = document.getElementById('selectCount');
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const selectionInfo = document.getElementById('selectionInfo');
            
            if (totalSelected > 0) {
                toolbar.classList.add('show');
                selectCount.textContent = `${totalSelected} selected`;
                
                // Update selection info
                const fileCount = selectedItems.files.length;
                const folderCount = selectedItems.folders.length;
                let info = [];
                if (fileCount > 0) info.push(`${fileCount} file${fileCount > 1 ? 's' : ''}`);
                if (folderCount > 0) info.push(`${folderCount} folder${folderCount > 1 ? 's' : ''}`);
                selectionInfo.textContent = info.join(', ');
            } else {
                toolbar.classList.remove('show');
                selectionInfo.textContent = '';
            }
            
            // Update select all checkbox state
            const allCheckboxes = document.querySelectorAll('.item-checkbox');
            const checkedCheckboxes = document.querySelectorAll('.item-checkbox:checked');
            
            if (allCheckboxes.length > 0) {
                selectAllCheckbox.checked = allCheckboxes.length === checkedCheckboxes.length;
                selectAllCheckbox.indeterminate = checkedCheckboxes.length > 0 && checkedCheckboxes.length < allCheckboxes.length;
            }
        }

        // Toggle select all
        function toggleSelectAll(checked) {
            const allCheckboxes = document.querySelectorAll('.item-checkbox');
            
            allCheckboxes.forEach(checkbox => {
                if (checkbox.checked !== checked) {
                    checkbox.checked = checked;
                    checkbox.dispatchEvent(new Event('change'));
                }
            });
        }

        // Clear all selections
        function clearMultiSelection() {
            selectedItems.files = [];
            selectedItems.folders = [];
            
            // Uncheck all checkboxes
            document.querySelectorAll('.item-checkbox').forEach(cb => cb.checked = false);
            document.querySelectorAll('.file-item.selected, .folder-item.selected').forEach(el => el.classList.remove('selected'));
            document.getElementById('selectAllCheckbox').checked = false;
            
            updateMultiSelectUI();
        }

        // Download selected items
        async function downloadSelectedItems() {
            const totalItems = selectedItems.files.length + selectedItems.folders.length;
            
            if (totalItems === 0) {
                showAlert('‚ö†Ô∏è No items selected', 'warning');
                return;
            }
            
            if (selectedItems.folders.length > 0) {
                showAlert('‚ö†Ô∏è Folder download is not yet supported. Only files will be downloaded.', 'warning');
            }
            
            if (selectedItems.files.length === 0) {
                return;
            }
            
            showAlert(`üì• Downloading ${selectedItems.files.length} file(s)...`, 'info');
            addLog(`Starting batch download of ${selectedItems.files.length} files`, 'info');
            
            let successCount = 0;
            let failCount = 0;
            
            for (const file of selectedItems.files) {
                try {
                    await downloadFile(file.id);
                    successCount++;
                    // Small delay between downloads
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error(`Failed to download ${file.name}:`, error);
                    failCount++;
                }
            }
            
            if (failCount === 0) {
                showAlert(`‚úÖ Successfully downloaded ${successCount} file(s)`, 'success');
            } else {
                showAlert(`‚ö†Ô∏è Downloaded ${successCount} file(s), ${failCount} failed`, 'warning');
            }
            
            addLog(`Batch download completed: ${successCount} success, ${failCount} failed`, 'info');
        }

        // Delete selected items
        async function deleteSelectedItems() {
            const totalItems = selectedItems.files.length + selectedItems.folders.length;
            
            if (totalItems === 0) {
                showAlert('‚ö†Ô∏è No items selected', 'warning');
                return;
            }
            
            // Build confirmation message
            let confirmMsg = `Are you sure you want to delete:\n`;
            if (selectedItems.files.length > 0) {
                confirmMsg += `‚Ä¢ ${selectedItems.files.length} file(s)\n`;
            }
            if (selectedItems.folders.length > 0) {
                confirmMsg += `‚Ä¢ ${selectedItems.folders.length} folder(s)\n`;
            }
            confirmMsg += `\nThis action cannot be undone!`;
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            showAlert(`üóëÔ∏è Deleting ${totalItems} item(s)...`, 'info');
            addLog(`Starting batch delete of ${totalItems} items`, 'info');
            
            let successCount = 0;
            let failCount = 0;
            
            // Delete files
            for (const file of selectedItems.files) {
                try {
                    if (storageMode === 'github') {
                        await deleteFileInfoFromGitHub(file);
                    } else {
                        await deleteFileFromIndex(file.id);
                    }
                    successCount++;
                } catch (error) {
                    console.error(`Failed to delete file ${file.name}:`, error);
                    failCount++;
                }
            }
            
            // Delete folders
            for (const folderName of selectedItems.folders) {
                try {
                    if (storageMode === 'github') {
                        await deleteGitHubFolder(folderName);
                    } else {
                        await deleteFolder(folderName);
                    }
                    successCount++;
                } catch (error) {
                    console.error(`Failed to delete folder ${folderName}:`, error);
                    failCount++;
                }
            }
            
            // Clear selection and refresh
            clearMultiSelection();
            await loadFileList();
            
            if (failCount === 0) {
                showAlert(`‚úÖ Successfully deleted ${successCount} item(s)`, 'success');
            } else {
                showAlert(`‚ö†Ô∏è Deleted ${successCount} item(s), ${failCount} failed`, 'warning');
            }
            
            addLog(`Batch delete completed: ${successCount} success, ${failCount} failed`, 'info');
        }

        // Show/hide select all container based on file list content
        function updateSelectAllVisibility() {
            const selectAllContainer = document.getElementById('selectAllContainer');
            const fileList = document.getElementById('fileList');
            const hasItems = fileList.querySelectorAll('.file-item, .folder-item').length > 0;
            
            selectAllContainer.style.display = hasItems ? 'flex' : 'none';
        }
    </script>
</body>
</html>
